<?php

/**
 * @file
 * This module provides functionality for pre-populating forms from
 *   an encrypted query string parameter without bootstrapping drupal
 *   or busting cache.
 */

/**
 * Implements hook_js_info().
 */
function secure_autofill_js_info() {
  $callbacks['get_amounts'] = array(
      'methods' => array('POST'),
      'token' => FALSE,
    );
  $callbacks['get_values'] = array(
    'methods' => array('POST'),
    'token' => FALSE,
  );
  return $callbacks;
}

/**
 * Implements MODULE_js_callback_CALLBACK().
 *
 * Callback for decrypting a dynamic gift string.
 */
function secure_autofill_js_callback_get_amounts($gs) {
  $json = array();

  // Ensure that the gift string variable was provided.
  if (empty($gs)) {
    drupal_set_message(t('You must provide a gift string.'), 'error');
    $json['content'] = NULL;
  }
  else {
    // Decrypt gs per dynamic gift strings.
    // TODO check for expiration as appropriate.
    $raw_qs = secure_autofill_decrypt($gs);
    $json['content'] = secure_autofill_parse_qs($raw_qs);
  }

  return $json;
}

/**
 * Implements MODULE_js_callback_CALLBACK().
 *
 * Callback for decrypting a secure prepopulate string.
 */
function secure_autofill_js_callback_get_values($af) {
  $json = array();

  // Ensure that the gift string variable was provided.
  if (empty($af)) {
    drupal_set_message(t('You must provide a query string.'), 'error');
    $json['content'] = NULL;
  }
  else {
    // Decrypt af
    // TODO check for expiration as appropriate.
    $raw_qs = secure_autofill_decrypt($af);
    $json['content'] = secure_autofill_parse_qs($raw_qs);
  }

  return $json;
}

/**
 * Implements hook_form_alter().
 *
 * Add secure_autofill js to donation forms, bypass amount validation.
 */
function secure_autofill_form_alter(&$form, &$form_state, $form_id) {
  if (strstr($form_id, 'webform_client_form') !== FALSE && fundraiser_is_donation_type($form['#node']->type) && arg(4) != 'edit') {
    // Attach ask amount handler.
    $form['#attached']['js'][] = drupal_get_path('module', 'secure_autofill') . '/js/secure-autofill.js';
    // Attach jquery cookie.
    $form['#attached']['library'][] = array('system', 'jquery.cookie');
    // Bypass amount field validation so we can inject our values.
    if (isset($form['submitted']['donation']['amount'])) {
      $form['submitted']['donation']['amount']['#webform_validated'] = TRUE;
    }
    if (isset($form['submitted']['donation']['recurring_amount'])) {
      $form['submitted']['donation']['recurring_amount']['#webform_validated'] = TRUE;
    }

    // Add form validate handler to ensure only numeric and 'other' values can be entered into 'amount'.
    $form['#validate'][] = "secure_autofill_donation_amount_validate";

    // Add the submit handler.
    $form['#submit'][] = 'secure_autofill_submit';
  }
}

/**
 * Validate handler for amounts.
 */
function secure_autofill_donation_amount_validate($form, &$form_state) {
  // Ensure that donation amount is set and numeric or 'other'.
  // First, filter XSS and get our values from form_state.
  $donation_amount = filter_xss($form_state['values']['submitted']['donation']['amount']);
  $recurring_amount = filter_xss($form_state['values']['submitted']['donation']['recurring_amount']);
  $recurring_selection = $form_state['values']['submitted']['donation']['recurs_monthly'];

  // Ensure that amount is set for recurring and one-time donations.
  if (
    ($form['#node']->recurring_setting == 'always' && empty($recurring_amount))
    || (
      $form['#node']->recurring_setting == 'user_choice' && $form['#node']->recurring_dual_ask_amounts
      && (is_array($recurring_selection) ? $recurring_selection['recurs'] === 'recurs'
        : $recurring_selection == 'recurs') && empty($recurring_amount))
  ) {
    // No recurring amount was selected with dual ask., throw error.
    form_set_error('recurring_amount', t('You must select a recurring donation amount.'));
  }
  elseif (
    ($form['#node']->recurring_setting == 'always' && empty($donation_amount))
    || (
      $form['#node']->recurring_setting == 'user_choice' && !$form['#node']->recurring_dual_ask_amounts
      && (is_array($recurring_selection) ? $recurring_selection['recurs'] === 'recurs'
        : $recurring_selection == 'recurs') && empty($donation_amount))
  ) {
    // No recurring amount was selected without dual ask, throw error.
    form_set_error('amount', t('You must select a recurring donation amount.'));
  }
  elseif (
    ($form['#node']->recurring_setting == 'never' && empty($donation_amount))
    || (
      $form['#node']->recurring_setting == 'user_choice' && (is_array($recurring_selection) ? $recurring_selection['recurs'] === 0
        : $recurring_selection == 'NO_RECURR') && empty($donation_amount)
    )
  ) {
    // No amount was selected for one-time donation, throw error.
    form_set_error('amount', t('You must select a donation amount.'));
  }
  elseif (
    ($form['#node']->recurring_setting == 'always' && (!is_numeric($recurring_amount) || $recurring_amount != 'other'))
    || (
      $form['#node']->recurring_setting == 'user_choice' && $form['#node']->recurring_dual_ask_amounts
      && (is_array($recurring_selection) ? !empty($recurring_selection['recurs'])
        : $recurring_selection == 'recurs') && (!is_numeric($recurring_amount) && $recurring_amount != 'other')
    )
    ) {
    // Bad amount format for recurring with dual ask.
    form_set_error('recurring_amount', t('You must provide a recurring donation amount in the correct format.'));
  }
  elseif (
    ($form['#node']->recurring_setting == 'always' && (!is_numeric($donation_amount) || $donation_amount != 'other'))
    || (
      $form['#node']->recurring_setting == 'user_choice' && !$form['#node']->recurring_dual_ask_amounts
      && (is_array($recurring_selection) ? !empty($recurring_selection['recurs'])
        : $recurring_selection == 'recurs') && (!is_numeric($donation_amount) && $donation_amount != 'other')
    )
    ) {
    // Bad amount format for recurring without dual ask.
    form_set_error('recurring_amount', t('You must provide a recurring donation amount in the correct format.'));
  }
  elseif (
    ($form['#node']->recurring_setting == 'never' && (!is_numeric($donation_amount) || $donation_amount != 'other'))
    || (
      $form['#node']->recurring_setting == 'user_choice' && (is_array($recurring_selection) ? $recurring_selection['recurs'] === 0
        : $recurring_selection == 'NO_RECURR') && (!is_numeric($donation_amount) && $donation_amount != 'other')
    )
  ) {
    // Bad amount format for one-time.
    form_set_error('amount', t('You must provide a donation amount in the correct format.'));
  }
}

function secure_autofill_decrypt($cipher) {
  // The 128 bit key to use to decrypt the string.
  $key = secure_autofill_variable_get('secure_prepopulate_key', NULL);
  // The initialization vector to use to decrypt the string.
  $iv = secure_autofill_variable_get('secure_prepopulate_iv', NULL);
  if (!$key || !$iv) {
    drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);
    watchdog('Secure Autofill', 'Cannot perform decryption because AES Key and IV have not been configured correctly.', NULL, WATCHDOG_CRITICAL);
    return FALSE;
  }
  $kv = array('key' => $key, 'iv' => $iv);
  $cipher = base64_decode($cipher);
  $descriptor = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');
  mcrypt_generic_init($descriptor, $kv['key'], $kv['iv']);
  $decrypted_data = mdecrypt_generic($descriptor, $cipher);
  mcrypt_generic_deinit($descriptor);
  mcrypt_module_close($descriptor);
  // Account for some PHP AES shortcomings.
  $decrypted_data = _secure_autofill_pkcs5_unpad($decrypted_data);
  $decrypted_data = rtrim($decrypted_data);
  return $decrypted_data;
}

/**
 * Helper function, Parses the decrypted query string into an array.
 *
 * @param $qs
 *   The query string to parse in key/value pair format.
 */
function secure_autofill_parse_qs($qs) {
  $result = array();
  $segments = explode('&', $qs);
  // Loop over each field in the segement and extract the key/value pairs.
  if (count($segments)) {
    foreach ($segments as $segment) {
      $key_value = explode('=', $segment);
      if (isset($key_value[1])) {
        $result[$key_value[0]] = $key_value[1];
      } else {
        // No key given, so fall back to numeric index.
        $result[] = $key_value[0];
      }
    }
  }
  return $result;
}

/**
 * Helper function, gets variables without bootstrap.
 *
 * @param $name
 *   The var name to get.
 * @param $default
 *   The var to return if $name is not found.
 */
function secure_autofill_variable_get($name, $default = NULL) {
  // Use db_query here for performance reasons, see https://www.drupal.org/node/310075.
  $result = db_query("SELECT value FROM {variable} WHERE name = :name", array(":name" => $name))->fetchField();

  return isset($result) ? unserialize($result) : $default;
}

/**
 * Helper function, for padding text to PKCS5 specification.
 *
 * @param $text
 *   The text to pad.
 * @param $blocksize
 *   The size of the PKCS5 blocksize to use.
 */
function _secure_autofill_pkcs5_pad($text, $blocksize) {
  $pad = $blocksize - (strlen($text) % $blocksize);
  return $text . str_repeat(chr($pad), $pad);
}

/**
 * Helper function, to unpad PKCS5 padded text.
 *
 * @param $text
 *   The text to unpad.
 */
function _secure_autofill_pkcs5_unpad($text) {
  $pad = ord($text{strlen($text) -1});
  if ($pad > strlen($text)) {
    return FALSE;
  }
  return substr($text, 0, -1 * $pad);
}

/**
 * Submit handler for forms that have been prepopulated.
 */
function secure_autofill_submit(&$form, &$form_state) {
  $node = $form['#node'];
  secure_autofill_clear_cookies($node->nid);
}

/**
 * Helper function, Clears the gs/af cookies.
 *
 * @param $nid
 *   The id of the node who's prepopulated data should be cleared.
 */
function secure_autofill_clear_cookies($nid) {
  // Unset secure prepopulate hash.
  if (isset($_COOKIE['af-'. $nid])) {
    unset($_COOKIE['af-'. $nid]);
    setcookie('af-'. $nid, '', time() - 3600, '/'); // empty value and old timestamp
  }
  // Unset gift string hash.
  if (isset($_COOKIE['gs-'. $nid])) {
    unset($_COOKIE['gs-'. $nid]);
    setcookie('gs-'. $nid, '', time() - 3600, '/'); // empty value and old timestamp
  }
}
