<?php

/**
 * @file
 * Provides Salesforce integration functionality specific to NGOC.
 */

define('SALESFORCE_NGOC_DEFAULT_EMAIL_TYPE', 'Home');
define('SALESFORCE_NGOC_DEFAULT_ADDRESS_TYPE', 'Home');
define('SALESFORCE_NGOC_DEFAULT_PAYMENT_METHOD_TYPE', 'Third Party Charge');
define('SALESFORCE_NGOC_DEFAULT_RECORD_TYPE', 'Donation');
define('SALESFORCE_NGOC_DEFAULT_TRANSACTION_TYPE', 'Payment');
define('SALESFORCE_NGOC_DEFAULT_FREQUENCY', 'One Payment');
define('SALESFORCE_NGOC_DEFAULT_POLL_RECORD_LIMIT', 2000);

/**
 * Implements hook_cron().
 */
function salesforce_ngoc_cron() {
  watchdog('salesforce_ngoc', 'Standard cron run.', NULL, WATCHDOG_INFO);
  salesforce_ngoc_poll_batch_upload();
}

/**
 * Implements hook_entity_info().
 */
function salesforce_ngoc_entity_info() {
  return array(
    'salesforce_ngoc_sync_map' => array(
      'label' => t('NGOC Batch Upload Sync Map'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'base table' => 'salesforce_ngoc_sync_map',
      'entity keys' => array(
        'id' => 'id',
      ),
      'fieldable' => FALSE,
      'exportable' => FALSE,
      'module' => 'salesforce_ngoc',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function salesforce_ngoc_menu() {
  $items['admin/config/salesforce/salesforce-ngoc'] = array(
    'title' => 'Salesforce NGO Connect',
    'description' => 'Configuration settings for the Salesforce NGO Connect',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_ngoc_admin_form'),
    'access arguments' => array('administer salesforce ngoc'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/salesforce_ngoc.admin.inc',
  );
  $items['salesforce_ngoc_cron'] = array(
    'page callback' => 'salesforce_ngoc_standalone_cron',
    'access callback' => 'salesforce_ngoc_standalone_cron_access',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function salesforce_ngoc_permission() {
  return array(
    'administer salesforce ngoc' => array(
      'description' => t('Configure settings for the Salesforce NGO Connect.'),
      'title' => t('Configure Salesforce NGOC'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_salesforce_genmap_map_fields_alter().
 */
function salesforce_ngoc_salesforce_genmap_map_fields_alter(&$fields, $context) {
  // The batch upload object needs some system flags set correct in order
  // to do it's thing. Let's do that here instead of implementing in the
  // mapping interface because these flags have no donation counterpart.
  if ($context['module'] == 'salesforce_donation' && $context['map']->salesforce_object_type == 'rC_Connect__Batch_Upload__c') {
    $fields['rC_Connect__Giving_Paid__c'] = TRUE;
    $fields['rC_Connect__Contact_1_Email_Type__c'] = variable_get('salesforce_ngoc_default_email_type', SALESFORCE_NGOC_DEFAULT_EMAIL_TYPE);
    $fields['rC_Connect__Address_Type__c'] = variable_get('salesforce_ngoc_default_address_type', SALESFORCE_NGOC_DEFAULT_ADDRESS_TYPE);
    $fields['rC_Connect__Giving_Transaction_Type__c'] = variable_get('salesforce_ngoc_default_transaction_type', SALESFORCE_NGOC_DEFAULT_TRANSACTION_TYPE);
    $fields['rC_Connect__Giving_Payment_Frequency__c'] = variable_get('salesforce_ngoc_default_frequency', SALESFORCE_NGOC_DEFAULT_FREQUENCY);
    $fields['rC_Connect__Payment_Method_Payment_Type__c'] = variable_get('salesforce_ngoc_default_payment_method_type', SALESFORCE_NGOC_DEFAULT_PAYMENT_METHOD_TYPE);
    // Prevents NGOC from trying to process the payment.
    $fields['rC_Connect__Disable_Merchant_Messages__c'] = TRUE;
    // Depends on one-time or recurring gift.
    $fields['rC_Connect__Giving_Giving_Frequency__c'] = 'One Payment';
    $fields['rC_Connect__Giving_Record_Type__c'] = variable_get('salesforce_ngoc_default_record_type', SALESFORCE_NGOC_DEFAULT_RECORD_TYPE);
  }
}

/**
 * Implements hook_salesforce_mapping_confirm_entity_for_queue().
 */
function salesforce_ngoc_salesforce_mapping_confirm_entity_for_queue($entity, $entity_type, $op){
  // Suppress creation of user salesforce sync item if the user was created by
  // submitting a donation form because the user data is included in the
  // batch_upload salesforce sync item.
  if($entity_type = 'user' && $op == 'CREATE') {
    if(!empty($entity->sbp_created_via['und']['0']['value']) && fundraiser_is_donation_type($entity->sbp_created_via['und']['0']['value'])) {
      return FALSE;
    }
  }
}

/**
 * Determine if item has "parent" records that have not been processed in SF.
 *
 * Salesforce queue items of records that reference "parent" objects which are
 * created via a batch_upload object (Contact and Opportunity) must go in
 * the hold queue until such time that the batch_upload object has been
 * processed and the Contact and/or Opportunity objects have been created. This
 * allows the child objects to reference the parent objecs using the parent's
 * sfid.
 *
 * We determine that those parents have been processed by looking for them in
 * the salesforce_sync_map table.
 *
 * Objects that have parent Contact and Opportunity objects are:
 * - sb_Actions_Taken__c
 * - social_share__c
 * - Donation_Upsell__c
 * - P2P_Personal_Campaign__c
 * - Sustainers_Upgrade__c
 *
 * @param array $item
 *   A salesforce_mapping or salesforce_genmap queue item.
 * @param object $drupal_object
 *   An object or drupal entity containing data for finding parent records.
 *
 * @return array
 */
function salesforce_ngoc_has_unsyncd_parents($item, $drupal_object){
  $unsyncd_parents_found = array();
  $salesforce_ngoc_parent_objects = variable_get('salesforce_ngoc_parent_objects');
  $object_type = $item['object_type'];
  // If this is an object with known parents that are created
  if (isset($salesforce_ngoc_parent_objects[$object_type])) {
    foreach ($salesforce_ngoc_parent_objects[$object_type] as $parent_object_type => $delta) {
      // Gotta find the drupal_id of the parent object.
      if ($parent_object_type == 'Contact') {
        if (!empty($drupal_object->uid)) {
          $drupal_id = $drupal_object->uid;
        }
      }
      elseif ($parent_object_type == 'Opportunity') {
        if (!empty($drupal_object->uid)) {
          $drupal_id = $drupal_object->uid;
        }
      }
      if(!empty($drupal_id) && !empty($delta) && !empty($parent_object_type)) {
        $result = db_query('SELECT sfid FROM {salesforce_sync_map} WHERE
          object_type = :parent_object_type AND
          delta = :delta AND
          drupal_id = :drupal_id',
          array(
            ':parent_object_type' => $parent_object_type,
            ':delta' => $delta,
            ':drupal_id' => $drupal_id,
          )
        );
        if ($result->rowCount() == 0) {
          $unsyncd_parents_found[] = array($parent_object_type => $drupal_id);
        }
      }
      unset($result);
    }
  }
  return $unsyncd_parents_found;
}

/**
 * Implements hook_salesforce_mapping_destination_queue_alter().
 */
function salesforce_ngoc_salesforce_mapping_destination_queue_alter(&$queue_name, $item, $entity) {
  if ($parents = salesforce_ngoc_has_unsyncd_parents($item, $entity)) {
    $queue_name = 'hold';
    salesforce_ngoc_write_hold_queue_items($item, $parents);
  }
}

/**
 * Implements hook_salesforce_genmap_destination_queue_alter().
 */
function salesforce_ngoc_salesforce_genmap_destination_queue_alter(&$queue_name, $item, $drupal_object) {
  if ($parents = salesforce_ngoc_has_unsyncd_parents($item, $drupal_object)) {
    $queue_name = 'hold';
    salesforce_ngoc_write_hold_queue_items($item, $parents);
  }
}

/**
 * Implements hook_salesforce_sync_save_map_alter().
 */
function salesforce_ngoc_salesforce_sync_save_map_alter($record) {
  if ($record->object_type == 'rC_Connect__Batch_Upload__c') {
    if ($record->is_new == TRUE) {
      // Save record in salesforce_ngoc_sync_map.
      $ngoc_record = array(
        'batch_upload_sfid' => $record->sfid,
        'sf_status' => 'New',
        'drupal_id' => $record->drupal_id,
        'module' => $record->module,
        'delta' => $record->delta,
        'created' => REQUEST_TIME,
      );
      salesforce_ngoc_sync_map_save($ngoc_record);
      // Prevents batch_upload record from being saved to salesforce_sync_map.
      $record->prevent_save = TRUE;
    }
  }
}

/**
 * Records which hold queue items have parent items pending processing in SF.
 *
 * @param array $item
 *   A salesforce_mapping or salesforce_genmap queue item.
 * @param array $parents
 */
function salesforce_ngoc_write_hold_queue_items($item, $parents) {
  foreach ($parents as $parent) {
    reset($parent);
    $key = key($parent);
    $record = array(
      'drupal_id' => $item['drupal_id'],
      'object_type' => $item['object_type'],
      'parent_type' => $key,
      'parent_drupal_id' => $parent[$key],
    );
    drupal_write_record('salesforce_ngoc_hold_queue_items', $record);
  }
}

/**
 * Creates or updates a Salesforce NGOC sync map record.
 *
 * @param mixed $record
 *   Can be an array of values or a salesforce_ngoc_sync_map entity object.
 *
 * @return mixed
 *   SAVED_NEW or SAVED_UPDATED depending on the operation performed. Otherwise,
 *   FALSE is returned if the record could not be saved.
 */
function salesforce_ngoc_sync_map_save($record) {
  if (is_array($record)) {
    // Allow sending an array and updating an existing entity.
    $id = _salesforce_ngoc_sync_get_id($record);
    if (!empty($id)) {
      $entity = salesforce_ngoc_sync_map_load($id);
    }
    // Adds array values to the loaded entity.
    if (isset($entity)) {
      foreach ($record as $key => $value) {
        $entity->$key = $value;
      }
      $record = $entity;
    }
    else {
      // Create a new entity object, but does not yet add to the database.
      $record = entity_create('salesforce_ngoc_sync_map', $record);
    }
  }
  if ($record->entityType() == 'salesforce_ngoc_sync_map') {
    // Adds the data to the database.
    $result = entity_save('salesforce_ngoc_sync_map', $record);
  }
  return FALSE;
}

/**
 * Creates and/or updates Salesforce NGOC sync map record(s).
 * @param array $records
 *   An array of salesforce_ngoc_sync_map records.
 */
function salesforce_ngoc_sync_map_save_multiple($records) {
  foreach ($records as $record) {
    salesforce_ngoc_sync_map_save((array) $record);
  }
}

/**
 * Load a single salesforce_ngoc_sync_map record.
 *
 * @param int $id
 *    The id representing the record we want to load.
 * @param bool $reset
 *    Whether to reset the internal cache for the requested entity type.
 *
 * @return mixed
 *    The Entity Object on success or FALSE.
 */
function salesforce_ngoc_sync_map_load($id, $reset = FALSE) {
  $entities = salesforce_ngoc_sync_map_load_multiple(array($id), array(), $reset);
  // entity_load() returns an array. We want the entity itself.
  if (!isset($entities[$id])) {
    return FALSE;
  }
  return $entities[$id];
}

/**
 * Load multiple salesforce_ngoc_sync_map records.
 */
function salesforce_ngoc_sync_map_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('salesforce_ngoc_sync_map', $ids, $conditions, $reset);
}

/**
 * Helper to grab the record id of a map.
 *
 * @param mixed $item
 *   Can be an array of values or an entity object.
 */
function _salesforce_ngoc_sync_get_id($item) {
  if (isset($item->id) && !empty($item->id)) {
    return $item->id;
  }
  if (is_object($item)) {
    $record = (array) clone($item);
  }
  else {
    $record = $item;
  }
  if (isset($record['sobject']->Id)) {
    return db_select('salesforce_ngoc_sync_map', 'm')
      ->fields('m', array('id'))
      ->condition('sfid', $record['sobject']->Id)
      ->execute()
      ->fetchField();
  }
  else {
    return db_select('salesforce_ngoc_sync_map', 'm')
      ->fields('m', array('id'))
      ->condition('module', $record['module'])
      ->condition('delta', $record['delta'])
      ->condition('drupal_id', $record['drupal_id'])
      ->execute()
      ->fetchField();
  }
}

/**
 * Menu callback for the standalone cron.
 */
function salesforce_ngoc_standalone_cron() {
  drupal_page_is_cacheable(FALSE);
  watchdog('salesforce_ngoc', 'Standalone cron run.', NULL, WATCHDOG_INFO);
  salesforce_ngoc_poll_batch_upload();
}

/**
 * Access callback for standalone cron.
 *
 * @todo make configurable.
 */
function salesforce_ngoc_standalone_cron_access() {
  return TRUE;
}

/**
 * Queries SF batch_upload objects for change in processing status.
 */
function salesforce_ngoc_poll_batch_upload() {
  // Get records from {salesforce_ngoc_sync_map}, oldest first.
  $ngoc_sync_map_records = db_query_range("SELECT * FROM {salesforce_ngoc_sync_map} WHERE sf_status != 'Committed' ORDER BY created DESC", 0, SALESFORCE_NGOC_DEFAULT_POLL_RECORD_LIMIT)->fetchAllAssoc('batch_upload_sfid');
  $sf_ids = array_keys($ngoc_sync_map_records);
  // Get corresponding batch upload objects from SF.
  $batch_upload_sobjects = salesforce_ngoc_get_batch_upload_sobjects($sf_ids);
  // Compare values from SF to those in {salesforce_ngoc_sync_map}.
  if (count($batch_upload_sobjects)) {
    $changed_records = salesforce_ngoc_batch_upload_compare($ngoc_sync_map_records, $batch_upload_sobjects);
  }
  // Save {salesforce_ngoc_sync_map} records with updated values.
  salesforce_ngoc_sync_map_save_multiple($changed_records);
  // Update polling_attempts and last_polled values. This is bad form to update
  // entity values directly, but it also seems undesirable to load 2,000
  // entities just to changes these values. This may cause issues with caching,
  // so attempting to flush manually afterwards.
  db_update('salesforce_ngoc_sync_map')
    ->fields(array('lasted_polled' => time()))
    ->expression('polling_attempts', 'polling_attempts + :one', array(':one' => 1))
    ->condition('batch_upload_sfid', $sf_ids, 'IN')
    ->execute();
  entity_get_controller('salesforce_ngoc_sync_map')->resetCache($sf_ids);
}

/**
 * Compares array of salesforce_ngoc_sync_map records to their SObject Objects.
 *
 * @param array $ngoc_sync_map_records
 *   An assoc array of stdClass Objects (as returened by fetchAllAssoc())
 *   containing salesforce_ngoc_sync_map record values, keyed by sf id.
 * @param array $batch_upload_sobjects
 *   An indexed array of SObject Objects as returned from retrieve() method.
 *
 * @return array
 *   An array containing salesforce_ngoc_sync_map records that have changed,
 *   and their new values.
 */
function salesforce_ngoc_batch_upload_compare($ngoc_sync_map_records, $batch_upload_sobjects) {
  $changed_records = array();
  $compare_fields = array(
    'rC_Connect__Batch_Upload_Status__c' => 'sf_status',
    'rC_Connect__Batch_Upload_Contact_1_Matched__c' => 'contact_sfid',
    'rC_Connect__Batch_Upload_Account_Matched__c' => 'account_sfid',
    'rC_Connect__Batch_Upload_Giving_Matched__c' => 'opportunity_sfid',
  );
  // For each batch_upload object retrieved form SF, see if the values are
  // different than the ones stored in {salesforce_ngoc_sync_map}
  foreach ($batch_upload_sobjects as $batch_upload_sobject) {
    $values_have_changed = FALSE;
    $ngoc_sync_map_record = $ngoc_sync_map_records[$batch_upload_sobject->Id];
    foreach ($compare_fields as $sf_field => $sb_field) {
      $new_ngoc_sync_map_record = $ngoc_sync_map_record;
      if ($batch_upload_sobject->fields->{$sf_field} !== $ngoc_sync_map_record->{$sb_field}) {
        $values_have_changed = TRUE;
        $new_ngoc_sync_map_record->{$sb_field} = $batch_upload_sobject->fields->{$sf_field};
      }
    }
    if ($values_have_changed) {
      $changed_records[] = $new_ngoc_sync_map_record;
    }
  }
  return $changed_records;
}

/**
 * Uses SF's retrieve method to get get batch upload SF objects.
 *
 * @param array $sf_ids
 *   An array of salesforce ids to retrieve.
 *
 * @return array
 *   An array containing SObject objects
 */
function salesforce_ngoc_get_batch_upload_sobjects($sf_ids) {
  $sobjects = array();
  $sf_fields = array(
    'Id',
    'rC_Connect__Batch_Upload_Giving_Matched__c',
    'rC_Connect__Batch_Upload_Account_Matched__c',
    'rC_Connect__Batch_Upload_Contact_1_Matched__c',
    'rC_Connect__Account_Status__c',
    'rC_Connect__Contact1_Status__c',
    'rC_Connect__Opportunity_Status__c',
    'rC_Connect__Payment_Method_Status__c',
    'rC_Connect__Batch_Upload_Status__c',
    'SB_User_Id__c',
    'SB_Donation_Id__c',
  );
  try {
    $sfapi = salesforce_get_api();
    $soap = new SalesforceSoapPartner($sfapi);
    $sobjects = $soap->retrieve(implode(',', $sf_fields), "rC_Connect__Batch_Upload__c", $sf_ids);
  }
  catch (Exception $e) {
    watchdog('salesforce_ngoc', $e->getMessage(), NULL, WATCHDOG_ERROR);
  }
  return $sobjects;
}
