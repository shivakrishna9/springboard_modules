<?php

/**
 * @file
 * Allows administrators to create petition webforms.
 */

/**
 * Implements hook_permission().
 */
function webform_user_permission() {
  return array(
    'administer user map' => array(
      'title' => t('Administer user map'),
      'description' => t('Map webform components to user profile fields.'),
    ),
    'alter webform components' => array(
      'title' => t('Alter webform components'),
      'description' => t('Add, edit, or delete webform components'),
    ),
    'configure webform settings' => array(
      'title' => t('Configure webform settings'),
      'description' => t('Modify confirmation message and other webform settings.'),
    ),
    'configure webform emails' => array(
      'title' => t('Configure webform emails'),
      'description' => t('Add, edit, and delete webform email settings.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function webform_user_menu() {
  $items['node/%node/webform/user_mapping'] = array(
    'title' => 'User map',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_user_mapping_form', 1),
    'access callback' => '_webform_user_mapping_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  // For webform user settings page.
  // 'access arguments' => array('Map webform submissions to Salesforce objects'),
  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * We are overriding the access callbacks to various webform related menu
 * items so more granular access permissions can be added as needed.
 */
function webform_user_menu_alter(&$items) {
  // configuration
  $items['node/%webform_menu/webform/configure']['access callback'] = '_webform_user_configure_access';

  //emails
  $items['node/%webform_menu/webform/emails']['access callback'] = '_webform_user_email_access';
  $items['node/%webform_menu/webform/emails/%webform_menu_email']['access callback'] = '_webform_user_email_access';
  $items['node/%webform_menu/webform/emails/%webform_menu_email/delete']['access callback'] = '_webform_user_email_access';

  // components
  $items['node/%webform_menu/webform/components/%webform_menu_component']['access callback'] = '_webform_user_component_access';
  $items['node/%webform_menu/webform/components/%webform_menu_component/clone']['access callback'] = '_webform_user_component_access';
  $items['node/%webform_menu/webform/components/%webform_menu_component/delete']['access callback'] = '_webform_user_component_access';
}

/**
 * Provides access to the mapping tabs if node has webform_user enabled form.
 */
function _webform_user_mapping_access($node) {
  $access = FALSE;
  if (_webform_user_is_webform_user_node($node) && user_access('administer user map')) {
    $access = TRUE;
  }
  return $access;
}

/**
 * Access callback for webform settings tab.
 *
 * @param string $op
 * Node access op, passed automatically by webform, defaults to 'update'.
 *
 * @param object $node
 * Node object
 */
function _webform_user_configure_access($op, $node) {
  if (_webform_user_is_webform_user_node($node)) {
    if (user_access('configure webform settings') && node_access($op, $node)) {
      return TRUE;
    }
    else {
      return FALSE;
    }
  }
  else {
    // default to standard behavior.
    return node_access($op, $node);
  }
}

/**
 * Access callback for email settings tab, edit, and delete.
 *
 * @param string $op
 * Node access op, passed automatically by webform, defaults to 'update'.
 *
 * @param object $node
 * Node object
 */
function _webform_user_email_access($op, $node) {
  if (_webform_user_is_webform_user_node($node)) {
    if (user_access('configure webform emails') && node_access($op, $node)) {
      return TRUE;
    }
    else {
      return FALSE;
    }
  }
  else {
    // default to standard behavior.
    return node_access($op, $node);
  }
}

/**
 * Access callback for component edit, delete, and clone.
 *
 * @param string $op
 * Node access op, passed automatically by webform, defaults to 'update'.
 *
 * @param object $node
 * Node object
 */
function _webform_user_component_access($op, $node) {
  if (_webform_user_is_webform_user_node($node)) {
    if (user_access('alter webform components') && node_access($op, $node)) {
      return TRUE;
    }
    else {
      return FALSE;
    }
  }
  else {
    // default to standard behavior.
    return node_access($op, $node);
  }
}

/**
 * Implements hook_webform_submission_presave().
 * We're using this to prevent webform from changing the owner of a submission when a webform_user submission is edited.
 */
function webform_user_webform_submission_presave($node, &$submission) {
  if (_webform_user_is_webform_user_node($node) && isset($submission->sid)) {
    $results = db_query('SELECT uid FROM {webform_submissions} where sid = :sid', array(':sid' => $submission->sid));
    $uid = $results->fetchColumn();
    if ($uid) {
      $submission->uid = $uid;
    }
  }
}

// TODO: examine this closely and remove or refactor salesforce-specific code. This should be in a SF-specific module.
/**
 * Implements hook_queue_batch_item_alter().
 */
function webform_user_queue_batch_item_alter(&$object, $type, $action, $oid) {
  if ($type == 'webform_user' && $action == 'create') {
    $relationship = _webform_user_get_relationship($oid);
    if (!empty($relationship)) {
      $user = _webform_user_load_user_salesforce_ids($oid);
      if ($relationship->related_object == 'account') {
        $id = $user->salesforce_account_id;
      }
      elseif ($relationship->related_object == 'contact') {
        $id = $user->salesforce_contact_id;
      }
      if ($id) {
        $object[$relationship->foreign_key_field] = $id;
      }
    }
  }
}

/**
 * Only show the related object field tab if the form is webform_user and it has been mapped to a salesforce object
 */ // TODO - called from where?
function _webform_user_check_settings($op) {
  if ($op == 'Map webform submissions to Salesforce objects') {
    $node = node_load(arg(1));
    if (_webform_user_is_webform_user_node($node) && !empty($node->sf_webform_object)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Implements hook_form_alter().
 *
 * Alter content type settings to add 'Enable fundraiser?' checkbox on node content types.
 */
function webform_user_form_node_type_form_alter(&$form, &$form_state) {
  if (isset($form['type'])) {
    $form['webform_user'] = array(
      '#title' => t('Webform user settings'),
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
    );
    $form['webform_user']['webform_user'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable webform user?'),
      '#default_value' => variable_get('webform_user_' . $form['#node_type']->type, FALSE),
      '#description' => t('Enable this checkbox if this content type should allow webform submissions to set user profile information. ' .
        'Enabling this will also enable webform if not already active.'),
    );
    $form['webform_user']['settings'] = array(
      '#title' => t('Additional settings'),
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $fields = _webform_user_get_profile_fields();
    $options = array('webform_user_all_profile_fields' => t('All profile fields.'));
    foreach ($fields as $field) {
      $options[$field['name']] = check_plain($field['title']);
    }
    $form['webform_user']['settings']['webform_user_default_fields'] = array(
      '#type' => 'checkboxes',
      '#options' => $options,
      '#default_value' => variable_get('webform_user_default_fields_' . $form['#node_type']->type, array('webform_user_all_profile_fields')),
      '#title' => t('Default fields'),
      '#description' => t('Select profile fields to automatically create components for.'),
    );
    $form['#submit'][] = 'webform_user_form_node_type_form_alter_submit';
  }
}

/**
 * Submit handler for fundraiser_form_node_type_form_alter.
 */
function webform_user_form_node_type_form_alter_submit(&$form, &$form_state) {
  // NOTE: we need to make sure if there are other things toggling this value not to untoggle it.
  _webform_user_toggle_webform($form_state['values']['type'], $form_state['values']['webform_user']);
}

/**
 * Helper function, enable or disable webform settings.
 */
function _webform_user_toggle_webform($type, $is_enabled = TRUE) {
  $webform_node_types = variable_get('webform_node_types', array('webform'));
  $webform_node_types_primary = variable_get('webform_node_types_primary', array('webform'));
  // Make sure this content type is enabled for webform if not already.
  // Add the selected node types to the webform_node_types_primary so a webform is added by default.
  if ($is_enabled) {
    $webform_node_types = array_merge($webform_node_types, array($type));
    $webform_node_types_primary = array_merge($webform_node_types_primary, array($type));
  }
// If disabled, we leave it as a webform for other modules to use.
//  else {
//    $webform_node_types = array_diff($webform_node_types, array($type));
//    $webform_node_types_primary = array_diff($webform_node_types_primary, array($type));
//  }
  // Re-save the variables.
  variable_set('webform_node_types', array_unique($webform_node_types));
  variable_set('webform_node_types_primary', array_unique($webform_node_types_primary));
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node forms.
 */
function webform_user_form_node_form_alter(&$form, &$form_state, $form_id) {
  // Modify the options on a specific instance of this node type.
  if (_webform_user_is_webform_user_node_type($form['#node']->type)) {
    $node = $form['#node'];
    $form['webform_user'] = array(
      '#title' => t('Webform user settings'),
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
    );
    // Allow for the option that a user may not *want* this *specific* node to interact with user profiles.
    $form['webform_user']['is_webform_user'] = array(
      '#title' => t('Create or update users when this webform is submitted.'),
      '#type' => 'checkbox',
      '#default_value' => isset($node->is_webform_user) ? $node->is_webform_user : TRUE,
      '#description' => t('When checked, user profile fields will automatically be added to the webform. ' .
        'When the form is submitted, new users will be created using those form values.'),
    );
    $form['webform_user']['send_new_user_email'] = array(
      '#title' => t('Send new users an email with their account details.'),
      '#description' => t('If a new user is created during the submission, an email containing their account details will be sent to them.'),
      '#type' => 'checkbox',
      '#default_value' => isset($node->send_new_user_email) ? $node->send_new_user_email : NULL,
    );
  }
}

/**
 * Implements hook_form_alter().
 */
function webform_user_form_alter(&$form, &$form_state, $form_id) {

  // Disallow users from changing the mail keyform after it's been created.
  // It is critical that we have a matching key id for this value, and it shouldn't change.
  if ($form_id == 'webform_component_edit_form') {
    $node = node_load($form['nid']['#value']);
    // For new components ONLY prevent key conflicts by name.
    if (arg(4) == 'new') {
      // Gather the set of already available keys.
      $seen_keys = array();
      if (isset($node->webform['components'])) {
        foreach ($node->webform['components'] as $cid => $this_component) {
          $seen_keys[$cid] = $this_component['form_key'];
        }
      }
      if (in_array($form['form_key']['#default_value'], $seen_keys)) {
        $new_key_name = $form['form_key']['#default_value'];
        $count = 0;
        while (in_array($new_key_name, $seen_keys)) {
          $new_key_name = $form['form_key']['#default_value'] = $new_key_name = $form['form_key']['#default_value'] . '_' . $count;
        }
        $form['form_key']['#default_value'] = $new_key_name;
      }
    }
    // Check against mail for conflict avoidance.
    if (isset($node->is_webform_user) && $node->is_webform_user) {
      if ($form['form_key']['#default_value'] == 'mail') {
        $form['form_key']['#disabled'] = TRUE;
        $form['form_key']['#description'] .= '</br>' . t('This field key is required by Webform User and cannot be changed.');
        $form['form_key']['#value'] = $form['form_key']['#default_value'];
      }
    }
  }

  // For the webform itself, we map the value of the given submission profile.
  if (strpos($form_id, 'webform_client') !== FALSE) {
    $node = node_load($form['#node']->nid);
    $components = $node->webform['components'];
    global $user;
    $user_data = user_load($user->uid);
    // If the user is logged in.
    if (user_is_logged_in() && _webform_user_is_webform_user_node($node)) {
      $component_hierarchy = __webform_user_parse_components($node->nid, $components);
      $map = webform_user_user_map($node->nid);
      // Map each profile field if there's a matching component field.
      foreach ($map as $webform_field => $profile_field) {
        if (array_key_exists($webform_field, $component_hierarchy)) {
          $form_field = &_webform_user_find_field($form, $component_hierarchy[$webform_field]);
          if (isset($user_data->$profile_field)) {
            // Figure out what the value is.
            $profile_value = is_array($user_data->$profile_field) ? '1' : 0;
            if (is_array($user_data->$profile_field)) {
              $current_field = $user_data->$profile_field;
              $profile_value = isset($current_field['und'][0]['value']) ? $current_field['und'][0]['value'] : NULL;
            }
            else {
              $profile_value = $user_data->$profile_field;
            }
            // Set the value.
            switch ($form_field['#type']) {
              case 'date':
                $form_field['#default_value'] = $profile_value;
                break;
              case 'checkboxes':
                if ($profile_value) { // Will be a 0 if unchecked.
                  $form_field['#default_value'] = array($profile_field);
                }
                break;
              default:
                $form_field['#default_value'] = check_plain($profile_value);
                break;
            }
          } // End if webform empty with a profile field value.
        } // End if field is in component heirarchy.
      } // End foreach
    } // End if the user is logged in.
    // Add a new validation handler.
    $form['#validate'][] = 'webform_user_webform_validate';
    // Add new submit handler.
    $form['#submit'][] = 'webform_user_webform_submit';
    // Add CSS and JS on after build.
    $form['#after_build'][] = 'webform_user_webform_after_build';
  }

}

/**
 * After build to include js and css.
 */
function webform_user_webform_after_build($form, $form_state) {
  // Attach the js files
  drupal_add_js(drupal_get_path('module', 'webform_user') . '/js/webform_user.js');
  return $form;
}

/**
 * Validates the results of a webform with webform user.
 */
function webform_user_webform_validate($form, &$form_state) {
  $node = node_load($form_state['values']['details']['nid']);
  $fields = _webform_user_flatten_tree($form_state['values']['submitted'], $node->nid);
  if (_webform_user_is_webform_user_node($node) && !_webform_user_validate_email(isset($fields['mail']) ? $fields['mail'] : '')) {
    form_set_error('mail', t('Please enter a valid email address.'));
  }
}

/**
 * Submit the results of a webform with webform user.
 */
function webform_user_webform_submit($form, &$form_state) {
  global $user;
  $node = node_load($form_state['values']['details']['nid']);
  // Only process if the form is completed and it's a webform_user form.
  $submit_op = empty($node->webform['submit_text']) ? t('Submit') : $node->webform['submit_text'];
  if ($form_state['values']['op'] == $submit_op && _webform_user_is_webform_user_node($node)) {
    $fields = _webform_user_flatten_tree($form_state['values']['submitted_tree'], $node->nid);
    $map = _webform_user_get_map($form_state['values']['details']['nid'], $fields);
    $fields['mail'] = trim($fields['mail']);
    $account = user_load_by_mail($fields['mail']); // Return user object or false if no user found.

    // We have a uid, so this is an authenticated user, update if this isn't an edit.
    // TODO: What if the logged in user is NOT the submission user?
    // See: offline fundraiser or other trickery mid submission.
    // Would it not be better to grab the user from sub. data?
    // This could potentially update the logged in user INSTEAD of the submitted user.
    if ($user->uid && $form_state['redirect']) {
      // Update the existing user account.
      _webform_user_save_profile_map($user->uid, $map);
    }
    // Or if we found an account matching the email.
    elseif (isset($account->uid) && $form_state['redirect']) {
      // Update the existing user account.
      _webform_user_save_profile_map($account->uid, $map);
      $submission = webform_get_submission($node->nid, $form_state['values']['details']['sid']);
      $submission->uid = $account->uid;
      webform_submission_update($node, $submission);
    }
    // Anonymous user, new email to Drupal.
    elseif ($form_state['redirect']) {
      // Register the user.
      $user_fields = array(
        'name' => $fields['mail'],
        'mail' => $fields['mail'],
        'init' => $fields['mail'],
        'pass' => user_password(8),
        'status' => 1,
      );
      $account = user_save('', $user_fields);
      // Update the new user account.
      _webform_user_save_profile_map($account->uid, $map);
      $submission = webform_get_submission($node->nid, $form_state['values']['details']['sid']);
      $submission->uid = $account->uid;
      webform_submission_update($node, $submission);
      // Send the e-mail through the user module.
      if ($node->send_new_user_email) {
        // Manually set the password so it appears in the e-mail.
        $account->password = $user_fields['pass'];
        drupal_mail('user', 'register_no_approval_required', $user_fields['mail'], NULL, array('account' => $account), NULL);
      }
    }
  }
}

/**
 * Menu callback form, provides user interface to set up form fields to profile fields mapping.
 *
 * Webform User can map webform components to user profile fields. Values added to the user profile for these fields
 * will be used to populate default values for webform components they are mapped to.
 *
 *  Example: we have a user profile field "First Name". We map this to a webform component "First Name" with a form key of first_name.
 *  Note that the name and form key of the component are irrelevant, all that matters is a relationship has been established between
 *  this profile field and this webform component.
 *
 *  If an anonymous user submits a webform a new user account is created using the email address provided. Whatever value the user entered
 *  in the "First Name" webform component will be used to set the value of the "First Name" profile field as well.
 *
 *  For existing users, mapped profile fields are used to provide default values for webform components. For example, given the mapping
 *  described above, if an existing user views a webform, the "First Name" component field will contain a default value that matches
 *  the value in the "First Name" field in that user's profile.
 */
function webform_user_mapping_form($form, $form_state, $node) {
  $form = array(
    '#tree' => TRUE,
    '#node' => $node,
    'mapping' => array(),
  );
  $form['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  $form['info'] = array(
    '#value' => t('This form allows you to map the submitted form values to Drupal user and profile fields. ' .
      'When the webform form is submitted, the user\'s profile will be updated with the values from the form.'),
    '#weight' => 0,
  );

  $header = array(
    t('Webform Component'),
    t('Profile Field'),
  );
  // The NULL option and any core account fields have to be handled separately.
  $options = array(
    '' => t('--Select One--'),
  );
  $fields = _webform_user_get_profile_fields();
  foreach ($fields as $field) {
    $options[$field['name']] = $field['title'];
  }
  // we like alphabetized dropdowns.
  asort($options);
  $form['mapping'] = array(
    '#prefix' => '<div id="fields">',
    '#suffix' => '</div>',
    '#tree' => TRUE,
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => array(),
  );
  foreach ($node->webform['components'] as $cid => $component) {
    if (isset($node->map[$cid])) {
      $default = $node->map[$cid];
    }
    else {
      $default = 0;
    }
    if ($component['type'] !== 'fieldset') {
      $select = array(
        '#id' => 'component-' . $cid,
        '#type' => 'select',
        '#options' => $options,
        '#default_value' => $default,
      );
      $form['mapping'][$cid] = array(
        'component_cid' => &$select,
      );
      $form['mapping']['#rows'][] = array(
        array('data' => $component['name']),
        array('data' => &$select),
      );
      unset($select);
    }
  }
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );
  return $form;
}

/**
 * Submit handler for user profile mapping form.
 */
function webform_user_mapping_form_submit($form, &$form_state) {
  // Remove the old map.
  $query = db_delete('webform_user_component_map');
  $query->condition('nid', $form_state['values']['nid']);
  $query->execute();
  // Add the new map.
  foreach ($form_state['values']['mapping'] as $key => $values) {
    if (!empty($values['component_cid'])) {
      $query = db_insert('webform_user_component_map');
      $query->fields(array(
        'nid' => $form_state['values']['nid'],
        'cid' => $key,
        'map_id' => $values['component_cid'],
      ));
      $query->execute();
    }
  }
  drupal_set_message(t('Profile mapping has been saved'));
}

/**
 * Hook node functions, for nodes with webform user turned on for content type.
 */

/**
 * Implements hook_node_insert().
 */
function webform_user_node_insert($node) {
  // If the newly created node is a webform user node, set the defaults and create comps.
  if (_webform_user_is_webform_user_node_type($node->type)) {
    if (_webform_user_is_webform_user_node($node)) {
      _webform_user_set_values($node);
      if (!isset($node->clone_from_original_nid)) { // Value from node_clone module.
        // We only want to create new components if this is NOT a clone.
        _webform_user_create_webform_components($node);
      }
      else {
        webform_user_clone_component_map($node, $node->clone_from_original_nid);
      }
    }
  }
}

/**
 * Implements hook_node_update().
 */
function webform_user_node_update($node) {
  if (_webform_user_is_webform_user_node_type($node->type)) {
    // If the node hasn't been a webform_user form and it's set to be a webform_user form, make it one.
    $current_node = node_load($node->nid);
    if (!_webform_user_is_webform_user_node($current_node) && _webform_user_is_webform_user_node($node)
       && $current_node->webform['components'][1]['form_key'] != 'mail') { //TODO make sure this ref is correct.
      // TODO confirm that this works if email not #1, other modules make components too.
      _webform_user_create_webform_components($node);
    }
    _webform_user_set_values($node);
  }
}

/**
 * Implements hook_node_delete().
 */
function webform_user_node_delete($node) {
  if (_webform_user_is_webform_user_node_type($node->type)) {
    _webform_user_delete_node_values($node);
  }
}

/**
 * Implements hook_node_load().
 */
function webform_user_node_load($nodes, $types) {
  $webform_users = db_query('SELECT * FROM {webform_user} WHERE nid IN (:nids)',
    array(':nids' => array_keys($nodes)));
  $maps = db_query('SELECT nid, cid, map_id FROM {webform_user_component_map} WHERE nid IN (:nids)',
    array(':nids' => array_keys($nodes)));
  foreach ($webform_users as $webform_user) {
    $webform_user = (array) $webform_user;
    $nodes[$webform_user['nid']]->is_webform_user = $webform_user['is_webform_user'];
    $nodes[$webform_user['nid']]->send_new_user_email = $webform_user['send_new_user_email'];
    $map = array();
    foreach ($maps as $row) {
      $row = (array) $row;
      if ($row['nid'] == $webform_user['nid']) {
        $map[$row['cid']] = $row['map_id'];
      }
    }
    $nodes[$webform_user['nid']]->map = $map;
  }
}

/**
 * Webform related functions, used to crawl through forms and comps and interact with webform.
 */

/**
 * Returns a reference to an element of a FAPI array based on a known path.
 */
function &_webform_user_find_field(&$form, $path) {
  foreach (array_keys($path) as $v) {
    if (is_array($path[$v]) && count($path[$v])) {
      // Recurse if there are more keys.
      return _webform_user_find_field($form[$v], $path[$v]);
    }
    else {
      return $form[$v];
    }
  }
}

/**
 * Helper function.
 * Creates a nested array of where components exist in the FAPI array for all components in a webform.
 * This is needed because the webform module allows the user to move components around. Therefore
 * we must be able to find them if they are not in their usual spot.
 */
function __webform_user_parse_components($nid, $components, $reset = FALSE) {
  $component_hierarchy = array();
  foreach ($components as $cid => $component) {
    $component_path = 'submitted[' . implode('][', _webform_user_walk_component_hierarchy($nid, $cid, $reset)) . ']';
    parse_str($component_path, $output); // Convert string to a nested array.
    $component_hierarchy[$component['form_key']] = $output;
  }
  return $component_hierarchy;
}

/**
 * Creates a nested array of where a component exists in the FAPI array.
 */
function _webform_user_parse_component($nid, $form_key) {
  $results = db_query('SELECT cid FROM {webform_component} WHERE nid = :nid and form_key = :form_key',
    array(':nid' => $nid, ':form_key' => $form_key))->fetchColumn();
  $component_path = 'submitted[' . implode('][', _webform_user_walk_component_hierarchy($nid, $cid, $reset)) . ']';
  parse_str($component_path, $output);
  return $output;
}

/**
 * Builds a path from the webform component to it's topmost parent.
 */
function _webform_user_walk_component_hierarchy($nid, $cid, $reset = FALSE, &$path = array()) {
  // Store all the components for this node in a static cache to reduce the number of duplicated database hits.
  static $component_hierarchy = array();
  if (empty($component_hierarchy[$nid]) || $reset == TRUE) {
    $component_hierarchy[$nid] = array();
    $result = db_query('SELECT cid, pid, form_key FROM {webform_component} WHERE nid = :nid', array(':nid' => $nid));
    foreach ($result as $data) {
      $this_cid = $data->cid;
      $component_hierarchy[$nid][$this_cid][] = $data;
    }
  }
  // Build a path from the webform component to its topmost parent.
  if (isset($component_hierarchy[$nid][$cid])) {
    foreach ($component_hierarchy[$nid][$cid] as $data) {
      array_unshift($path, $data->form_key);
      if ($data->pid > 0) {
        _webform_user_walk_component_hierarchy($nid, $data->pid, FALSE, $path);
      }
    }
  }
  return $path;
}

/**
 * Set default values for the weform components based on user profile fields.
 */
function _webform_user_add_webform_defaults(&$node, &$user) {
  // Reload user object to ensure profile field values are present.
  $account = user_load($user->uid);
  $fields = _webform_user_get_profile_fields();
  foreach ($node->webform['components'] as $ckey => $component) {
    foreach ($fields as $fkey => $field) {
      // Handle e-mail.
      if ($component['form_key'] == 'mail') {
        $node->webform['components'][$ckey]['value'] = check_plain($account->mail);
      }
      // Handle custom profile fields.
      elseif ($component['form_key'] == $field['name'] && isset($account->$component['form_key'])) {
        if ($field['type'] == 'checkbox') {
          $node->webform['components'][$ckey]['value'] = $component['form_key'];
        }
        else {
          $node->webform['components'][$ckey]['value'] = check_plain($account->$component['form_key']);
        }
        unset($fields[$fkey]);
      }
    }
  }
}

/**
 * Query for all the component types for a given node ID. Statically cached to
 * reduce duplicate queries.
 *
 * @param $nid
 *   Webform node ID.
 * @param $form_key = NULL
 *   Optionally filter results by a single form key.
 * @return
 *   The component type of a single form key if $form_key is set, or all
 *   component types for the webform node.
 */
function _webform_user_webform_component_types($nid, $form_key = NULL) {
  $component_types = &drupal_static(__FUNCTION__);
  if (!empty($nid) && !isset($component_types[$nid])) {
    $result = db_query("SELECT form_key, type FROM {webform_component} WHERE nid = :nid", array(':nid' => $nid));
    $component_types[$nid] = $result->fetchAllKeyed();
  }
  if (isset($form_key)) {
    return isset($component_types[$nid][$form_key]) ? $component_types[$nid][$form_key] : NULL;
  }
  return isset($component_types[$nid]) ? $component_types[$nid] : array();
}

/**
 * Flatten a submission tree into a flat list. Note: date values are not flattened.
 */
function _webform_user_flatten_tree($tree, $nid = NULL) {
  $items = array();
  foreach ($tree as $key => $val) {
    $type = _webform_user_webform_component_types($nid, $key);
    if (is_array($val)) {
      // If it's a date, don't flatten the value.
      if ($type == 'date') {
        if (isset($val[0]) && isset($val[1]) && isset($val[2])) {
          $val['month'] = $val[0];
          $val['day'] = $val[1];
          $val['year'] = $val[2];
          unset($val[0], $val[1], $val[2]);
          $items[$key] = $val;
        }
        else {
          continue;
        }
      }
      elseif ($type == 'select') {
        $values = array();
        foreach ($val as $k => $v) {
          $values[] = $v;
        }
        if (count($values) == 1) { // Single item select (aka checkbox).
          $items[$key] = array_shift($values);
        }
        elseif (count($values) == 0) { // No value, reset.
          $items[$key] = NULL;
        }
        else {
          $items[$key] = $values;
        }
      }
      else {
        $items = array_merge($items, _webform_user_flatten_tree($val, $nid));
      }
    }
    elseif (!empty($val)) {
      $items[$key] = $val;
    }
  }
  return $items;
}

/**
 * Creates webform components for this node. All selected profile fields, plus the required email field.
 */
function _webform_user_create_webform_components(&$node) {
  // Include webform component functions to allow creation.
  module_load_include('inc', 'webform', 'includes/webform.components');

  // Process additional fields.
  $items = array();
  $fieldset_lookup = array();
  $fields = _webform_user_get_profile_fields();
  /**
   * Hook available to other modules: hook_webform_user_get_profile_fields().
   * This allows other modules to filter, add to, or modify profile fields that
   * are created by webform user. Allowing for example fundraiser to avoid
   * duplication of effort, or custom modules to filter out results.
   */
  drupal_alter('webform_user_profile_fields', $fields, $node);

  // Set up fieldsets for entry.
  $fieldset_lookup = $fieldset_created = array();
  foreach ($fields as $field) {
    if (isset($field['category_key']) && !empty($field['category_key'])) {
      $item = array(
        'nid' => $node->nid,
        'pid' => 0,
        'form_key' => $field['category_key'],
        'name' => $field['category_name'],
        'type' => 'fieldset',
        'weight' => 0,
        'extra' => array(
          'collapsible' => 1,
          'collapsed' => 0,
          'description' => '',
        ),
      );
      // Add the fieldset component and store its ID in a lookup table.
      $fieldset_lookup[$field['category_key']] = $item;
    }
  }

  // Process fields. (If a fieldset has no available fields, don't create it.
  $all = FALSE;
  $default_fields = variable_get('webform_user_default_fields_' . $node->type, array('webform_user_all_profile_fields'));
  if (empty($default_fields) || in_array('webform_user_all_profile_fields', $default_fields)) {
    $all = TRUE;
  }
  foreach ($fields as $field) {
    // Filter our fields only to those marked in the profile configuration for this
    // node type. Users can always add more as needed, this is just for default configurations.
    // The mail field can always be created.
    if ($all || in_array($field['name'], $default_fields) || $field['name'] == 'mail') {
      // Create a webform component array for the field.
      $fieldset_id = 0;
      // Get the fieldset ID, or create it if it doesn't already exist.
      // Prevents fieldsets that aren't being used from getting created.

      if (isset($field['category_key']) && !empty($field['category_key'])) {
        if (isset($fieldset_created[$field['category_key']])) {
          $fieldset_id = $fieldset_created[$field['category_key']];
        }
        else {
          $fieldset_id = webform_component_insert($fieldset_lookup[$field['category_key']]);
          $fieldset_created[$field['category_key']] = $fieldset_id; // Save the created id.
        }
      }
      /**
       * Standard webform components available are:
       * date, email, fieldset, file, grid, hidden, markup, number, pagebreak, select, textarea, textfield, time
       */
      $item = array(
        'nid' => $node->nid,
        'form_key' => str_replace('profile_', '', $field['name']), // Strip 'profile_' where needed.
        'pid' => $fieldset_id,
        'name' => $field['title'],
        'type' => $field['type'],
        'mandatory' => isset($field['mandatory']) ? $field['mandatory'] : 0,
        'weight' => isset($field['weight']) ? $field['weight'] : 0,
        'email' => 1,
        'extra' => array(
          'description' => isset($field['explanation']) ? $field['explanation'] : '',
        ),
      );

      // Transform the component array for certain field types.
      // TODO handle:
      // 'taxonomy_term_reference'
      switch ($item['type']) {
        case 'email':
          break;
        case 'checkbox':
        // From list_field_info().
        case 'list_boolean':
          $item['type'] = 'select';
          $item['extra']['items'] = $field['name'] . '|' . $field['title'];
          $item['extra']['aslist'] = 0;
          $item['extra']['multiple'] = 'Y';
          break;
        case 'list':
          $item['type'] = 'textarea';
          break;
        case 'url':
          $item['type'] = 'textfield';
          break;
        // From number_field_info().
        case 'number_integer':
        case 'number_decimal':
        case 'number_float':
          $item['type'] = 'textarea';
          break;
        // From text_field_info().
        case 'text':
          $item['type'] = 'textfield';
          break;
        case 'text_long':
        case 'text_with_summary':
          $item['type'] = 'textarea';
          break;
        // From list_field_info().
        case 'list_text':
        case 'list_integer':
        case 'list_float':
          $item['type'] = 'select';
          $field['options'] = _webform_user_implode_options($field['options']);
          $item['extra']['items'] = $field['options'];
          $item['extra']['aslist'] = 'Y';
          $item['extra']['multiple'] = 0;
          break;
        // From date_field_info().
        case 'date':
        case 'datetime':
        case 'datestamp':
          $item['type'] = 'date'; // TODO this is partial, dates MAY also have times, and we need to make second component.
          break;
        // Special hidden types.
        case 'hidden':
          $item['extra']['private'] = 0; // Allow to be changed by JS.
          $item['extra']['hidden_type'] = 'hidden'; // Allow to be changed by JS.
          $item['extra']['conditional_operator'] = '='; // Allow to be changed by JS.
          break;
        // Special no-equilivent types.
        case 'image':
          // There is no webform image field, so we don't map this at all.
          drupal_set_message(t('Webform does not support Image fields, the Image field %name has not been added to this webform.',
            array('%name' => $field['title'])));
          $item = array();
          break;
        case 'file':
          // There is no webform file field, so we don't map this at all.
          drupal_set_message(t('Webform does not support File fields, the File field %name has not been added to this webform.',
            array('%name' => $field['title'])));
          $item = array();
          break;
        default:
          // We've exausted the list of available types with no match, field type must be unsupported.
          drupal_set_message(t('Webform does not support %type fields, the %type field %name has not been added to this webform.', array('%type' => $item['type'], '%name' => $field['title'])));
          $item = array();
      }
      if (!empty($item)) {
        // Add the component to the Webform.
        $cid = webform_component_insert($item);
        // Add the component mapping record
        $map = array(
          'nid' => $node->nid,
          'cid' => $cid,
          'map_id' => $field['name'],
        );
        drupal_write_record('webform_user_component_map', $map);
      }
    }
  } // End foreach field.
  drupal_set_message(t('User profile fields have been mapped to webform components, use the "User Map" tab to edit the map.'));
}

/**
 * Implode options into a string formated for webform components.
 */
function _webform_user_implode_options($options) {
  $formatted_options = '';
  if (is_array($options)) {
    foreach ($options as $key => $value) {
      $formatted_options .= $key . '|' . $value . "\n";
    }
  }
  return $formatted_options;
}

/**
 * Helper functions.
 */

/**
 * Helper function, check to see if this node is enabled for webform user.
 */
function _webform_user_is_webform_user_node($node) {
  if (isset($node->is_webform_user)) { // Set by node_load.
    return $node->is_webform_user ? TRUE : FALSE;
  }
  return FALSE;
}

/**
 * Helper function, check if this node type is enabled for webform user.
 */
function _webform_user_is_webform_user_node_type($type) {
  static $types; // Cache.
  if (isset($types[$type])) {
    return $types[$type];
  }
  $types[$type] = variable_get('webform_user_' . $type, FALSE);
  return $types[$type];
}

/**
 * Helper function, return a map of webform components to user profile fields.
 */
function _webform_user_get_map($nid, $fields) {
  $map = webform_user_user_map($nid);
  if ($map) {
    foreach ($map as $key => $value) {
      if (isset($fields[$key])) {
        $map2[$value] = $fields[$key];
      }
    }
    return $map2;
  }
  return array();
}

/**
 * Helper function, validate an e-mail address.
 */
function _webform_user_validate_email($mail) {
  // TODO - why are we not using valid_email_address() from D7?
  return preg_match('/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/', $mail);
}

/**
 * Helper function, save mapped profile data to given user.
 */
function _webform_user_save_profile_map($uid, &$map) {
  // The saved map has to handle saving to both profile2 / entity fields. And profile.module.
  if ($map) {
    // First loop through the map and fields to grab results.
    $account = user_load($uid);
    $profile_values = array();
    $fields = _webform_user_get_profile_fields();
    foreach ($fields as $field) {
      // So far no types actually require a unique solution.
      switch ($field['type']) {
        case 'checkbox':
        case 'checkboxes':
        case 'list_boolean':
          // These take integers. Always set them T or F.
          $profile_values[$field['name']] = !empty($map[$field['name']]) ? 1 : 0;
          break;
        default:
          // Only add the profile result if the name is in the keys.
          if (in_array($field['name'], array_keys($map))) {
            $profile_values[$field['name']] = $map[$field['name']];
          }
          break;
      }
    }
    // Starting with the mail field.
    if (isset($profile_values['mail'])) {
      // Check for length. User mail max length: 254
      if (strlen($profile_values['mail']) > 254) {
        $original_field = $profile_values['mail'];
        $profile_values['mail'] = substr($profile_values['mail'], 0, 254);
        watchdog('webform_user', 'Truncated field @field_name at length @length for user #@uid. Original data: @original_field',
          array('@field_name' => 'mail', '@length' => 254, '@uid' => $uid, '@original_field' => $original_field));
      }
      $account->mail = $profile_values['mail'];
      unset($profile_values['mail']);
    }

    // Fields found, now save the rest of the fields.
    if (count($profile_values) > 0 && $account->uid) {
      // Profile2 and entity fields saves on entity fields.
      // (Both Profile and Profile2 can be installed, so we do both.)
      foreach ($profile_values as $field_name => $field_value) {
        if (isset($account->{$field_name})) {
          if (is_array($account->{$field_name})) {
            // Check for length.
            $field_info = field_info_field($field_name);
            // Length is a concern for text fields. Select values set will fail validation.
            // Text areas are stored in blob form, so not an issue.
            $max_length = isset($field_info['settings']['max_length']) ? $field_info['settings']['max_length'] : '';
            if (!empty($max_length) && strlen($field_value) > $max_length) {
              $original_field = $field_value;
              $field_value = substr($field_value, 0, $max_length);
              watchdog('webform_user', 'Truncated field @field_name at length @length for user #@uid. Original data: @original_field',
                array('@field_name' => $field_name, '@length' => $max_length, '@uid' => $uid, '@original_field' => $original_field));
            }
            $account->{$field_name}['und'][0]['value'] = $field_value;
          }
        }
      }
      user_save($account);

      // If the standard profile field system is active, use that.
      if (function_exists('_profile_get_fields')) {
        $categories = profile_user_categories();
        // Loop on each category.
        foreach ($categories as $category) {
          $this_profile = array();
          $expected_fields = _profile_get_fields($category['name'], FALSE);
          foreach ($expected_fields as $expected_field) {
            if (!isset($profile[$expected_field->name])) {
              // profile.module saves values in text field type as defined in hook_schema().
              // Aka mediumtext, 16 MB. So not really an issue for this.
              $this_profile[$expected_field->name] = $profile_values[$expected_field->name];
            }
          }
          profile_save_profile($this_profile, $account, $category['name']);
        }
      }
    }
  } // End if map.
}

/**
 * Database functions.
 */

/**
 * Database/helper function, fetch an array of user profile fields.
 */
function _webform_user_get_profile_fields() {
  /**
   * Returns an array of fields with the following fields set:
   * name - form key
   * title - human readable name
   * type - webform component type
   * mandatory - required or not (optional, defaults to 0)
   * weight - order of display (optional, defaults to 0)
   * explanation - description (optional, defaults to '')
   * options - array of select options, required for type list_float
   * category_key - form key for the fieldset for the profile
   * category_name - human readable profile field value
   */
  $fields = array();
  $excluded = array('entityreference', 'commerce_customer_profile_reference', 'commerce_line_item_reference', 'commerce_product_reference');
  // Add the e-mail field first.
  $mail_field = array(
    'name' => 'mail',
    'title' => t('E-mail address'),
    'type' => 'email',
    'mandatory' => 1,
    'weight' => 0,
    'explanantion' => '',
    'options' => NULL,
  );
  $fields[] = $mail_field;

  // Grab settings from profile2 module AND from fields manually added on profile.
  // These are standard fields types.
  $entity_types = array('user');
  if (module_exists('profile2')) {
    $entity_types[] = 'profile2'; // Add profile2 values.
  }
  $results = db_query('SELECT i.id, i.field_name, i.data, c.data as extra, c.type FROM {field_config_instance} i ' .
    'INNER JOIN {field_config} c ON i.field_name = c.field_name ' .
    'WHERE entity_type IN (:types)',
    array(':types' => $entity_types)
  );
  foreach ($results as $result) {
    if(!in_array($result->type, $excluded)) {
      $field = array();
      $result->data = unserialize($result->data);
      $result->extra = unserialize($result->extra);
      $field['name'] = $result->field_name;
      $field['title'] = $result->data['label'];
      // TODO Map types to types webform understands.
      $field['type'] = $result->type;
      // UNLESS the display is hidden. Then we need to override this to HIDE the field.
      if (!empty($result->data['display']['default']['type']) && $result->data['display']['default']['type'] == 'hidden') {
        $field['type'] = 'hidden';
      }
      $field['mandatory'] = $result->data['required'] ? $result->data['required'] : 0;
      $field['weight'] = $result->data['widget']['weight'];
      $field['explanantion'] = $result->data['description'];
      $field['options'] = isset($result->extra['settings']['allowed_values']) ? $result->extra['settings']['allowed_values'] : NULL;
      // FOR NOW: field groups are only coming in from a field group module for these values. Leave it alone.
      $field['category_key'] = NULL;
      $field['category_name'] = NULL;
      $fields[] = $field;
    }
  }

  //  And or grab settings from D7 profile module.
  if (function_exists('_profile_get_fields')) {
    $categories = _user_categories();
    foreach ($categories as $category) {
      $profile_fields = _profile_get_fields($category['name'], FALSE);
      foreach ($profile_fields as $profile_field) {
        if(!in_array($profile_field->type, $excluded)) {
          $field = array();
          $field['name'] = $profile_field->name;
          $field['title'] = $profile_field->title;
          // TODO Map types to types webform understands.
          $field['type'] = $profile_field->type;
          $field['mandatory'] = $profile_field->required ? $profile_field->required : 0;
          $field['weight'] = $profile_field->weight;
          $field['explanantion'] = isset($profile_field->explanantion) ? $profile_field->explanantion : '';
          $field['options'] = isset($profile_field->options) ? $profile_field->options : NULL;
          $field['category_key'] = isset($category['name']) ? $category['name'] : NULL;
          $field['category_name'] = isset($category['title']) ? $category['title'] : NULL;
          $fields[] = $field;
          }
      }
    }
  }
  return $fields;
}

/**
 * Database function, create or update values of the is_webform_user checkbox when the selected node is created.
 */
function _webform_user_set_values(&$node) {
  $is_webform_user = $node->is_webform_user ? TRUE : FALSE;
  $send_new_user_email = $node->send_new_user_email ? 1 : 0;
  $exists = db_query('SELECT 1 FROM {webform_user} WHERE nid = :nid', array(':nid' => $node->nid))->fetchColumn();
  $record = array(
    'nid' => $node->nid,
    'is_webform_user' => $is_webform_user,
    'send_new_user_email' => $send_new_user_email,
  );
  // Doesn't exist yet, add the data to the table.
  if (!$exists && $is_webform_user) {
    drupal_write_record('webform_user', $record);
  }
  else {
    // Or update it.
    drupal_write_record('webform_user', $record, array('nid'));
  }
}

/**
 * Database function, read webform user data.
 */
function _webform_user_load_webform_user($nid) {
  return db_query('SELECT * FROM {webform_user} WHERE nid = :nid', array(':nid' => $nid))->fetchAssoc();
}

/**
 * Database function, delete webform user data.
 */
function _webform_user_delete_node_values($node) {
  db_query('DELETE FROM {webform_user} WHERE nid = :nid', array(':nid' => $node->nid));
  db_query('DELETE FROM {webform_user_component_map} WHERE nid = :nid', array('nid' => $node->nid));
}

/**
 * Database function, creates an array to map webform component fields to user profile fields from DB.
 */
function webform_user_user_map($nid) {
  $map = array();
  $result = db_query('SELECT w.form_key, c.cid, c.map_id, w.type, f.field_name FROM {webform_component} w ' .
    'INNER JOIN {webform_user_component_map} c ON c.cid = w.cid AND c.nid = w.nid ' .
    'LEFT JOIN {field_config_instance} f ON f.id = c.map_id ' .
    'WHERE c.nid = :nid ' .
    'ORDER BY c.cid',
    array(':nid' => $nid)
  );
  while ($row = $result->fetchObject()) {
    $map[$row->form_key] = $row->field_name ? $row->field_name : $row->map_id;
  }
  return $map;
}

/**
 * Database function, clone component map settings.
 */
function webform_user_clone_component_map($node, $original_nid) {
  $originals = db_query('SELECT cid, map_id FROM {webform_user_component_map} m WHERE nid = :nid',
    array(':nid' => $original_nid));
  $mapped = FALSE;
  foreach ($originals as $original) {
    $new = (array) $original;
    $new['nid'] = $node->nid;
    drupal_write_record('webform_user_component_map', $new);
    $mapped = TRUE;
  }
  if ($mapped) {
    drupal_set_message(t('User profile fields have been mapped to webform components, use the "User Map" tab to edit the map.'));
  }
}

/**
 * Implements hook_theme_registry_alter().
 *
 * We're overriding the theme function for the webform components table
 * so we can add granular access permissions to component actions and the "add" form.
 */
function webform_user_theme_registry_alter(&$theme_registry) {
  if (!empty($theme_registry['webform_components_form'])) {
    $theme_registry['webform_components_form']['file'] = 'webform_user.module';
    $theme_registry['webform_components_form']['function'] = 'theme_webform_user_webform_components_form';
    $theme_registry['webform_components_form']['theme_path'] = drupal_get_path('module', 'webform_user');
    $theme_registry['webform_components_form']['includes'] = array();
  }
}

/**
 * Override webform components table theme function.
 *
 * We need to hide edit, delete, and add functionality based
 * on additional permissions.
 */
function theme_webform_user_webform_components_form($variables) {
  $form = $variables['form'];

  $form['components']['#attached']['library'][] = array('webform', 'admin');

  // TODO: Attach these. See http://drupal.org/node/732022.
  drupal_add_tabledrag('webform-components', 'order', 'sibling', 'webform-weight');
  drupal_add_tabledrag('webform-components', 'match', 'parent', 'webform-pid', 'webform-pid', 'webform-cid');

  $node = $form['#node'];

  $header = array(t('Label'), t('Type'), t('Value'), t('Mandatory'), t('Weight'), array(
      'data' => t('Operations'),
      'colspan' => 3,
    ));

  // Add a row containing form elements for a new item.
  unset($form['add']['name']['#title'], $form['add_type']['#description']);
  $form['add']['name']['#attributes']['rel'] = t('New component name');
  $form['add']['name']['#attributes']['class'] = array('webform-default-value');
  $form['add']['cid']['#attributes']['class'] = array('webform-cid');
  $form['add']['pid']['#attributes']['class'] = array('webform-pid');
  $form['add']['weight']['#attributes']['class'] = array('webform-weight');
  $row_data = array(
    drupal_render($form['add']['name']),
    drupal_render($form['add']['type']),
    '',
    drupal_render($form['add']['mandatory']),
    drupal_render($form['add']['cid']) . drupal_render($form['add']['pid']) . drupal_render($form['add']['weight']),
    array(
      'colspan' => 3,
      'data' => drupal_render($form['add']['add']),
    ),
  );
  $add_form = array(
    'data' => $row_data,
    'class' => array('draggable', 'webform-add-form'),
  );
  $form_rendered = FALSE;

  if (!empty($node->webform['components'])) {
    $component_tree = array();
    $page_count = 1;
    _webform_components_tree_build($node->webform['components'], $component_tree, 0, $page_count);
    $component_tree = _webform_components_tree_sort($component_tree);
    // Build the table rows.

    foreach ($component_tree['children'] as $cid => $component) {
      _webform_components_form_rows($node, $cid, $component, 0, $form, $rows, $add_form);
    }
  }
  else {
    $rows[] = array(array(
        'data' => t('No Components, add a component below.'),
        'colspan' => 9,
      ));
  }

  // Append the add form if not already printed.
  if ($add_form && user_access('alter webform components')) {
    $rows[] = $add_form;
  }

  $output = '';
  $output .= theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => 'webform-components')));
  $output .= user_access('alter webform components') ? drupal_render_children($form) : '';
  return $output;
}

function _webform_user_edit_component_link($node, $cid) {
  if (user_access('alter webform components')) {
    return l(t('Edit'), 'node/' . $node->nid . '/webform/components/' . $cid, array('query' => drupal_get_destination()));
  }
  return '';
}

function _webform_user_clone_component_link($node, $cid) {
  if (user_access('alter webform components')) {
    return l(t('Clone'), 'node/' . $node->nid . '/webform/components/' . $cid . '/clone', array('query' => drupal_get_destination()));
  }
  return '';
}

function _webform_user_delete_component_link($node, $cid) {
  if (user_access('alter webform components')) {
    return l(t('Delete'), 'node/' . $node->nid . '/webform/components/' . $cid . '/delete', array('query' => drupal_get_destination()));
  }
  return '';
}

function _webform_components_form_rows($node, $cid, $component, $level, &$form, &$rows, &$add_form) {
  // Create presentable values.
  if (drupal_strlen($component['value']) > 30) {
    $component['value'] = drupal_substr($component['value'], 0, 30);
    $component['value'] .= '...';
  }
  $component['value'] = check_plain($component['value']);

  // Remove individual titles from the mandatory and weight fields.
  unset($form['components'][$cid]['mandatory']['#title']);
  unset($form['components'][$cid]['pid']['#title']);
  unset($form['components'][$cid]['weight']['#title']);

  // Add special classes for weight and parent fields.
  $form['components'][$cid]['cid']['#attributes']['class'] = array('webform-cid');
  $form['components'][$cid]['pid']['#attributes']['class'] = array('webform-pid');
  $form['components'][$cid]['weight']['#attributes']['class'] = array('webform-weight');

  // Build indentation for this row.
  $indents = '';
  for ($n = 1; $n <= $level; $n++) {
    $indents .= '<div class="indentation">&nbsp;</div>';
  }

  // Add each component to a table row.
  $row_data = array(
    $indents . filter_xss($component['name']),
    $form['add']['type']['#options'][$component['type']],
    ($component['value'] == '') ? '-' : $component['value'],
    drupal_render($form['components'][$cid]['mandatory']),
    drupal_render($form['components'][$cid]['cid']) . drupal_render($form['components'][$cid]['pid']) . drupal_render($form['components'][$cid]['weight']),
    _webform_user_edit_component_link($node, $cid),
    _webform_user_clone_component_link($node, $cid),
    _webform_user_delete_component_link($node, $cid),
  );
  $row_class = array('draggable');
  if (!webform_component_feature($component['type'], 'group')) {
    $row_class[] = 'tabledrag-leaf';
  }
  if ($component['type'] == 'pagebreak') {
    $row_class[] = 'tabledrag-root';
    $row_class[] = 'webform-pagebreak';
    $row_data[0] = array(
      'class' => array('webform-pagebreak'),
      'data' => $row_data[0],
    );
  }
  $rows[] = array(
    'data' => $row_data,
    'class' => $row_class,
  );
  if (isset($component['children']) && is_array($component['children'])) {
    foreach ($component['children'] as $cid => $component) {
      _webform_components_form_rows($node, $cid, $component, $level + 1, $form, $rows, $add_form);
    }
  }

  // Add the add form if this was the last edited component.
  if (isset($_GET['cid']) && $component['cid'] == $_GET['cid'] && $add_form) {
    $add_form['data'][0] = $indents . $add_form['data'][0];
    $rows[] = $add_form;
    $add_form = FALSE;
  }
}
