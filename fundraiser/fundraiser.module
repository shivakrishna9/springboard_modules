<?php
/**
 * @file
 * Provides behaviors to handle donation form creation and donation submission.
 */

require_once 'includes/fundraiser.utility.inc';
require_once 'includes/fundraiser.donation.inc';
require_once 'includes/node/fundraiser.node.inc';
require_once 'includes/node/fundraiser.node_type.inc';

if (module_exists('node_clone')) {
  require_once 'includes/node/fundraiser.node_clone.inc';
}

require_once 'includes/fundraiser.refund.inc';
require_once 'includes/fundraiser.theme.inc';

/**
 * Implements hook_entity_info().
 */
function fundraiser_entity_info() {
  $info['fundraiser'] = array(
    'label' => t('Fundraiser'),
    'base table' => 'fundraiser',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'nid',
    ),
    'static cache' => TRUE,
    'bundles' => array(
      'fundraiser' => array(
        'label' => 'Fundraiser',
      ),
    ),
  );

  return $info;
}

/**
 * Implements hook_permission().
 */
function fundraiser_permission() {
  return array(
    'administer fundraiser' => array(
      'title' => t('Administer fundraiser'),
      'description' => t('Perform administration tasks for fundraiser.'),
    ),
    'refund donations' => array(
      'title' => t('Refund donations'),
      'description' => t('Refund donations for fundraiser.'),
    ),
    'create donation form' => array(
      'title' => t('Create donation form'),
      'description' => t('Create donation forms.'),
    ),
    'edit own donation form' => array(
      'title' => t('Edit own donation form'),
      'description' => t('Edit own donation forms.'),
    ),
    'edit any donation form' => array(
      'title' => t('Edit any donation form'),
      'description' => t('Edit any donation forms.'),
    ),
    'delete own donation form' => array(
      'title' => t('Delete own donation form'),
      'description' => t('Delete own donation forms.'),
    ),
    'delete any donation form' => array(
      'title' => t('Delete any donation form'),
      'description' => t('Delete any donation forms.'),
    ),
    'clone donation form' => array(
      'title' => t('Clone donation form'),
      'description' => t('Clone donation forms.'),
    ),
    'use gateway switcher' => array(
      'title' => t('Use the bulk gateway switcher'),
      'description' => t('Allows users to change donation form gateway configurations in bulk.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function fundraiser_menu() {
  // Admin paths.
  $items['admin/config/system/fundraiser'] = array(
    'title' => 'Fundraiser',
    'description' => 'Configurations for the Fundraiser system.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_admin_settings'),
    'access arguments' => array('administer fundraiser'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/fundraiser.admin.inc',
  );
  $items['admin/config/system/fundraiser/settings'] = array(
    'title' => 'Fundraiser',
    'description' => 'Configurations for the Fundraiser system.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_admin_settings'),
    'access arguments' => array('administer fundraiser'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'includes/fundraiser.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_boost_is_cacheable().
 *
 * If Boost is enabled, make sure donation form nodes aren't cached.
 */
function fundraiser_boost_is_cacheable($parts) {
  $args = $parts['args'];
  if ($args[0] == 'node' && isset($args[1]) && is_numeric($args[1]) && !isset($args[2])) {
    // It's a node, but is it a donation node?
    $node = node_load($args[1]);
    if (fundraiser_is_donation_type($node)) {
      // Don't cache donation forms
      $parts['is_cacheable'] = FALSE;
    }
  }
  return $parts;
}

/**
 * Implements hook_token_info().
 */
function fundraiser_token_info() {
  // Add a donation type.
  $info['types']['donation'] = array(
    'name' => t('Current donation'),
    'description' => t('Tokens related to specific donations.'),
    'needs-data' => 'donation',
  );
  // Donation tokens by field.
  $info['tokens']['donation'] = _fundraiser_donation_token_info();
  // Donation basic data.
  $info['tokens']['donation']['did'] = array(
    'name' => t('Donation ID'),
    'description' => t('The unique ID of the donation.'),
  );
  $info['tokens']['donation']['node'] = array(
    'name' => t('Fundraiser Node'),
    'description' => t('The fundraiser node the donation came from.'),
    'type' => 'node',
  );
  $info['tokens']['donation']['user'] = array(
    'name' => t('Donating User'),
    'description' => t('The user account the donation came from.'),
    'type' => 'user',
  );
  // Modify given for payment fields.
  if (isset($info['tokens']['donation']['payment_fields'])) {
    // Payment token fields are generated by the gateway and are not predictable.
    unset($info['tokens']['donation']['payment_fields']);
    unset($info['tokens']['donation']['other_amount']);
    // So we add the ones we know we want to support, they will be enpty if
    // the donation didn't set them.
    $info['tokens']['donation']['card_number'] = array(
      'name' => t('Last 4 of card number.'),
      'description' => t('The last four digits of the card number, ' .
        'available only if the user selected a credit card method supporting this token.'),
    );
    $info['tokens']['donation']['card_expiration_month'] = array(
      'name' => t('Card expiration month'),
      'description' => t('The expiration month of the card, ' .
        'available only if the user selected a credit card method supporting this token.'),
    );
    $info['tokens']['donation']['card_expiration_year'] = array(
      'name' => t('Card expiration year'),
      'description' => t('The expiration year of the card, ' .
        'available only if the user selected a credit card method supporting this token.'),
    );
    $info['tokens']['donation']['card_type'] = array(
      'name' => t('Card type'),
      'description' => t('The type of credit card, ' .
        'available only if the user selected a credit card method supporting this token.'),
    );
  }

  // The currency is a special case.
  $info['tokens']['donation']['currency:code'] = array(
    'name' => t('Currency code'),
    'description' => t('The currency code. For example, "USD".'),
  );
  $info['tokens']['donation']['currency:name'] = array(
    'name' => t('Currency name'),
    'description' => t('The full currency name. For example, "United States Dollar".'),
  );
  $info['tokens']['donation']['currency:symbol'] = array(
    'name' => t('Currency symbol'),
    'description' => t('The currency symbol. For example, "$".'),
  );

  return $info;
}

/**
 * Recursive to build up form info for tokens.
 */
function _fundraiser_donation_token_info($fields = NULL, $tokens = array()) {
  if ($fields == NULL) {
    $fields = _fundraiser_field_info();
  }
  $children = element_children($fields);
  foreach ($children as $child) {
    // TODO Adjust this tokening to account for the new changed in donation fields.
    $disallowed = array('card_cvv', 'currency');
    if (isset($fields[$child]['#type']) && $fields[$child]['#type'] != 'fieldset' && !in_array($child, $disallowed)) {
      // Add children.
      $tokens[$child] = array(
        'name' => isset($fields[$child]['#title']) ? $fields[$child]['#title'] : $child,
        'description' => t('Donation field information.'),
      );
    }
    else {
      // Recurse for more.
      $tokens = _fundraiser_donation_token_info($fields[$child], $tokens);
    }
  }
  return $tokens;
}

/**
 * Implements hook_tokens().
 */
function fundraiser_tokens($type, $tokens, $data = array(), $options = array()) {
  $replacements = array();
  $sanitize = !empty($options['sanitize']);

  if ($type == 'donation' && !empty($data['donation'])) {

    $donation = $data['donation'];
    // All set fields.
    $data = is_array($donation->donation) ? $donation->donation : array();
    // User and etc types.
    $data['did'] = isset($donation->did) ? $donation->did : '';
    $data['node'] = isset($donation->node->nid) ? $donation->node->nid : '';
    $data['user'] = isset($donation->user->uid) ? $donation->user->uid : '';
    // Specific changes for payment fields.
    if (isset($data['payment_fields'])) {
      // Payment token fields are generated by the gateway and are not predictable across all nodes.
      // Since the nodes are individually configurable. We wouldn't be able to predict all element.
      unset($data['payment_fields']);
      $data['card_number'] = isset($donation->donation['payment_fields']['credit']['card_number']) ?
        substr($donation->donation['payment_fields']['credit']['card_number'], -4) : '';
      $data['card_expiration_month'] = isset($donation->donation['payment_fields']['credit']['card_expiration_month']) ?
        $donation->donation['payment_fields']['credit']['card_expiration_month'] : '';
      $data['card_expiration_year'] = isset($donation->donation['payment_fields']['credit']['card_expiration_year']) ?
        $donation->donation['payment_fields']['credit']['card_expiration_year'] : '';
      $data['card_type'] = isset($donation->donation['payment_fields']['credit']['card_type']) ?
        $donation->donation['payment_fields']['credit']['card_type'] : '';
    }

    if (is_array($data['currency'])) {
      foreach ($data['currency'] as $key => $value) {
        $data['currency:' . $key] = $value;
      }
    }

    // Replace the given tokens.
    foreach ($tokens as $key => $token) {
      if (isset($data[$key])) {
        $replacements[$token] = $sanitize ? check_plain($data[$key]) : $data[$key];
      }
    }

    // If we have a donation object add the node and user tokens as well.
    if (!empty($donation)) {
      if ($node_tokens = token_find_with_prefix($tokens, 'node')) {
        $replacements += token_generate('node', $node_tokens, array('node' => $donation->node), $options);
      }
      if ($user_tokens = token_find_with_prefix($tokens, 'user')) {
        $replacements += token_generate('user', $user_tokens, array('user' => $donation->user), $options);
      }
    }

    // Make more user-friendly label for payment method token.
    if (isset($data['payment_method']) && isset($donation->node)) {
      // Get node gateways and loop through them.
      foreach ($donation->node->gateways as $gateway) {
        // If donation's payment method matches gateway, use label for
        // gateway token.
        if (array_key_exists('method', $gateway) && array_key_exists('label', $gateway) && $data['payment_method'] == $gateway['method'] && $gateway['label']) {
          $replacements['[donation:payment_method]'] = $gateway['label'];
        }
      }
    }

  }

  return $replacements;
}

/**
 * Implements hook_views_api().
 */
function fundraiser_views_api() {
  return array(
    'api' => 2,
  );
}

/**
 * Donation field definitions.
 */

/**
 * Provides a list of fields to be defined by the display module.
 * Requests additional field information from other modules that need to define them.
 */
function _fundraiser_field_info($refresh = FALSE) {
  $fields = &drupal_static(__FUNCTION__, array());
  // Cache fundraiser content types during page execution.
  if (empty($fields) || $refresh == TRUE) {
    // Request additional fields from other modules.
    $fields = module_invoke_all('fundraiser_field_info');
    // Allow for others to modify as needed.
    drupal_alter('fundraiser_field_info', $fields);
  }
  // And return.
  return $fields;
}

/**
 * Implements hook_fundraiser_field_info().
 */
function fundraiser_fundraiser_field_info() {
  // Donation amounts are handled in a special case.
  $fields['donation'] = array(
    '#title' => t('Donation'),
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['donation']['amount'] = array(
    '#title' => t('Amount'),
    '#type' => 'textfield',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'width' => 10,
      'field_prefix' => '$',
    ),
    '#allow_update' => 1,
    '#reset_value' => 1,
    '#create_callback' => '_fundraiser_amount_field_create',
  );
  $fields['donation']['other_amount'] = array(
    '#title' => t('Other'),
    '#type' => 'textfield',
    '#required' => 0,
    '#extra' => array(
      'description' => t('Minimum payment $ @min.', array(
        '@min' => number_format(variable_get('fundraiser_default_minimum', 10.00), 2),
      )),
      'width' => 10,
      'field_prefix' => '$',
    ),
    '#allow_update' => 1,
    '#create_callback' => '_fundraiser_other_amount_field_create',
    '#validate_callback' => '_fundraiser_other_amount_field_validate',
    '#display_callback' => '_fundraiser_other_amount_field_display',
  );

  $fields['donation']['currency'] = array(
    '#title' => 'Currency',
    '#type' => 'hidden',
    '#value' => '',
    '#required' => 1,
    '#allow_update' => 1,
    '#reset_value' => 1,
    '#create_callback' => '_fundraiser_currency_field_create',
    '#display_callback' => '_fundraiser_currency_field_display',
  );

  $fields['donor_information'] = array(
    '#title' => t('Your Information'),
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['donor_information']['first_name'] = array(
    '#title' => t('First Name'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['donor_information']['last_name'] = array(
    '#title' => t('Last Name'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['donor_information']['mail'] = array(
    '#title' => t('E-mail address'),
    '#type' => 'email',
    '#required' => 1,
    '#validate_callback' => '_fundraiser_email_field_validate',
  );
  $fields['billing_information'] = array(
    '#title' => t('Billing Information'),
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['billing_information']['address'] = array(
    '#title' => t('Address'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['address_line_2'] = array(
    '#title' => t('Address Line 2'),
    '#type' => 'textfield',
    '#required' => 0,
  );
  $fields['billing_information']['city'] = array(
    '#title' => t('City'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['country'] = array(
    '#title' => t('Country'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['state'] = array(
    '#title' => t('State/Province'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['zip'] = array(
    '#title' => t('ZIP/Postal Code'),
    '#type' => 'textfield',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'width' => 10,
      'maxlength' => 10,
    ),
  );
  $fields['payment_information'] = array(
    '#title' => t('Payment Information'),
    '#type' => 'fieldset',
    '#required' => 0,
  );

  /**
   * These two fields are intended to hold the payment method information and
   * the array of user entered data for the payment method. They replace
   * previous implementations relying on CC fields.
   */
  $fields['payment_information']['payment_method'] = array(
    '#title' => t('Payment Method'),
    '#type' => 'payment_method',
    '#required' => 1,
    '#allow_update' => 1,
    '#create_callback' => '_fundraiser_payment_method_field_create',
  );
  $fields['payment_information']['payment_fields'] = array(
    '#title' => t('Payment Details'),
    '#type' => 'payment_fields',
    '#required' => 0,
    /**
     * Instead of returning the value of this field it's treated more like a
     * variable fieldset. The values returned are dependant on the value
     * returned by payment method by gateway.
     * In the format:
     * 'payment_fields' => array(
     *   'credit' => array(
     *     'card_number' => '',
     *     'card_expiration_month' => '',
     *     'card_expiration_year' => '',
     *     'card_cvv' => '',
     *   )
     *   'paypal' => array(
     *     'paypal_email' => '',
     *   )
     *   'debit' => array(
     *     'debit_routing' => '',
     *     'debit_account' => '',
     *   )
     * );
     */
  );
  return $fields;
}

/**
 * Field callback to update the field with fundraiser specific settings.
 */
function _fundraiser_amount_field_create($fundraiser, $field) {
  $currency = fundraiser_get_currency_from_node($fundraiser);
  $currency_symbol = check_plain($currency['symbol']);

  // If donation amounts don't exist, use amount as is.
  if (empty($fundraiser->donation_amounts) || !is_array($fundraiser->donation_amounts)) {
    // Show the minimum amount when only displaying an amount text box.
    $field['#extra']['description'] = 'Minimum payment ' . $currency_symbol . number_format($fundraiser->minimum_donation_amount, 2) . '.';
    return $field;
  }
  // Else we want a select field.
  if (is_array($fundraiser->donation_amounts)) {
    // Since we have an array of donation_amounts, set the field data to match.
    $keys = array_keys($fundraiser->donation_amounts);
    // Construct a set of options based on the configured amounts.
    $formatted_amounts = '';
    foreach ($fundraiser->donation_amounts as $value => $label) {
      if (empty($label)) {
        $label = $currency_symbol . $value;
      }
      $formatted_amounts[] = implode('|', array($value, $label));
    }
    if ($fundraiser->show_other_amount && count($fundraiser->donation_amounts)) {
      // Strip out other other|Other combiantions and make sure this is at the end.
      $formatted_amounts = array_diff($formatted_amounts, array('other|Other'));
      $formatted_amounts[] = 'other|Other';
    }
    $formatted_amounts = implode("\n", $formatted_amounts);
    $field['#title'] = t('Please select your tax-deductible gift amount below');
    $field['#type'] = 'select';
    $field['#extra'] = array(
      'description' => '',
      'items' => $formatted_amounts,
      'multiple' => 0,
    );
    $default = $keys[0];
    if (empty($fundraiser->default_amount)) {
      $default = '';
    }
    else if (in_array($fundraiser->default_amount, $keys)) {
      // Default is one of the defined ask amounts. Use it, but make sure the formatting matches the ask amount exactly.
      foreach ($keys as $ask_amount) {
        if ($ask_amount == $fundraiser->default_amount) {
          $default = $ask_amount;
          break;
        }
      }
    }

    // Extra settings may get clobbered in fundraiser_webform. if we don't flag them.
    // See "extra config" comment under _fundraiser_webform_update_component().
    if (!empty($field['#extra'])) {
      $field['#node_extra_settings'] = $field['#extra'];
    }

    $field['#value'] = $default;

  }

  return $field;
}

/**
 * Field callback, called at runtime to update the field with fundraiser specific settings during creation.
 */
function _fundraiser_other_amount_field_create($fundraiser, $field) {
  // If donation amounts don't exist, drop the amount_other field, and use amount as is.
  if (empty($fundraiser->donation_amounts) || !is_array($fundraiser->donation_amounts)) {
    return FALSE; // FALSE as opposed to empty, means we delete this field if it exists.
  }
  // If the show other options is disallowed, unset it.
  if (!$fundraiser->show_other_amount) {
    return FALSE; // FALSE as opposed to empty, means we delete this field if it exists.
  }
  // Update the min with fundraiser's min.
  $field['#extra']['description'] = $field['#node_extra_settings']['description'] =
    'Minimum payment [currency-symbol]' . number_format($fundraiser->minimum_donation_amount, 2) . '.';

  // Return the field to be created.
  return $field;
}

/**
 * Fundraiser field display callback for the other amount field.
 */
function _fundraiser_other_amount_field_display($form, $form_state, $field) {
  // Get the currency, either from a current donation or the node.
  if (!empty($form['#donation'])) {
    $currency = $form['#donation']->donation['currency'];
  }
  else {
    $currency = fundraiser_get_currency_from_node($form['#node']);
  }

  $field['#attributes']['class'][] = 'input-medium';
  $field['#field_prefix'] = $currency['symbol'];

  // Replace the currency-symbol token.
  if (isset($field['#description'])) {
    $field['#description'] = str_replace('[currency-symbol]', $currency['symbol'], $field['#description']);
  }

  return $field;
}

/**
 * Validation callback for field other_amount. Called during form validation.
 */
function _fundraiser_other_amount_field_validate($form, $form_state, $submission_fields, $value) {
  // Check for confusing selection.
  if (!empty($submission_fields['amount']) && $submission_fields['amount'] != "other" && !empty($submission_fields['other_amount'])) {
    return array(
      'amount' => t('You have entered a custom amount and selected a set amount. Please clarify which amount you ' .
        'intend to give, if you want to give the amount that appears in the other box, please select Other from ' .
        'the radio buttons.'),
      'other_amount' => '',
    );
  }
  $value = $submission_fields['amount'];
  // Look for other amount if set.
  if ($submission_fields['amount'] == 'other') {
    $value = $submission_fields['other_amount'];
  }
  // Check for valid value.
  if (!preg_match('/^\d*(\.\d*)?$/', $value)) {
    return array('other_amount' => t('Donation amount must be in a valid number format. No commas and only one decimal point.'));
  }
  // Check for minimum amount.
  $fundraiser = _fundraiser_get_fundraiser_by_nid($form['#node']->nid);
  $minimum_donation_amount = isset($fundraiser->minimum_donation_amount) ?
    $fundraiser->minimum_donation_amount :  variable_get('fundraiser_default_minimum', 10.00);
  $minimum_donation_amount = number_format($minimum_donation_amount, 2);
  if ($value < $minimum_donation_amount) {
    return array('other_amount' => t('Your donation amount must be greater than or equal to @min_amount.',
      array('@min_amount' => $minimum_donation_amount)));
  }
}

/**
 * Fundraiser field create callback.
 *
 * Sets the currency value from the node.
 */
function _fundraiser_currency_field_create($fundraiser, $field) {
  $currency = fundraiser_get_currency_from_node($fundraiser);
  $field['#value'] = $currency['code'];

  return $field;
}

/**
 * Fundraiser field display callback.
 *
 * Note this field is a value type, so not really displayed.
 */
function _fundraiser_currency_field_display($form, $form_state, $field) {
  // Get the currency, either from a current donation or the node.
  if (!empty($form['#donation'])) {
    $currency = $form['#donation']->donation['currency'];
  }
  else {
    $currency = fundraiser_get_currency_from_node($form['#node']);
  }

  $field['#value'] = $currency['code'];
  return $field;
}

/**
 * Validation callback for field email. Called during form validation.
 */
function _fundraiser_email_field_validate($form, $form_state, $submission_fields, $value) {
  if (!_fundraiser_validate_email(trim($value))) {
    return array('mail' => t('You must enter a valid email address.'));
  }
}

/**
 * Field callback, called at runtime to update the field with fundraiser specific settings during creation.
 */
function _fundraiser_payment_method_field_create($fundraiser, $field) {
  // If donation amounts don't exist, use amount as is.
  if (empty($fundraiser->gateways)) {
    // Leave it alone, do nothing else, don't overwrite existing values.
    $field['#allow_update'] = 0;
    return $field;
  }
  // Set all the fields for the gateways based on the configuration.
  $field['#extra'] = array(
    'payment_methods' => unserialize($fundraiser->gateways),
  );
  return $field;
}

/**
 * Asks the display glue module(s) for field information.
 * This allows other modules to find a field as needed in a form array.
 * For example - for retrieveing the AJAX return values of a form.
 */
function fundraiser_get_form_field($calling_module, $form, $field_key) {
  // Get the form element from the given form.
  if (module_hook($calling_module, 'fundraiser_get_form_field')) {
    return module_invoke($calling_module, 'fundraiser_get_form_field', $form, $field_key);
  }
  else {
    // Assume the form is a regularly constructed form and find it in a child somewhere.
    return _fundraiser_get_form_field($form, $field_key);
  }
}

/**
 * Asks the display glue module(s) to update field information.
 * This allows other modules to update a field as needed in a form array.
 */
function fundraiser_update_form_field($calling_module, $form, $field_key, $new_field) {
  // Save the changed form element.
  if (module_hook($calling_module, 'fundraiser_update_form_field')) {
    return module_invoke($calling_module, 'fundraiser_update_form_field', $form, $field_key, $new_field);
  }
  else {
    return _fundraiser_update_form_field($form, $field_key, $new_field);
  }
}

/**
 * There is no need for a creation function here to handle creating fields in a hook.
 * That is something the display glue module should be able to handle on it's own
 * given access to the callback information. No reason to put that in the central module.
 */

/**
 * Process through given submission fields to change their display form on the fly. Recursive.
 * Calling module provides the identity of the display glue module. Usually webform, could be sustainers.
 */
function fundraiser_display_form_fields($calling_module, &$form, $form_state, $field_info = NULL) {
  if ($field_info == NULL) {
    $field_info = _fundraiser_field_info();
  }
  $children = element_children($field_info);
  foreach ($children as $child) {
    if (isset($field_info[$child]['#display_callback']) && function_exists($field_info[$child]['#display_callback'])) {
      // Get the field, update it, and put it back.
      $this_field = fundraiser_get_form_field($calling_module, $form, $child);
      $new_field = call_user_func($field_info[$child]['#display_callback'], $form, $form_state, $this_field);
      $form = fundraiser_update_form_field($calling_module, $form, $child, $new_field);
    }
    // Check for any further children.
    fundraiser_display_form_fields($calling_module, $form, $form_state, $field_info[$child]);
  }
}

/**
 * Process through given submission fields to validate on the fly. Recursive.
 * This handles the calls to additional validation callbacks as defined in the field_info array.
 * May be called by any module that needs to perform validation on a submitted array. See sustainers.
 *
 * @return bool
 *   TRUE if there are validation errors.
 */
function fundraiser_validate_form_fields($form, $form_state, $submission_fields, $field_info = NULL, $errors = FALSE) {
  // Grab field info, we'll use this all the way down.
  if ($field_info == NULL) {
    $field_info = _fundraiser_field_info();
    drupal_alter('fundraiser_field_info_validate', $field_info, $form);
  }
  // Check for errors by field info array.
  $children = element_children($field_info);
  foreach ($children as $child) {
    $keys[$child] = '';
    // Check only if the submission field is set.
    // And the additional validate callback exists.
    if (isset($submission_fields[$child]) && isset($field_info[$child]['#validate_callback'])
       && function_exists($field_info[$child]['#validate_callback'])) {
      $error_messages = call_user_func($field_info[$child]['#validate_callback'], $form, $form_state,
        $submission_fields, $submission_fields[$child]);
      if (isset($error_messages) && !empty($error_messages)) {
        foreach ($error_messages as $form_field => $error_message) {
          // Set the error.
          $this_field = _fundraiser_get_form_field($form, $form_field);
          $parents = implode('][', $this_field['#parents']);
          form_set_error($parents, $error_message); // Coder: This is ok.
          $errors = TRUE;
        }
      }
    }
    // Recurse down.
    $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields, $field_info[$child], $errors);
  }
  return $errors;
}

/**
 * Given a standard form array, recursively locate a given key and return it.
 */
function _fundraiser_get_form_field($form, $field_key) {
  foreach (element_children($form) as $child) {
    if ($child == $field_key) {
      return $form[$child];
    }
    else {
      // Check this child for other children.
      $found = _fundraiser_get_form_field($form[$child], $field_key);
      if (!empty($found)) {
        return $found;
      }
    }
  }
}

/**
 * Given a standard (non webform, nothing fancy, form array. Locate a given key and update it.
 * Recursive.
 */
function _fundraiser_update_form_field($form, $field_key, $new_field) {
  // Walks a given form looking for the given key. Returns it when found.
  foreach (element_children($form) as $child) {
    if ($child == $field_key) {
      // Update the array.
      $form[$child] = array_merge($form[$child], $new_field);
    }
    else {
      // Check this child for other children.
      $form[$child] = _fundraiser_update_form_field($form[$child], $field_key, $new_field);
    }
  }
  return $form;
}

/**
 * Helper functions.
 */

/**
 * Helper function, given the array from field_info - get the listed keys.
 * WARNING: Recursion is here to walk the field info array to gather form keys.
 */
function _fundraiser_get_field_keys($field_info = NULL, $keys = array()) {
  if ($field_info == NULL) {
    $field_info = _fundraiser_field_info();
  }
  $children = element_children($field_info);
  $keys = array_merge($keys, $children);
  foreach ($children as $child) {
    if ($field_info[$child] != NULL && !empty($field_info[$child])) {
      $keys = _fundraiser_get_field_keys($field_info[$child], $keys);
    }
  }
  return $keys;
}

/**
 * Helper function, given the array from field_info - get the listed fields.
 * WARNING: Recursion is here to walk the field info array to gather fields.
 */
function _fundraiser_get_field_fields($field_info = NULL, $fields = array()) {
  if ($field_info == NULL) {
    $field_info = _fundraiser_field_info();
  }
  $children = element_children($field_info);
  foreach ($children as $child) {
    $fields[$child] = $field_info[$child];
  }
  foreach ($children as $child) {
    if ($field_info[$child] != NULL && !empty($field_info[$child])) {
      $fields = _fundraiser_get_field_fields($field_info[$child], $fields);
    }
  }
  return $fields;
}

/**
 * DB functions.
 */

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_create_fundraiser($fundraiser) {
  $fundraiser = (array) $fundraiser;
  $fundraiser_data = FALSE;
  if (isset($fundraiser['nid'])) {
    $fundraiser_data = _fundraiser_get_fundraiser_by_nid($fundraiser['nid']);
  }
  if (!$fundraiser_data) {
    // Implode donation amounds for saving.
    $imploded_amounts = array();
    $donation_amounts = FALSE;
    foreach ($fundraiser['donation_amounts'] as $index => $donation_amount) {
      if (isset($donation_amount['amount']) && isset($donation_amount['label'])) {
        // Settings are coming from the node edit page, each amount should be
        // an associative array with amount, label, and weight keys.
        $donation_amounts[$donation_amount['weight']] = $donation_amount['amount'] . '|' . $donation_amount['label'];
      }
    }
    if ($donation_amounts) {
      ksort($donation_amounts);
      $imploded_amounts = array_unique($donation_amounts);
    }
    // On getting fundraiser this will be exploded into the correct values.
    $fundraiser['donation_amounts'] = implode('|||', $imploded_amounts);
    // TODO: we should also store the donation_default internally, instead of
    // relying on fundraiser_webform to store that value for us.
    // For now, this will have to do.
    // Serialize for storage, our configured gateway values for storage in components.
    $fundraiser['gateways'] = isset($fundraiser['gateways']) ? serialize($fundraiser['gateways']) : serialize('');
    // After the node is created, add additional data to fundraiser.
    $record = array(
      'receipt_email_from' => variable_get('site_name', ''),
      'receipt_email_address' => variable_get('site_mail', ''),
      'receipt_email_subject' => t('Thank you for your donation'),
      'redirect_url' => '<confirmation>',
    );
    $record = array_merge($record, $fundraiser);
    if (isset($record['default_amount']) && empty($record['default_amount'])) unset($record['default_amount']); // NULL > empty
    drupal_write_record('fundraiser', $record);
    // And invoke the hooks for all the other modules to respond.
    module_invoke_all('fundraiser_create_fundraiser_alter', (object) $fundraiser);
  }
  else {
    _fundraiser_update_fundraiser($fundraiser);
  }
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_get_fundraiser_by_nid($nid) {
  // Get fundraiser table information.
  $fundraiser = db_query('SELECT * FROM {fundraiser} WHERE nid = :nid', array(':nid' => $nid))->fetchObject();
  if ($fundraiser) {
    // Explode the donation amounts that were imploded during save.
    $donation_amounts = explode('|||', $fundraiser->donation_amounts);
    $donation_amounts = array_unique($donation_amounts);
    $exploded_amounts = array();
    foreach ($donation_amounts as $donation_amount) {
      $exploded_amounts[] = explode('|', $donation_amount);
    }
    $fundraiser->donation_amounts = $exploded_amounts;
    // Get the unserialized gateway configurations.
    $fundraiser->gateways = unserialize($fundraiser->gateways);
    // Get values from other modules for additional information.
    module_invoke_all('fundraiser_get_fundraiser_alter', $fundraiser);
  }
  return $fundraiser;
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_update_fundraiser($fundraiser) {
  $fundraiser = (array) $fundraiser;
  $fundraiser_data = FALSE;
  if (isset($fundraiser['nid'])) {
    $fundraiser_data = _fundraiser_get_fundraiser_by_nid($fundraiser['nid']);
  }
  if (!$fundraiser_data) {
    _fundraiser_create_fundraiser($fundraiser);
  }
  else {
    $fundraiser = array_merge((array) $fundraiser_data, $fundraiser);
    // Implode donation amounds for saving.
    $imploded_amounts = array();
    $donation_amounts = array();
    foreach ($fundraiser['donation_amounts'] as $index => $donation_amount) {
      if (isset($donation_amount['weight']) && isset($donation_amount['amount'])) {
        // Settings are coming from the node edit page, each amount should be
        // an associative array with amount, label, and weight keys.
        $donation_amounts[$donation_amount['weight']] = $donation_amount['amount'] . '|' . $donation_amount['label'];
      }
      else {
        // Settings loaded directly from webform component, this means
        // the amount and label are in a numerically indexed array
        // and weight is not available.
        if (isset($donation_amount[0]) && isset($donation_amount[1])) {
          $donation_amounts[] = $donation_amount[0] . '|' . $donation_amount[1];
        }
      }
    }
    if (count($donation_amounts)) {
      ksort($donation_amounts);
      $imploded_amounts = array_unique($donation_amounts);
      // On getting fundraiser this will be exploded into the correct values.
      $fundraiser['donation_amounts'] = implode('|||', $imploded_amounts);
    }
    else {
      $fundraiser['donation_amounts'] = '';
    }
    // Serialize for storage, our configured gateway values for storage in components.
    $fundraiser['gateways'] = serialize($fundraiser['gateways']);
    $record = $fundraiser;
    if (isset($record['default_amount']) && empty($record['default_amount'])) unset($record['default_amount']); // NULL > empty
    drupal_write_record('fundraiser', $record, 'nid');
    // And invoke the hooks for all the other modules to respond.
    module_invoke_all('fundraiser_update_fundraiser_alter', (object) $fundraiser);
    // Fire a hook that other modules can use to add additional processing when a donation form is created.
    // Called in sf_donation.module
    // This can, and should, be replaced with hook_node_insert() implementations.
    // THIS HOOK IS TO BE DEPR.
    // module_invoke_all('fundraiser_form_insert', $node, $components);
  }
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_delete_fundraiser($nid) {
  db_delete('fundraiser')->condition('nid', $nid)->execute();
  // And invoke the hooks for all the other modules to respond.
  module_invoke_all('fundraiser_delete_fundraiser_alter', $nid);
}

/**
 * DB function for fundraiser.
 */
function _fundraiser_get_fundraiser_by_nids($nids) {
  // Get fundraiser table information.
  $fundraisers = array();
  foreach ($nids as $nid) {
    $fundraisers[$nid] = _fundraiser_get_fundraiser_by_nid($nid);
  }
  return $fundraisers;
}

/**
 * DB function for fundraiser.
 */
function _fundraiser_delete_fundraisers($nodes) {
  foreach ($nodes as $node) {
    _fundraiser_delete_fundraiser($node->nid);
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_create_donation($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_get_donation_by_did($donation['did']);
  }
  if (!$donation_data) {
    $record = array_merge((array) $donation_data, $donation);
    drupal_write_record('fundraiser_donation', $record);
  }
  else {
    _fundraiser_update_donation($donation);
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_get_donation_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_donation} ' .
    'WHERE did = :did',
    array(':did' => $did))->fetchObject();
}

/**
 * DB function for fundraiser_donation.
 */
function _fundraiser_get_donations() {
  return db_query('SELECT * FROM {fundraiser_donation}')->fetchAll();
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_update_donation($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_get_donation_by_did($donation['did']);
  }
  if (!$donation_data) {
    _fundraiser_create_donation($donation);
  }
  else {
    $record = array_merge((array) $donation_data, $donation);
    drupal_write_record('fundraiser_donation', $record, 'did');
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_delete_donation($did) {
  db_delete('fundraiser_donation')->condition('did', $did)->execute();
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_create_refund($refund) {
  // Cast donation just in case.
  $refund = (array) $refund;
  // Check for old data.
  $refund_data = FALSE;
  if (isset($refund['rid'])) {
    $refund_data = _fundraiser_get_refund_by_rid($refund['rid']);
  }
  if (!$refund_data) {
    drupal_write_record('fundraiser_refund', $refund);
  }
  else {
    $refund = _fundraiser_update_refund($refund);
  }
  return (object) $refund;
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_get_refund_by_rid($rid) {
  return db_query('SELECT * FROM {fundraiser_refund} ' .
    'WHERE rid = :rid',
    array(':rid' => $rid))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_update_refund($refund) {
  // Cast donation just in case.
  $refund = (array) $refund;
  // Check for old data.
  $refund_data = FALSE;
  if (isset($refund['rid'])) {
    $refund_data = _fundraiser_get_refund_by_rid($refund['rid']);
  }
  if (!$refund_data) {
    $refund = _fundraiser_create_refund($refund);
  }
  else {
    $record = array_merge((array) $refund_data, $refund); // Merge data together so we get everything in the record.
    drupal_write_record('fundraiser_refund', $refund, 'rid');
  }
  return (object) $refund;
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_delete_refund($rid) {
  db_delete('fundraiser_refund')->condition('rid', $rid)->execute();
}

/**
 * DB function for fundraiser_refund.
 */
function _fundraiser_get_refunds_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_refund} ' .
    'WHERE did = :did',
    array(':did' => $did))->fetchAll();
}

/**
 * DB function for fundraiser_refund.
 */
function _fundraiser_get_refund_by_txn_id($txn_id) {
  return db_query('SELECT * FROM {fundraiser_refund} ' .
    'WHERE txn_id = :txn_id',
    array(':txn_id' => $txn_id))->fetchAll();
}

/**
 * DB Function, Check if the given order was made on a payment gateway that supports refunds
 */
function _fundraiser_get_donation_gateway($did) {
  // First check the donation table. It trumps the fundraiser table in case the FR has changed since.
  $found_gateway = db_query('SELECT d.gateway FROM {fundraiser_donation} d ' .
    'WHERE d.did = :did', array(':did' => $did))->fetchField();
  // Now ask if any other module wants to override this result.
  drupal_alter('fundraiser_get_donation_gateway', $found_gateway);
  // Now translate that into something we can use by getting the rest of the dateway info.
  if (isset($found_gateway)) {
    return _fundraiser_gateway_info($found_gateway);
  }
  // If nothing has been found, return nothing.
  return array();
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_create_tracking($tracking) {
  $tracking = (array) $tracking;
  $tracking_data = FALSE;
  if (isset($tracking['nid'])) {
    $tracking_data = _fundraiser_get_tracking_by_nid($tracking['nid']);
  }
  if (!$tracking_data) {
    $record = array(
      'pageviews' => 1,
      'conversions' => 0,
      'local_failures' => 0,
      'gateway_failures' => 0,
      'latest_load_time' => 0,
    );
    $tracking = array_merge($record, $tracking);
    drupal_write_record('fundraiser_tracking', $tracking);
  }
  else {
    _fundraiser_update_tracking($tracking);
  }
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_get_tracking_by_nid($nid) {
  return db_query('SELECT * FROM {fundraiser_tracking} WHERE nid = :nid', array(':nid' => $nid))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_update_tracking($tracking) {
  /**
   * Code commented out on 2/18/2016 by pcave for performance reasons.
   * When a donation form encounters significant traffic, updating a single row
   * in this table over and over during a request can cause lock contentions.
   * This eventually cascades to other database operations thus slowing down
   * the entire response.
   *
   * $tracking = (array) $tracking;
   * $tracking_data = FALSE;
   * if (isset($tracking['nid'])) {
   *   $tracking_data = _fundraiser_get_tracking_by_nid($tracking['nid']);
   * }
   * if (!$tracking_data) {
   *   _fundraiser_create_tracking($tracking);
   * }
   * else {
   *   $tracking = array_merge((array) $tracking_data, $tracking);
   *   drupal_write_record('fundraiser_tracking', $tracking, 'nid');
   * }
   */
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_delete_tracking($nid) {
  /**
   * Code commented out on 2/18/2016 by pcave for performance reasons.
   * When a donation form encounters significant traffic, updating a single row
   * in this table over and over during a request can cause lock contentions.
   * This eventually cascades to other database operations thus slowing down
   * the entire response.
   *
   * db_delete('fundraiser_tracking')->condition('nid', $nid)->execute();
   */
}

/**
 * DB function for updating the stats in fundraiser_tracking.
 */
function _fundraiser_update_tracking_value($nid, $field) {
   /**
   * Code commented out on 2/18/2016 by pcave for performance reasons.
   * When a donation form encounters significant traffic, updating a single row
   * in this table over and over during a request can cause lock contentions.
   * This eventually cascades to other database operations thus slowing down
   * the entire response.
   *
   * $tracking = _fundraiser_get_tracking_by_nid($nid);
   * // No tracking data? Create one.
   * if (!$tracking) {
   *   $tracking = new stdClass();
   *   $tracking->nid = $nid;
   *   _fundraiser_create_tracking($tracking);
   *   $tracking = _fundraiser_get_tracking_by_nid($nid);
   * }
   * // Check to make sure we weren't handed a non-existing track.
   * if (isset($tracking->$field)) {
   *   $tracking->$field++;
   *   _fundraiser_update_tracking($tracking);
   * }
   */
  }

/**
 * Implements hook_webform_token_selector_blacklist_alter().
 *
 * Filter out credit card webform components.
 * Note: this replaces _fundraiser_field_blacklist().
 */
function fundraiser_webform_token_selector_blacklist_alter(&$tokens) {
  // These fields may or may not even have a value depending on the user's selected form of submission.
  // So this may not be a viable solution anymore.
  $fundraiser_blacklist = array(
    'card_number',
    'card_cvv',
    'recurs_monthly',
    'card_expiration_month',
    'card_expiration_year',
  );
  $tokens = array_merge($fundraiser_blacklist, $tokens);
}

/**
 * Implements hook_action_info().
 */
function fundraiser_action_info() {
  return array(
    '_fundraiser_gateway_switch_action' => array(
      'description' => t('Gateway Bulk Switch'),
      'label' => t('Switch the gateway configurations of multiple forms at once.'),
      'type' => 'node',
      'configurable' => TRUE,
      'triggers' => array('any'),
    ),
  );
}

/**
 * An action to change the gateway of a node.
 */
function _fundraiser_gateway_switch_action($node, $context = array()) {
  $orig_config = $node->gateways;
  // Only update the methods that have been selected.
  foreach ($context['update_methods'] as $method) {
    $node->gateways[$method] = $context['gateways'][$method];

    // If we're updating the default setting.
    if (!empty($context['update_default']) && !empty($context['gateways']['_default'])) {
      $node->gateways[$method]['default'] = ($context['gateways']['_default'] == $method) ? 1 : 0;
    }
    // Else use the original setting, if not in the original setting then set it
    // to 0.
    else {
      $node->gateways[$method]['default'] = !empty($orig_config[$method]['default']) ? $orig_config[$method]['default'] : 0;
    }

    // If we're updating the weights.
    if (!empty($context['update_weights'])) {
      $node->gateways[$method]['weight'] = $context['gateways'][$method]['weight'];
    }
    // Else use the original setting, if not in the original setting then set it
    // to 0.
    else {
      $node->gateways[$method]['weight'] = !empty($orig_config[$method]['weight']) ? $orig_config[$method]['weight'] : 0;
    }
  }

  _fundraiser_update_fundraiser($node);
}

/**
 * Configuration form for the gateway switching action.
 */
function _fundraiser_gateway_switch_action_form($context) {
  $gateways = _fundraiser_gateway_info();

  if (empty($gateways)) {
    return array();
  }

  // Create an array of available payment methods
  foreach ($gateways as $gateway) {
    $types = isset($gateway['payment_method']) ? $gateway['payment_method'] : array();
    foreach ($types as $type) {
      $methods[$type] = $type;
    }
  }

  // Checkboxes to select which payment methods will be updated
  $form['update_methods'] = array(
    '#title' => 'Payment Methods to Update',
    '#description' => t('Select the payment methods to update. Only select a payment method if you want its settings to be changed on all the forms.'),
    '#type' => 'checkboxes',
    '#options' => $methods,
  );

  // Option to update the default method across all the forms
  $form['update_default'] = array(
    '#title' => 'Update the default method',
    '#description' => t('Check this to change the default method across all these forms.'),
    '#type' => 'checkbox',
    '#return_value' => 1,
  );

  // Option to update the ordering accross all the forms
  $form['update_weights'] = array(
    '#title' => 'Update the ordering',
    '#description' => t('Check this to change the ordering of methods across all these forms.'),
    '#type' => 'checkbox',
    '#return_value' => 1,
  );

  $fieldset = array(
    '#type' => 'fieldset',
    '#title' => t('Payment methods'),
    '#description' => t('Enable donation form payment methods and their corresponding gateways.'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => TRUE,
    '#theme' => 'fundraiser_form_payment_methods',
  );

  $configuration = variable_get('fundraiser_payment_method_config_defaults', array());
  $form['gateways'] = _fundraiser_form_payment_method_config_fieldset($gateways, $configuration, $fieldset, 'gateways');

  foreach ($methods as $method) {
    foreach (element_children($form['gateways'][$method]) as $field_name) {
      // Add states to each config field to disable it if that payment method hasn't been selected
      $form['gateways'][$method][$field_name]['#states'] = array(
        'disabled' => array(
          ':input[name="update_methods[' . $method . ']"]' => array('checked' => FALSE),
        ),
      );
    }

    // Add states to hide the default and weight fields if that option isn't checked
    $form['gateways'][$method]['_default']['#states']['visible'][] = array(':input[name="update_default"]' => array('checked' => TRUE));
    $form['gateways'][$method]['weight']['#states']['visible'][] = array(':input[name="update_weights"]' => array('checked' => TRUE));
  }

  return $form;
}

/**
 * Validate handler for the gateway switch action form.
 */
function _fundraiser_gateway_switch_action_validate($form, $form_state) {
  $update_methods = array_filter($form_state['values']['update_methods']);
  // Ensure at least one method has been selected
  if (empty($update_methods)) {
    form_set_error('update_methods', 'Please select at least one payment method.');
    return;
  }

  // If updating the default method ensure an enabled payment method is selected as default
  $default_enabled = FALSE;
  if (!empty($form_state['values']['update_default'])) {
    foreach ($update_methods as $method) {
      if ($form_state['values']['gateways'][$method]['status'] == 1 && $form_state['values']['gateways']['_default'] == $method) {
        $default_enabled = TRUE;
      }
    }
    if (!$default_enabled) {
      form_set_error('update_default', "You've selected to update the default method but haven't chosen an enabled method.");
    }
  }
}

/**
 * Submit handler for the gateway switch action form.
 */
function _fundraiser_gateway_switch_action_submit($form, $form_state) {
  return array(
    'update_methods' => array_filter($form_state['values']['update_methods']),
    'update_default' => $form_state['values']['update_default'],
    'update_weights' => $form_state['values']['update_weights'],
    'gateways' => $form_state['values']['gateways'],
  );
}
/**
 * Implements hook_cron().
 *
 * Needed for gateway test mode status check.
 */
function fundraiser_cron() {
  if (module_exists("rules")) {
    $rule = rules_config_load('rules_gateway_test_mode_alert');
    if (!empty($rule->active) && in_array('fundraiser_gateway_test_mode_detected', $rule->events())) {
      fundraiser_gateway_status_check();
    }
  }
}

/**
 * Test to see if a published donation form's gateway is non-live.
 *
 * Send alert to admin if so.
 */
function fundraiser_gateway_status_check() {
  $bad_gateways = array();
  $gateways = _fundraiser_gateway_info();
  // Grab all fundraiser nodes along with publication status.
  $fundraisers = db_query('SELECT f.nid, f.gateways, n.status FROM {fundraiser} f INNER JOIN {node} n on n.nid = f.nid');

  foreach ($fundraisers as $fundraiser) {
    $fundraiser->gateways = unserialize($fundraiser->gateways);
    foreach($fundraiser->gateways as $type => $gateway) {
      $global_status = FALSE;
      if (!empty($gateway['id']) && $gateway['status'] == 1) {
        //grab the rules_config settings
        $fundraiser->gateways[$type]['gateway_details'] = isset($gateways[$gateway['id']]['gateway_details']) ? $gateways[$gateway['id']]['gateway_details'] : FALSE;
        //detect disabled or unconfigured gateways
        if ($fundraiser->gateways[$type]['gateway_details'] === FALSE) {
          $global_status = array('disabled');
        }
        else if (empty($fundraiser->gateways[$type]['gateway_details']['settings'])) {
          $global_status = array('unconfigured');
        }

        if (empty($global_status)) {
          $status = module_invoke_all("fundraiser_gateway_status_cron_check", $fundraiser->gateways[$type]['gateway_details']);
          if (!empty($status)) {
            $global_status = $status;
          }
        }
        //set up the token values for the alert
        if ($fundraiser->status == 1 &&  !empty($global_status[0]) && $global_status[0] != 'live') {
          $bad_gateways[$gateway['id']]['status'] = $global_status[0];
          $bad_gateways[$gateway['id']]['urls'][] = url('node/' . $fundraiser->nid, array('absolute' => TRUE));
          $bad_gateways[$gateway['id']]['type'] = $type;
        }
      }
    }
  }
  //build the info
  foreach ($bad_gateways as $id => $gateway) {
    //prepare the node urls for tokens
    $nodes = implode("\n\r", $gateway['urls']);
    //get the edit link for token
    $pos = strpos($id, '|');
    if ($pos !== FALSE) {
      $name = substr($id, $pos + 1);
      $edit_link = url('admin/commerce/config/payment-methods/manage/' . $name, array('absolute' => TRUE));
    }
    else {
      //this may never happen. but  you never know.
      $edit_link = t('(There was a problem determining the correct link. See below for additional info.)');
    }
    _fundraiser_gateway_status_alert($nodes, $gateway['type'], $id, $gateway['status'], $edit_link);
  }
}

function _fundraiser_gateway_status_alert($nodes, $method_type, $gateway_id, $status, $edit_link) {
  if (module_exists("rules")) {
    rules_invoke_event("fundraiser_gateway_test_mode_detected", $nodes, $method_type, $gateway_id, $status, $edit_link);
    watchdog('fundraiser', 'A test mode gateway configuration has been detected on a live donation form. Gateway: %gateway. Type: %type, Donation forms: %nodes', array('%gateway' => $gateway_id, '%type' => $method_type, '%nodes' => $nodes), WATCHDOG_EMERGENCY);

  }
}

/**
 * Implements hook_springboard_admin_alias_patterns().
 */
function fundraiser_springboard_admin_alias_patterns() {
  return array(
    'admin/commerce/config/currency' => array(
      'path' => array(
        'regex' => '|^/admin/commerce/config/currency|',
        'replacement' => 'admin/commerce/config/currency',
      ),
      'alias' => array(
        'regex' => '|^springboard/settings/config/currency|',
        'replacement' => 'springboard/settings/config/currency',
      ),
    ),
  );
}

/**
 * Implements hook_springboard_admin_admin_menu_items_alter().
 */
function fundraiser_springboard_admin_admin_menu_items_alter(&$items) {
  $items['admin/springboard/settings']['_children']['admin/springboard/settings/config']['_children']['admin/commerce/config/currency'] = array(
    'link_path' => 'admin/commerce/config/currency',
    'link_title' => 'Manage Currencies',
    'menu_name' => 'springboard_admin_menu',
    'expanded' => 0,
    'customized' => 1,
    'weight' => 0,
  );
}

/**
 * Log that a donation has processed and some other details for Log Analysis.
 *
 * @param object $donation
 *   The donation object.
 * @param array $log
 *   Additional log details, should include start/end times, and the type of transaction: charge, refund.
 */
function fundraiser_log_donation_processing($donation, $log = array()) {
  // Calculate the execution time.
  $exec_time = round($log['end'] - $log['start'], 4);

  // Setup the gateway details, the gateway name and config (rule name) are contained in the id.
  list($gateway, $gateway_config) = explode('|', $donation->gateway['id']);

  $pieces = array(
    'datetime',
    'category',
    'unique_transaction_id',
    'client_identifier',
    'payment_gateway',
    'payment_gateway_config',
    'transaction_type',
    'transaction_total_exec_time',
    'donation_value',
    'donation_currency',
    'country',
    'origin_ip',
    'success',
    'reference_charge',
  );

  $message = '|%' . implode('|%', $pieces);

  $variables = array(
    '%datetime' => date('c', $log['start']),
    '%category' => 'INFO',
    '%unique_transaction_id' => $donation->did,
    '%client_identifier' => $donation->uid,
    '%payment_gateway' => $gateway,
    '%payment_gateway_config' => $gateway_config,
    '%transaction_type' => $log['transaction_type'],
    '%transaction_total_exec_time' => $exec_time,
    '%donation_value' => !empty($donation->donation['amount']) ? $donation->donation['amount'] : '0.00',
    '%donation_currency' => !empty($donation->donation['currency']['code']) ? $donation->donation['currency']['code'] : 'N/A',
    '%country' => !empty($donation->donation['country']) ? $donation->donation['country'] : 'N/A',
    '%origin_ip' => ip_address(),
    '%success' => isset($donation->result['success']) ? (int) $donation->result['success'] : 0,
    '%reference_charge' => isset($donation->reference_charge) ? (int) $donation->reference_charge : 0,
  );

  watchdog('fundraiser_donation_tracker', $message, $variables, WATCHDOG_INFO);
}

/**
 * Clean up the input for an amount field.
 *
 * @param string $amount
 *   The amount entered from the submission.
 *
 * @return string
 *   The input amount stripped of any values other than a decimal point.
 */
function _fundraiser_amount_value_sanitize($amount) {
  return preg_replace('/[^\d\.]/i', '', $amount);
}

/**
 * Implements hook_springboard_node_expire_expiration_message().
 */
function fundraiser_springboard_node_expire_node_view_alter(&$node) {
  $node->content['webform']['#access'] = FALSE;
}

/**
 * Returns a form for updating billing information.
 *
 * @param array $form
 *   The form.
 * @param array &$form_state
 *   The form state.
 * @param array $data
 *   An array of data values:
 *   - "update billing": (boolean|optional) TRUE if you want this module to
 *   handle the validation and updating of billing information. If FALSE, the
 *   module calling this function is expected to handle the billing updating
 *   information itself.
 *   - "update cardonfile": (boolean|optional) TRUE if you would like to
 *   automatically add the necessary validation and submission handlers for
 *   updating a cardonfile card.
 *   - "card": (object|optional) The card object used to update the cardonfile
 *   card record. Useful if you want to override the card that will be updated
 *   as determined by $form_state['card'].
 *   - "calling module": (string|optional) The name of the module calling this
 *   function. Required if you would like to use the more granular preprocess,
 *   alter, and postprocess hooks called by this function.
 *   - "donation": (object|required) The donation object.
 *   - "payment fields": (array|optional) A form render array which will replace
 *   the "payment fields".
 *
 * @return array
 *   The form element.
 */
function fundraiser_update_billing_form($form, &$form_state, $data) {
  // Merge defaults with $data.
  $defaults = array(
    'update billing' => TRUE,
    'update cardonfile' => TRUE,
    'calling module' => 'fundraiser',
    'donation' => NULL,
    'card' => NULL,
  );
  $data = array_replace_recursive($defaults, $data);

  // Allow other modules to stop the process if something doesn't meet one of
  // their conditions. If return value is empty, we assume we can continue.
  // Otherwise we expect a form render array to return to the calling method.
  $functions = array(
    'fundraiser_update_billing_form_preprocess',
  );
  // If the 'calling module' array element is set, also provide a more granular
  // hook for modules to hook into. This granular hook name will be
  // `fundraiser_update_billing_form__{calling module}__preprocess`.
  if (isset($data['calling module']) && !empty($data['calling module'])) {
    $functions[] = sprintf('fundraiser_update_billing_form__%s__preprocess', $data['calling module']);
  }
  foreach ($functions as $function) {
    $continue = module_invoke_all($function, $form, $form_state, $data);
    if (!empty($continue)) {
      return $continue;
    }
  }

  $fundraiser_path = drupal_get_path('module', 'fundraiser');
  $form['#attached']['js'] = array(
    $fundraiser_path . '/js/jquery.alphanumeric.min.js',
    $fundraiser_path . '/js/jquery.validate.min.js',
    $fundraiser_path . '/js/donation_validation.js',
  );

  // Add the validation configuration settings array.
  $form_validation_js = _fundraiser_donation_form_js_validation_config($data['donation']->node);
  if (!empty($form_validation_js)) {
    $form['#attached']['js'][] = array(
      'data' => array('fundraiser' => array('js_validation_settings' => $form_validation_js)),
      'type' => 'setting',
    );
  }

  $form['#attributes']['class'][] = 'fundraiser-donation-form';
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $data['donation']->uid,
  );

  $field_info = _fundraiser_field_info();
  // The parts we need to allow for updating: donor info, billing and credit
  // card.
  $form['billing_information'] = array(
    '#type' => 'fieldset',
    '#title' => t('Billing Address'),
    '#attributes' => array('id' => 'billing-address'),
  );
  $billing_fields = array_merge($field_info['donor_information'], $field_info['billing_information']);
  foreach (element_children($billing_fields) as $field_key) {
    $field = $billing_fields[$field_key];
    $form['billing_information'][$field_key] = _fundraiser_create_field_from_info($field_key, $field, $data['donation']->donation);
  }

  // CC info.
  $form['payment_method'] = array(
    '#type' => 'hidden',
    '#value' => $data['donation']->donation['payment_method'],
  );
  $form['payment_fields'] = array(
    '#type' => 'fieldset',
    '#title' => 'Payment Information',
    '#attributes' => array('id' => 'credit-card-info'),
    '#tree' => TRUE,
  );
  $form['payment_fields'][$data['donation']->donation['payment_method']] = array(
    '#type' => 'fieldset',
    '#attributes' => array('id' => 'credit-card-info'),
  );

  // Pull the gateway form from the donation gateway.
  // Once set a gateway CANNOT be changed on a donation series.
  // Check against the gateway config for a specific form to go with this
  // payment gateway.
  if (isset($data['donation']->gateway['form callback'])) {
    $form_func = $data['donation']->gateway['form callback'];
    if (function_exists($form_func)) {
      $form['payment_fields'][$data['donation']->donation['payment_method']] += $form_func($data['donation']->donation['payment_method']);
    }
  }

  $form_state['op'] = 'update';

  $form['actions']['submit']['#type'] = 'submit';
  $form['actions']['submit']['#value'] = t('Save changes');
  $form['#validate'] = array();

  $form['#donation'] = $data['donation'];

  // Make the card number and cvv optional by default.
  $form['#attached']['js'][3]['data']['fundraiser']['js_validation_settings']['card_cvv']->required = FALSE;
  $form['#attached']['js'][3]['data']['fundraiser']['js_validation_settings']['card_number']->required = FALSE;

  if (!empty($data['card'])) {
    $form_state['card'] = $data['card'];
  }

  // If the "update cardonfile" element is non-empty, add the cardonfile
  // validation and submission handlers.
  if ($data['update cardonfile']) {
    $use_cardonfile = FALSE;
    if (!empty($data['card'])) {
      $use_cardonfile = TRUE;
    }
    elseif (($card = _fundraiser_donation_cardonfile_card($data['donation'])) !== FALSE) {
      $form_state['card'] = $data['card'] = $card;
      $use_cardonfile = TRUE;
    }

    if ($use_cardonfile) {
      // Using this instead of form_load_include because if this function isn't
      // called from a form constructor (fundraiser_sustainers), the include
      // isn't included.
      $form_state['build_info']['files']["commerce_cardonfile:includes/commerce_cardonfile.pages.inc"] = array(
        'type' => 'inc',
        'module' => 'commerce_cardonfile',
        'name' => 'includes/commerce_cardonfile.pages',
      );
      $form['#validate'][] = '_fundraiser_update_billing_form_commerce_cardonfile_card_form_alter_validate';
      $form['#validate'][] = 'commerce_cardonfile_card_form_validate';
      $form['actions']['submit']['#submit'][] = '_fundraiser_update_billing_form_commerce_cardonfile_card_form_submit';
    }
    elseif (empty($cardonfile)) {
      if (!function_exists('_fundraiser_commerce_credit_card_pane_values')) {
        module_load_include('module', 'fundraiser_commerce');
      }

      $stored_card = _fundraiser_commerce_credit_card_pane_values($data['donation']);

      if (empty($stored_card)) {
        drupal_set_message(t("A request to access a cardonfile card was made but either no matching card was available, or the card's gateway does not support the cardonfile module."), 'warning', FALSE);
      }
      else {
        $data['payment_fields']['credit']['expiration_date']['card_expiration_month']['#default_value'] = $stored_card['credit_card']['exp_month'];
        $data['payment_fields']['credit']['expiration_date']['card_expiration_year']['#default_value'] = $stored_card['credit_card']['exp_year'];
      }
    }
  }

  // Set any payment information from the $data variable.
  if (isset($data['payment_fields'])) {
    $form['payment_fields'] = array_replace_recursive($form['payment_fields'], $data['payment_fields']);
  }

  if (empty($form_state['donation'])) {
    $form_state['donation'] = $data['donation'];
  }

  // Allow other modules to make any further alterations to this form before we
  // finish with our own stuff.
  $functions = array(
    'fundraiser_update_billing_form',
  );
  if (!empty($data['calling module'])) {
    $functions[] = sprintf('fundraiser_update_billing_form__%s_', $data['calling module']);
  }
  foreach ($functions as $function) {
    drupal_alter($function, $form, $form_state, $data);
  }

  // If the "update billing" element is non-empty, add validation and submission
  // handlers that will validate and update the billing information. This
  // defaults to TRUE and is only FALSE if the calling module will handle this
  // itself.
  if ($data['update billing']) {
    $form['#validate'][] = 'fundraiser_update_billing_form_validate';
    $form['actions']['submit']['#submit'][] = 'fundraiser_update_billing_form_submit';
  }

  $form['#calling_module'] = empty($data['calling module']) ? 'fundraiser' : $data['calling module'];
  fundraiser_display_form_fields(empty($data['calling module']) ? 'fundraiser' : $data['calling module'], $form, $form_state);

  // And finally, call a post process hook for any modules that want to alter
  // the final output of the form, knowing we won't alter anything they do from
  // here on out.
  $functions = array(
    'fundraiser_update_billing_form_postprocess',
    sprintf('fundraiser_update_billing_form__%s__postprocess', $data['calling module']),
  );
  foreach ($functions as $function) {
    if (count(module_implements($function))) {
      $form = module_invoke_all($function, $form, $form_state, $data);
    }
  }

  return $form;
}

/**
 * Validation handler for commerce_cardonfile handling.
 *
 * Sets some array elements so the cardonfile module can correctly validate and
 * submit.
 *
 * @see fundraiser_quick_donate_form_commerce_cardonfile_card_form_alter
 */
function _fundraiser_update_billing_form_commerce_cardonfile_card_form_alter_validate(&$form, &$form_state) {
  $input = $form_state['input'];
  $values = &$form_state['values'];

  $card = $form_state['card'];
  // Ensure card number and cvv are set if expiration is changed.
  if ($card->card_exp_month != $values['payment_fields']['credit']['expiration_date']['card_expiration_month'] || $card->card_exp_year != $values['payment_fields']['credit']['expiration_date']['card_expiration_year']) {
    if (empty($values['payment_fields']['credit']['card_number'])) {
      form_set_error('payment_fields][credit][card_number', t('Please verify your card number to change the expiration date.'));
    }
    if (empty($values['payment_fields']['credit']['card_cvv'])) {
      form_set_error('payment_fields][credit][card_cvv', t('Please verify your card CVV to change the expiration date.'));
    }
  }

  $values['credit_card']['owner'] = $input['first_name'] . ' ' . $input['last_name'];
  $values['credit_card']['exp_month'] = $values['payment_fields']['credit']['card_expiration_month'] = $values['payment_fields']['credit']['expiration_date']['card_expiration_month'] = sprintf('%02d', $input['payment_fields']['credit']['expiration_date']['card_expiration_month']);
  $values['credit_card']['exp_year'] = $values['payment_fields']['credit']['expiration_date']['card_expiration_year'] = $values['payment_fields']['credit']['card_expiration_year'] = $input['payment_fields']['credit']['expiration_date']['card_expiration_year'];

  $form['credit_card']['number']['#default_value'] = $form_state['card']->card_number;
  if (!empty($values['payment_fields']['credit']['card_number'])) {
    $_SESSION['card_number'] = $values['credit_card']['number'] = $values['payment_fields']['credit']['card_number'];
  }
  else {
    $_SESSION['card_number'] = $values['credit_card']['number'] = $values['payment_fields']['credit']['card_number'] = $form_state['card']->card_number;
  }

  $form['credit_card']['code'] = $values['payment_fields']['credit']['card_cvv'];
  $values['credit_card']['cardonfile_instance_default'] = $form_state['card']->instance_default;
}

/**
 * Submit callback for fundraiser_update_billing_form().
 *
 * Copy of commerce_cardonfile_card_form_submit() from commerce_cardonfile.pages
 * .inc, needed to support some functionality for the billing update form.
 *
 * @see commerce_cardonfile_card_form_submit()
 */
function _fundraiser_update_billing_form_commerce_cardonfile_card_form_submit($form, &$form_state) {
  $op = $form_state['op'];
  $card = $form_state['card'];
  $values = $form_state['values'];

  $card->card_name = $form_state['values']['credit_card']['owner'];
  $card->card_exp_month = $form_state['values']['credit_card']['exp_month'];
  $card->card_exp_year = $form_state['values']['credit_card']['exp_year'];
  if ($op == 'create') {
    $card->card_number = substr($form_state['values']['credit_card']['number'], -4);
    $card->card_type = $form_state['values']['credit_card']['type'];
  }
  $card->instance_default = $form_state['values']['credit_card']['cardonfile_instance_default'];

  // Invoke the payment method's card create/update callback.
  $payment_method = commerce_payment_method_instance_load($card->instance_id);
  $callback = $payment_method['cardonfile'][$op . ' callback'];
  $success = FALSE;

  // If updating and CC number is empty, mark $success as TRUE since the
  // callback function shouldn't be called.
  if ($op == 'update' && (empty($values['credit_card']['number']) || $values['credit_card']['number'] == $card->card_number)) {
    $success = TRUE;
  }

  if (function_exists($callback) && !$success) {
    $callback_return = $callback($form, $form_state, $payment_method, $card);
    if ($callback_return) {
      if ($op == 'create') {
        $card_save = $callback_return;
        $confirm_message = t('A new card has been added.');
      }
      else {
        // Re-set the card type if the number changed.
        $card->card_type = commerce_payment_validate_credit_card_type($values['credit_card']['number'], array_keys(commerce_payment_credit_card_types()));

        $card_save = $card;
        $confirm_message = t('The card has been updated.');
      }

      commerce_cardonfile_save($card_save);
      drupal_set_message($confirm_message);
      $form_state['values']['cardonfile']['old_card'] = clone $card;
      $form_state['values']['cardonfile']['card'] = $card_save;
      $success = TRUE;
    }
  }

  if (!$success) {
    if ($op == 'create') {
      drupal_set_message(t('We encountered an error attempting to save your card data. Please try again and contact us if this error persists.'), 'error');
    }
    else {
      drupal_set_message(t('We encountered an error attempting to update your card data. Please try again and contact us if this error persists.'), 'error');
    }
  }
  $form_state['redirect'] = 'user/' . $card->uid . '/cards';
}

/**
 * Afterbuild for the billing form.
 */
function fundraiser_update_billing_form_after_build($form, &$form_state) {
  return fundraiser_donation_form_after_build($form, $form_state);
}

/**
 * Form validation handler for billing address update form.
 */
function fundraiser_update_billing_form_validate($form, &$form_state) {
  $submission_fields = $form_state['values'];
  $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields);

  if (form_get_errors() || $errors) {
    drupal_set_message(t('Unable to update credit card information.'));
  }
}

/**
 * Form submit handler for billing address update form.
 */
function fundraiser_update_billing_form_submit($form, &$form_state) {
  $donation = $form['#donation'];
  $submission_fields = $form_state['values'];
  $donation->donation = array_merge($donation->donation, $submission_fields);
  $donation->update_billing = TRUE;
  $donation->update_payment = TRUE;
  fundraiser_donation_update($donation);
}
