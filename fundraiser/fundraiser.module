<?php

/**
 * @file
 * Provides behaviors to handle donation form creation and donation submission.
 */

// Include theme related functions.
// @todo Merge this back in.
require_once 'fundraiser.theme.inc';

/**
 * Implements hook_permission().
 */
function fundraiser_permission() {
  return array(
    'administer fundraiser' => array(
      'title' => t('Administer fundraiser'),
      'description' => t('Perform administration tasks for fundraiser.'),
    ),
    'refund donations' => array(
      'title' => t('Refund donations'),
      'description' => t('Refund donations for fundraiser.'),
    ),
    'create donation form' => array(
      'title' => t('Create donation form'),
      'description' => t('Create donation forms.'),
    ),
    'edit own donation form' => array(
      'title' => t('Edit own donation form'),
      'description' => t('Edit own donation forms.'),
    ),
    'edit any donation form' => array(
      'title' => t('Edit any donation form'),
      'description' => t('Edit any donation forms.'),
    ),
    'delete own donation form' => array(
      'title' => t('Delete own donation form'),
      'description' => t('Delete own donation forms.'),
    ),
    'delete any donation form' => array(
      'title' => t('Delete any donation form'),
      'description' => t('Delete any donation forms.'),
    ),
    'clone donation form' => array(
      'title' => t('Clone donation form'),
      'description' => t('Clone donation forms.'),
    ),
    'use gateway switcher' => array(
      'title' => t('Use the bulk gateway switcher'),
      'description' => t('Allows users to change donation form gateway configurations in bulk.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function fundraiser_menu() {
  // Admin paths.
  $items['admin/config/system/fundraiser'] = array(
    'title' => 'Fundraiser',
    'description' => 'Configurations for the Fundraiser system.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_admin_settings'),
    'access arguments' => array('administer fundraiser'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'fundraiser.admin.inc',
  );
  $items['admin/config/system/fundraiser/settings'] = array(
    'title' => 'Fundraiser',
    'description' => 'Configurations for the Fundraiser system.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_admin_settings'),
    'access arguments' => array('administer fundraiser'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'fundraiser.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_boost_is_cacheable().
 *
 * If Boost is enabled, make sure donation form nodes aren't cached.
 */
function fundraiser_boost_is_cacheable($parts) {
  $args = $parts['args'];
  if ($args[0] == 'node' && isset($args[1]) && is_numeric($args[1]) && !isset($args[2])) {
    // It's a node, but is it a donation node?
    $node = node_load($args[1]);
    if (fundraiser_is_donation_type($node)) {
      // Don't cache donation forms
      $parts['is_cacheable'] = FALSE;
    }
  }
  return $parts;
}

/**
 * Implements hook_token_info().
 */
function fundraiser_token_info() {
  // Add a donation type.
  $info['types']['donation'] = array(
    'name' => t('Current donation'),
    'description' => t('Tokens related to specific donations.'),
    'needs-data' => 'donation',
  );
  // Donation tokens by field.
  $info['tokens']['donation'] = _fundraiser_donation_token_info();
  // Donation basic data.
  $info['tokens']['donation']['did'] = array(
    'name' => t('Donation ID'),
    'description' => t('The unique ID of the donation.'),
  );
  $info['tokens']['donation']['node'] = array(
    'name' => t('Fundraiser Node'),
    'description' => t('The fundraiser node the donation came from.'),
    'type' => 'node',
  );
  $info['tokens']['donation']['user'] = array(
    'name' => t('Donating User'),
    'description' => t('The user account the donation came from.'),
    'type' => 'user',
  );
  // Modify given for payment fields.
  if (isset($info['tokens']['donation']['payment_fields'])) {
    // Payment token fields are generated by the gateway and are not predictable.
    unset($info['tokens']['donation']['payment_fields']);
    unset($info['tokens']['donation']['other_amount']);
    // So we add the ones we know we want to support, they will be enpty if
    // the donation didn't set them.
    $info['tokens']['donation']['card_number'] = array(
      'name' => t('Last 4 of card number.'),
      'description' => t('The last four digits of the card number, ' .
        'available only if the user selected a credit card method supporting this token.'),
    );
    $info['tokens']['donation']['card_expiration_month'] = array(
      'name' => t('Card expiration month'),
      'description' => t('The expiration month of the card, ' .
        'available only if the user selected a credit card method supporting this token.'),
    );
    $info['tokens']['donation']['card_expiration_year'] = array(
      'name' => t('Card expiration year'),
      'description' => t('The expiration year of the card, ' .
        'available only if the user selected a credit card method supporting this token.'),
    );
    $info['tokens']['donation']['card_type'] = array(
      'name' => t('Card type'),
      'description' => t('The type of credit card, ' .
        'available only if the user selected a credit card method supporting this token.'),
    );
  }

  // The currency is a special case.
  $info['tokens']['donation']['currency:code'] = array(
    'name' => t('Currency code'),
    'description' => t('The currency code. For example, "USD".'),
  );
  $info['tokens']['donation']['currency:name'] = array(
    'name' => t('Currency name'),
    'description' => t('The full currency name. For example, "United States Dollar".'),
  );
  $info['tokens']['donation']['currency:symbol'] = array(
    'name' => t('Currency symbol'),
    'description' => t('The currency symbol. For example, "$".'),
  );

  return $info;
}

/**
 * Recursive to build up form info for tokens.
 */
function _fundraiser_donation_token_info($fields = NULL, $tokens = array()) {
  if ($fields == NULL) {
    $fields = _fundraiser_field_info();
  }
  $children = element_children($fields);
  foreach ($children as $child) {
    // TODO Adjust this tokening to account for the new changed in donation fields.
    $disallowed = array('card_cvv', 'currency');
    if (isset($fields[$child]['#type']) && $fields[$child]['#type'] != 'fieldset' && !in_array($child, $disallowed)) {
      // Add children.
      $tokens[$child] = array(
        'name' => isset($fields[$child]['#title']) ? $fields[$child]['#title'] : $child,
        'description' => t('Donation field information.'),
      );
    }
    else {
      // Recurse for more.
      $tokens = _fundraiser_donation_token_info($fields[$child], $tokens);
    }
  }
  return $tokens;
}

/**
 * Implements hook_tokens().
 */
function fundraiser_tokens($type, $tokens, $data = array(), $options = array()) {
  $replacements = array();
  $sanitize = !empty($options['sanitize']);

  if ($type == 'donation' && !empty($data['donation'])) {

    $donation = $data['donation'];
    // All set fields.
    $data = is_array($donation->donation) ? $donation->donation : array();
    // User and etc types.
    $data['did'] = isset($donation->did) ? $donation->did : '';
    $data['node'] = isset($donation->node->nid) ? $donation->node->nid : '';
    $data['user'] = isset($donation->user->uid) ? $donation->user->uid : '';
    // Specific changes for payment fields.
    if (isset($data['payment_fields'])) {
      // Payment token fields are generated by the gateway and are not predictable across all nodes.
      // Since the nodes are individually configurable. We wouldn't be able to predict all element.
      unset($data['payment_fields']);
      $data['card_number'] = isset($donation->donation['payment_fields']['credit']['card_number']) ?
        substr($donation->donation['payment_fields']['credit']['card_number'], -4) : '';
      $data['card_expiration_month'] = isset($donation->donation['payment_fields']['credit']['card_expiration_month']) ?
        $donation->donation['payment_fields']['credit']['card_expiration_month'] : '';
      $data['card_expiration_year'] = isset($donation->donation['payment_fields']['credit']['card_expiration_year']) ?
        $donation->donation['payment_fields']['credit']['card_expiration_year'] : '';
      $data['card_type'] = isset($donation->donation['payment_fields']['credit']['card_type']) ?
        $donation->donation['payment_fields']['credit']['card_type'] : '';
    }

    if (is_array($data['currency'])) {
      foreach ($data['currency'] as $key => $value) {
        $data['currency:' . $key] = $value;
      }
    }

    // Replace the given tokens.
    foreach ($tokens as $key => $token) {
      if (isset($data[$key])) {
        $replacements[$token] = $sanitize ? check_plain($data[$key]) : $data[$key];
      }
    }

    // If we have a donation object add the node and user tokens as well.
    if (!empty($donation)) {
      if ($node_tokens = token_find_with_prefix($tokens, 'node')) {
        $replacements += token_generate('node', $node_tokens, array('node' => $donation->node), $options);
      }
      if ($user_tokens = token_find_with_prefix($tokens, 'user')) {
        $replacements += token_generate('user', $user_tokens, array('user' => $donation->user), $options);
      }
    }

    // Make more user-friendly label for payment method token.
    if (isset($data['payment_method']) && isset($donation->node)) {
      // Get node gateways and loop through them.
      foreach ($donation->node->gateways as $gateway) {
        // If donation's payment method matches gateway, use label for
        // gateway token.
        if (array_key_exists('method', $gateway) && array_key_exists('label', $gateway) && $data['payment_method'] == $gateway['method'] && $gateway['label']) {
          $replacements['[donation:payment_method]'] = $gateway['label'];
        }
      }
    }

  }

  return $replacements;
}

/**
 * Implements hook_clone_access_alter() from Node clone module.
 */
function fundraiser_clone_access_alter(&$access, $node) {
  if (fundraiser_is_donation_type($node->type)) {
    // Remove the access if the user isn't allowed to clone the donation form.
    if (!user_access('clone donation form')) {
      $access = 0;
    }
    if (user_access('clone donation form')) {
      $access = 1;
    }
  }
}

/**
 * Implements hook_clone_node_alter() from Node clone module.
 *
 * From: http://drupal.org/node/1256478
 */
function fundraiser_clone_node_alter(&$node, $context) {
  // Set the internal name.
  if (fundraiser_is_donation_type($context['original_node']->type)) {
    if (!empty($context['original_node']->field_fundraiser_internal_name[$context['original_node']->language][0]['value'])) {
      $internal_name = t('Clone of @internal', array('@internal' => $context['original_node']->field_fundraiser_internal_name[$context['original_node']->language][0]['value']));
      $node->field_fundraiser_internal_name  = array($node->language => array(0 => array('value' => $internal_name)));
    }
  }
  // The additional load in hook_node_load already will have brought in additional node data.
  // The additional saves in hook_node_insert / hook_node_update will save the additional node data.
}

/**
 * Implements hook_views_api(). From Views module.
 */
function fundraiser_views_api() {
  return array(
    'api' => 2,
  );
}

/**
 * Implementshook_node_access().
 */
function fundraiser_node_access($node, $op, $account) {
  // Without an idea who the owner is or type is we can't assess access. So don't rock the boat.
  if ( isset($node->type) && isset($node->uid) && fundraiser_is_donation_type($node->type)) {
    $is_author = $account->uid == $node->uid;
    switch ($op) {
      case 'create':
        return user_access('create donation form', $account) ? NODE_ACCESS_ALLOW : NODE_ACCESS_IGNORE;
      case 'update':
        return ((user_access('edit own donation form', $account) && $is_author) ||
          user_access('edit any donation form', $account)) ? NODE_ACCESS_ALLOW : NODE_ACCESS_IGNORE;
      case 'delete':
        return ((user_access('delete own donation form', $account) && $is_author) ||
          user_access('delete any donation form', $account)) ? NODE_ACCESS_ALLOW : NODE_ACCESS_IGNORE;
    }
  }
}

/**
 * Implements hook_form_alter().
 *
 * Alter content type settings to add "Enable fundraiser?" checkbox.
 */
function fundraiser_form_node_type_form_alter(&$form, &$form_state) {
  if (isset($form['type'])) {
    $form['fundraiser_type'] = array(
      '#type' => 'fieldset',
      '#title' => t('Fundraiser settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
    );
    $form['fundraiser_type']['fundraiser'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable fundraiser?'),
      '#default_value' => variable_get('fundraiser_' . $form['#node_type']->type, FALSE),
      '#description' => t('Enable this checkbox if this content type should provide a donation field.'),
    );
  }
}

/**
 * Implements hook_node_type_insert
 */
function fundraiser_node_type_insert($type) {
  if (fundraiser_is_donation_type($type->type)) {
    module_load_include('inc', 'fundraiser', 'includes/fundraiser.fields');
    _fundraiser_add_default_fields($type->type);
  }
}

/**
 * Implements hook_node_type_update
 */
function fundraiser_node_type_update($type) {
  if (fundraiser_is_donation_type($type->type)) {
    module_load_include('inc', 'fundraiser', 'includes/fundraiser.fields');
    _fundraiser_add_default_fields($type->type);
  }
}

/**
 * Node API Functions. Handle for each case of node operation.
 */

/**
 * Implements hook_node_delete().
 */
function fundraiser_node_delete($node) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($node->type)) {
    _fundraiser_delete_fundraiser($node->nid);
    _fundraiser_delete_tracking($node->nid);
  }
}

/**
 * Implements hook_node_insert().
 */
function fundraiser_node_insert($node) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($node->type)) {
    _fundraiser_create_fundraiser($node);
  }
}

/**
 * Implements hook_node_load().
 */
function fundraiser_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    // If this isn't a fundraiser type, ignore it.
    if (fundraiser_is_donation_type($node->type)) {
      // Get the fundraiser information.
      // This also loads additional data presented from other modules to FR.
      // AKA fundraiser_webform and fundraiser_profile data.
      $fundraiser = _fundraiser_get_fundraiser_by_nid($node->nid);
      // Merge data from fundraiser with node.
      $fundraiser = (array) $fundraiser;
      foreach ($fundraiser as $key => $value) {
        $nodes[$node->nid]->$key = $value;
      }
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function fundraiser_node_presave($node) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($node->type) && isset($node->amount_wrapper)) {
    // Check the submission to remove the donation amounts marked and (optionally) set the default.
    $node->default_amount = NULL;
    foreach ($node->amount_wrapper['donation_amounts'] as $index => $donation_amount) {
      // If the remove marker is set.
      if (isset($donation_amount['remove']) && $donation_amount['remove'] == 1) {
        unset($node->amount_wrapper['donation_amounts'][$index]);
      }
      unset($node->amount_wrapper['donation_amounts'][$index]['remove']);
      // Or if the values aren't set.
      if (empty($donation_amount['label']) && empty($donation_amount['amount'])) {
        unset($node->amount_wrapper['donation_amounts'][$index]);
      }
      unset($node->amount_wrapper['donation_amounts'][$index]['remove']);
      // If the default amount box is checked.
      if (!empty($donation_amount['default_amount'])) {
        $node->default_amount = $donation_amount['amount'];
      }
    }
    // Set the donation amounts where we expect them to be for processing.
    // These are buried under amount_wrapper because we set 'TREE' on that in the form.
    $node->donation_amounts = $node->amount_wrapper['donation_amounts'];
    $node->show_other_amount = $node->amount_wrapper['show_other_amount'];
    $node->minimum_donation_amount = is_numeric($node->amount_wrapper['minimum_donation_amount']) ?
      $node->amount_wrapper['minimum_donation_amount'] : variable_get('fundraiser_default_minimum', 10.00);
    unset($node->amount_wrapper);
  }
}

/**
 * Implements hook_node_update().
 */
function fundraiser_node_update($node) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($node->type)) {
    _fundraiser_update_fundraiser($node);
  }
}

/**
 * Implements hook_node_validate().
 */
function fundraiser_node_validate($node, $form, &$form_state) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($node->type)) {
    // If each given amount if numeric, we're ok.
    // Since the form is set to TREE at this point, we need to account for that in our addressing path.
    foreach ($node->amount_wrapper['donation_amounts'] as $index => $donation_amount) {
      if (isset($donation_amount['amount']) && !empty($donation_amount['amount'])) {
        if (!is_numeric($donation_amount['amount'])) {
          form_set_error('donation_amounts', t('Ask amounts must be numeric, you entered "@s".', array("@s" => $donation_amount['amount'])));
          break;
        }
      }
    }
  }
}

/**
 * Implements hook_node_view().
 */
function fundraiser_node_view($node, $view_mode, $langcode) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($node->type)) {
    // Track the pageview.
    if ($view_mode == 'full') {
      _fundraiser_update_tracking_value($node->nid, 'pageviews');
    }

    // Messaging checks. We want to hide warning/admin messages if user can't
    // edit the current node.
    if ($view_mode == 'full' && node_access("update", $node)) {
      // Set a reminder to turn off development mode on the page view.
      if (variable_get('fundraiser_development_mode', 0)) {
        $link = l('turn off', 'admin/config/system/fundraiser');
        drupal_set_message(t('Fundraiser is currently running in development mode. Remember to ' .
          '!link this feature on production websites.',
           array('!link' => $link)), 'warning');
      }
      // Throw a warning if no confirmation email has been configured.
      if (module_exists('email_wrappers') && !email_wrappers_load_settings($node->nid, NULL)) {
        drupal_set_message(t('No confirmation emails have been configured for this donation form.' .
          ' Users who submit a donation will not receive an email confirming their donation.'), 'warning');
      }

      // Allow other modules to throw up warnings on the donation form
      // when it is not configured correctly.
      $messages = module_invoke_all("fundraiser_donation_form_config_check", $node);

      if (!empty($messages)) {
        foreach($messages as $message) {
          drupal_set_message($message, 'error');
        }
      }
    }

  }
  // NOTE: Glue display modules are responsible for using hook_node_view to display themselves with the node.
  // Some, like webform based glue modules, already do the work of displaying on a form themselves.
}

/**
 * Fundraiser form modification functions.
 */

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node forms.
 */
function fundraiser_form_node_form_alter(&$form, &$form_state, $form_id) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($form['#node']->type)) {
    _fundraiser_donation_settings_form($form, $form_state);
    // Other modules that need to add to the settings form should also implement
    // hook_form_BASE_FORM_ID_alter, or any of the other form alter hooks.
  }
}

/**
 * Fundraiser form. This form collects the information to create donation forms per donation node types.
 * This is added to the node display via form_alter when editting nodes of the correct type.
 *
 * It ultimately populates the fundraiser table from which donation forms are created :
 * nid, gateway, receipt_email_from, receipt_email_address, receipt_email_subject, receipt_email_message,
 * donation_amounts, show_other_amount, minimum_donation_amount, confirmation_page_title,
 * confirmation_page_body, confirmation_page_format, redirect_url.
 */
function _fundraiser_donation_settings_form(&$form, &$form_state) {
  // Load the node up from form data so we have everything.
  if (empty($node) && isset($form['#node'])) {
    $node = $form['#node'];
  }
  // Check if this is being called on an enabled node type.
  if (!fundraiser_is_donation_type($node->type)) {
    return;
  }

  // Payment methods.
  $form['payment_methods'] = array(
    '#type' => 'fieldset',
    '#title' => t("Payment methods"),
    '#weight' => -4.95,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
  );
  // Get avaiable gateways and provide an interface on the fundraiser settings to edit the payment_method fields later.
  $gateway_options = array();
  $gateways = _fundraiser_gateway_info();
  if (empty($gateways)) {
    $form['payment_methods']['gateways'] = array(
      '#markup' => '<div>' . t('There are no gateways configured. Please create some gateways in the store configuration.') . '</div>',
    );
  }
  else {
    $fieldset = array(
      '#type' => 'fieldset',
      '#title' => t('Payment methods'),
      '#description' => t('Enable donation form payment methods and their corresponding gateways.'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#tree' => TRUE,
      '#theme' => 'fundraiser_form_payment_methods',
    );
    $configuration = !empty($node->gateways) ? $node->gateways : variable_get('fundraiser_payment_method_config_defaults', array());
    $form['payment_methods']['gateways'] = _fundraiser_form_payment_method_config_fieldset($gateways, $configuration, $fieldset, 'gateways');
    // add a validate callback.
    $form['#validate'][] = '_fundraiser_form_payment_method_validate';
  }

  // Fundraiser Settings (i.e., ask amounts).
  $form['fundraiser_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fundraiser settings'),
    '#weight' => -4.96,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
  );

  // Make changes to the currency settings field.
  if (!empty($form['field_fundraiser_currency'])) {
    $currency_field = &$form['field_fundraiser_currency'][ $form['field_fundraiser_currency']['#language'] ];
    // Remove the none option.
    unset($currency_field['#options']['_none']);

    // If there is only one value left hide the field and set the value to the default currency.
    if (count($currency_field['#options']) === 1) {
      $currency_field['#type'] = 'value';
      $currency_field['#default_value'] = commerce_default_currency();
      $currency_field['#required'] = FALSE;
    }
    // Else, move it into the fundraiser group.
    else {
      $form['fundraiser_settings']['currency'] = array(
        '#type' => 'fieldset',
        '#title' => t('Currency'),
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
      );

      $currency_field['#title_display'] = 'none';
      $form['fundraiser_settings']['currency']['field_fundraiser_currency'] = $form['field_fundraiser_currency'];
      unset($form['field_fundraiser_currency']);
    }
  }

  // Add specific CSS settings for IE support. Pending http://drupal.org/node/1015798 being resolved,
  // and UC Store accounting for that update. (Should be block not inline-block).
  $style = '.vertical-tabs fieldset fieldset legend {display: block;}';
  drupal_add_css($style, 'inline');
  $form['fundraiser_settings']['amount_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('Ask amounts'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#prefix' => '<div class="clear-block" id="ask-wrapper">',
    '#suffix' => '</div>',
    '#tree' => TRUE, // This is important, this allows the deltas below to function as part of the array.
  );
  $form['fundraiser_settings']['amount_wrapper']['donation_amounts'] = array(
    '#prefix' => '<div id="ask-amounts">',
    '#suffix' => '</div>',
    '#theme' => 'fundraiser_ask_amounts',
    '#tree' => TRUE,
  );

  // AJAXy bits.
  $donation_amounts = array();
  // The last submission takes precedence.
  if (isset($form_state['values']['amount_wrapper']['donation_amounts'])) {
    foreach ($form_state['values']['amount_wrapper']['donation_amounts'] as $index => $values) {
      $donation_amounts[$values['weight']] = array($values['amount'], $values['label']);
    }
    ksort($donation_amounts);
  }
  else {
    // If the form hasn't been submitted, then grab the defaults from the node or empty.
    // Donation amounts were loaded on node_load, and exploded at that time. If they exist, they're on the node.
    $donation_amounts = isset($node->donation_amounts) ? $node->donation_amounts : array();
    // If not there, then grab some defaults.
    if (count($donation_amounts) == 0) {
      $default_amounts = variable_get('fundraiser_default_amounts', '10|$10' . "\n" . '20|$20' . "\n" . '50|$50' . "\n" . '100|$100');
      $default_amounts = explode("\n", $default_amounts);
      $default_amounts = array_unique($default_amounts);
      $exploded_amounts = array();
      foreach ($default_amounts as $default_amount) {
        $these_amounts = explode('|', $default_amount);
        if (count($these_amounts) == 1) {
          $these_amounts[1] = '$' . $these_amounts[0];
        }
        $exploded_amounts[] = $these_amounts;
      }
      $donation_amounts = $exploded_amounts;
    }
  }
  // Default provide one spare blank for users to fill in.
  // If the button clicked was to add another, this line will add an extra field as expected on reload.
  $donation_amounts[] = array('', '');
  // Generate a form set for each existing amount. (To be themed into table format.)
  $index = 0;
  foreach ($donation_amounts as $weight => $donation_amount) {
    // Filter out other|Other combinations. We don't want to display those in this form.
    // And if we did, the value would fail validation (not a number).
    // There is probably a better way to track this, but for now this'll do.
    if (count($donation_amount) == 2 && $donation_amount[0] != 'other') {
      $form['fundraiser_settings']['amount_wrapper']['donation_amounts'][$index] = _fundraiser_ask_form($donation_amount, $index, $node, $weight);
    }
    ++$index;
  }

  // AJAX fix: reorder donation amounts in $form_state['input'] by weight.
  // Corrects the display order of donation amounts when an ajax event is
  // triggered.
  if (isset($form_state['input']['amount_wrapper']['donation_amounts'])) {
    $old_donation_amounts = $form_state['input']['amount_wrapper']['donation_amounts'];
    unset($form_state['input']['amount_wrapper']['donation_amounts']);
    foreach ($old_donation_amounts as $donation_amount) {
      $new_donation_amounts[$donation_amount['weight']] = $donation_amount;
    }
    ksort($new_donation_amounts);
    foreach ($new_donation_amounts as $donation_amount) {
      $form_state['input']['amount_wrapper']['donation_amounts'][] = $donation_amount;
    }
  }

  $form['fundraiser_settings']['amount_wrapper']['amount_more'] = array(
    '#type' => 'button',
    '#submit' => array(),
    '#value' => t('Add another'),
    '#description' => t('Click here to add more choices.'),
    '#ajax' => array(
      'callback' => '_fundraiser_donation_settings_form_amounts',
      'wrapper' => 'ask-amounts',
      'method' => 'replace',
      'effect' => 'fade',
    ),
  );

  // Additional fundraiser settings.
  $form['fundraiser_settings']['amount_wrapper']['show_other_amount'] = array(
    '#type' => 'checkbox',
    '#title' => t('Show other amount option'),
    '#description' => t('Use this option if you want to provide an "Other Amount" field in conjunction with the list ' .
      'of Donation Amounts.'),
    '#default_value' => isset($node->show_other_amount) ? $node->show_other_amount : variable_get('fundraiser_default_other', TRUE),
  );
  $form['fundraiser_settings']['amount_wrapper']['minimum_donation_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum donation amount'),
    '#description' => t('The minimum acceptable donation amount.'),
    '#default_value' => isset($node->minimum_donation_amount) ?
      number_format($node->minimum_donation_amount, 2) : variable_get('fundraiser_default_minimum', 10.00),
  );

  $form['#validate'][] = '_fundraiser_form_amounts_validate';
  // TODO this should probably go on a different table, not here.
  /* Hidden fields. These are set later on other forms, included here to prevent overwrite during saves. */
  $form['receipt_email_from'] = array(
    '#type' => 'value',
    '#value' => isset($node->receipt_email_from) ? $node->receipt_email_from : '',
  );
  $form['receipt_email_address'] = array(
    '#type' => 'value',
    '#value' => isset($node->receipt_email_address) ? $node->receipt_email_address : '',
  );
  $form['receipt_email_subject'] = array(
    '#type' => 'value',
    '#value' => isset($node->receipt_email_subject) ? $node->receipt_email_subject : '',
  );
  $form['receipt_email_message'] = array(
    '#type' => 'value',
    '#value' => isset($node->receipt_email_message) ? $node->receipt_email_message : '',
  );

  // Share the "Display" fieldset with related modules (e.g., Form Layouts).
  if (empty($form['springboard_display'])) {
    $form['springboard_display'] = array(
      '#type' => 'fieldset',
      '#title' => t('Display settings'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#group' => 'additional_settings',
    );
  }

  // Add CSS and JS + hide "Display settings" if it is empty during after build:
  $form['#after_build'][] = '_fundraiser_node_form_after_build';
}

/**
 * Afterbuild for node type form, to avoid AJAX losing js, css.
 *
 * Also, this hides the "Display settings" fieldset Fundraiser provides
 * if another module has not altered the form to insert something into it.
 */
function _fundraiser_node_form_after_build($form, &$form_state) {
  // Hide "Display settings" fieldset if empty:
  $display_settings_is_empty = TRUE;
  foreach ($form['springboard_display'] as $form_key => $value) {
    if (substr($form_key, 0, 1) != '#') {
      $display_settings_is_empty = FALSE;
      break;
    }
  }
  if ($display_settings_is_empty) {
    $form['springboard_display']['#description'] = t('No display settings are enabled at this time.');
  }

  // Add no-settings note if Fundraiser Settings has been emptied by alter
  // hooks.
  $fundraiser_settings_is_empty = TRUE;
  foreach (element_children($form['fundraiser_settings']) as $key) {
    if (!isset($form['fundraiser_settings'][$key]['#access']) || $form['fundraiser_settings'][$key]['#access']) {
      $fundraiser_settings_is_empty = FALSE;
      break;
    }
  }

  if ($fundraiser_settings_is_empty) {
    $form['fundraiser_settings']['#description'] = t("There are no Fundraiser settings to display.");
  }

  // Add additional js and css for this form.
  drupal_add_css(drupal_get_path('module', 'fundraiser') . '/css/fundraiser.css');
  drupal_add_js(drupal_get_path('module', 'fundraiser') . '/js/fundraiser.js');
  return $form;
}

/**
 * Creates the options for the payment method configuration form
 *
 * @param $gateways Array
 *    Array of gateways for this site
 * @param $configuration Array
 *    An array of values usually from the field configuration
 * @param $fieldset Array
 *    Formapi fieldset
 * @param $name String
 *    Name of the fieldset
 *
 * @return Array
 *    An array of fields to display on a payment method configuration form
 */
function _fundraiser_form_payment_method_config_fieldset($gateways, $configuration, $fieldset, $name) {
  // Create an array of gateways by the type of available payment methods
  foreach ($gateways as $gateway) {
    $types = isset($gateway['payment_method']) ? $gateway['payment_method'] : array();
    foreach ($types as $type) {
      $all_payment_methods[$type][] = $gateway;
    }
  }

  // Sort all payment methods by the configured weight of the fields
  foreach (array_keys($all_payment_methods) as $method_key) {
    $all_payment_methods[$method_key]['weight'] = !empty($configuration[$method_key]['weight']) ? $configuration[$method_key]['weight'] : 0;
  }
  uasort($all_payment_methods, '_fundraiser_payment_method_weight_compare');
  $method_count = count($all_payment_methods);
  // Loop through each method, comparing to those set on this node.
  foreach ($all_payment_methods as $method_key => $method) {
    // Remove the weight value
    unset($method['weight']);
    $field_method_settings = isset($configuration[$method_key]) ? $configuration[$method_key] : array();
    // Build the #options array for the payment processors supporting this payment method.
    $processor_options = array();
    foreach (element_children($method) as $key) {
      $processor_options[$method[$key]['id']] = $method[$key]['title'];
    }
    $fieldset[$method_key] = array('#tree' => TRUE);
    $fieldset[$method_key]['status'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable'),
      '#default_value' => isset($field_method_settings['status']) ? $field_method_settings['status'] : 0,
    );
    // Add auto check.
    if ($method_count == 1) {
      $fieldset[$method_key]['status']['#default_value'] = TRUE;
    }
    $fieldset[$method_key]['_status'] = array(
      '#type' => 'markup',
      '#title' => t('Method'),
      '#markup' => $method_key, // Could use a pretty name here
    );
    $fieldset[$method_key]['method'] = array(
      '#type' => 'value',
      '#value' => $method_key,
    );
    $fieldset[$method_key]['id'] = array(
      '#type' => 'select',
      '#title' => t('Payment Processor'),
      '#description' => t('The payment processor for this payment method.'),
      '#options' => $processor_options,
      '#default_value' => isset($field_method_settings['id']) ? $field_method_settings['id'] : NULL,
    );
    // Include these fields if there is more than one payment method.
    if ($method_count > 1) {
      $fieldset[$method_key]['label'] = array(
        '#type' => 'textfield',
        '#description' => t('The label displayed for this payment method. Required when multiple payment methods are enabled.'),
        '#title' => t('Label'),
        '#size' => 20,
        '#default_value' => isset($field_method_settings['label']) ? $field_method_settings['label'] : NULL,
      );
      $fieldset[$method_key]['weight'] = array(
        '#type' => 'weight',
        '#title' => t('Weight'),
        '#delta' => 25,
        '#default_value' => isset($field_method_settings['weight']) ? $field_method_settings['weight'] : 0,
        '#attributes' => array('class' => array('fundraiser-payment-methods-weight')),
      );
      $fieldset[$method_key]['_default'] = array(
        '#type' => 'radio',
        '#title' => t('Default'),
        '#default_value' => !empty($field_method_settings['default']) ? $method_key : NULL,
        '#return_value' => $method_key,
        '#parents' => array($name, '_default'),
      );
    }
  }
  return $fieldset;
}

/**
 * Validate handler for our component, also sets the default value
 */
function _fundraiser_form_payment_method_validate($form, &$form_state) {
  // Check the set payment methods.
  $values = $form_state['values']['gateways'];
  $default_method = isset($values['_default']) ? $values['_default'] : '';
  $enabled_methods = array_filter($values, '_fundraiser_payment_method_array_filter_enabled');
  unset($form_state['values']['gateways']['_default']);
  unset($enabled_methods['_default']);
  // Check that there is at least one method enabled
  if (empty($enabled_methods)) {
    form_set_error('payment_methods', t('At least one payment method must be enabled.'));
  }
  else {
    // Check that the marked payment type actually have selected gateways to match.
    foreach ($enabled_methods as $method => $enabled_method) {
      if (empty($enabled_method['id'])) {
        form_set_error('gateways][' . $method . '][id', t('All enabled payment methods must select a gateway.'));
      }
      if (count($enabled_methods) > 1 && empty($enabled_method['label'])) {
        form_set_error('gateways][' . $method . '][label', t('Please enter a label for the %method gateway.', array('%method' => $method)));
      }
    }
    // Check that a default has been set.
    if (!isset($enabled_methods[$default_method])) {
      if (count($enabled_methods) == 1) {
        $default_method = key($enabled_methods);
        $form_state['values']['gateways'][$default_method]['default'] = 1;
      }
      else {
        form_set_error('fundraiser_settings][gateways][_default', t('Default method must be one of the enabled methods.'));
      }
    }
    else {
      $form_state['values']['gateways'][$default_method]['default'] = 1;
    }
  }
}

/**
 * Validate handler for amounts configuration.
 */
function _fundraiser_form_amounts_validate($form, &$form_state) {
  // Check the ask amounts, if we have a label and we dong have an amount, throw a fit.
  // If we have neither, assume it's meant to be empty and leave it be (it will be removed).
  $amounts = $form_state['values']['amount_wrapper']['donation_amounts'];
  foreach ($amounts as $index => $amount_set) {
    if (!empty($amount_set['amount']) && empty($amount_set['label'])) {
      form_set_error('amount_wrapper][donation_amounts][' . $index . '][label',
        t('The label cannot be empty when an amount is set.'));
    }
    if (empty($amount_set['amount']) && !empty($amount_set['label'])) {
      form_set_error('amount_wrapper][donation_amounts][' . $index . '][amount',
        t('The amount cannot be empty when a label is set.'));
    }
    if (!is_numeric($amount_set['amount']) && !empty($amount_set['amount'])) {
      form_set_error('amount_wrapper][donation_amounts][' . $index . '][amount',
        t('The amount must be a number.'));
    }
  }

  // Checking the minimum amount.
  $minimum_donation_amount = $form_state['values']['amount_wrapper']['minimum_donation_amount'];
  foreach ($amounts as $amount) {
    if (empty($amount['remove']) && $amount['amount'] !='') {
      $min = (isset($min) && $amount['amount'] > $min) ? $min : $amount['amount'];
    }
  }
  // If no min ask amount is found (no ask amounts set) default to
  // the minimum donation amount. This prevents errors when all ask amounts
  // are removed from a donation form.
  $min = isset($min) ? $min : $minimum_donation_amount;
  if ($min < $minimum_donation_amount) {
    form_set_error('amount_wrapper][minimum_donation_amount', t('The minimum donation amount must not be higher than the minimum ask amount.'));
  }
  if (!empty($minimum_donation_amount) && !is_numeric($minimum_donation_amount)) {
    form_set_error('amount_wrapper][minimum_donation_amount', t('The minimum donation amount must be a numerical value.'));
  }
}

/**
 * Array_filter callback for filtering by method status.
 */
function _fundraiser_payment_method_array_filter_enabled($method_settings) {
  return !empty($method_settings['status']);
}

/**
 * Sort payment methods by weight
 */
function _fundraiser_payment_method_weight_compare($a, $b) {
  $weight = $a['weight'] - $b['weight'];
  return $weight;
}

/**
 * Generate donation ask amount fields, used by donation form
 */
function _fundraiser_ask_form($amount_values = array(), $index, $node, $weight) {
  $form['default_amount'] = array(
    '#type' => 'checkbox',
    '#default_value' => isset($node->default_amount) ? ($node->default_amount == $amount_values[0]) : FALSE,
  );
  $form['amount'] = array(
    '#type' => 'textfield',
    '#default_value' => isset($amount_values[0]) ? $amount_values[0] : '',
    '#size' => 10,
  );
  $form['label'] = array(
    '#type' => 'textfield',
    '#default_value' => isset($amount_values[1]) ? $amount_values[1] : '',
    '#size' => 30,
  );
  $form['remove'] = array(
    '#type' => 'checkbox',
    '#return_value' => 1,
    '#default_value' => 0,
  );
  $form['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Weight'),
    '#default_value' => $weight,
    '#delta' => 10,
    '#title_display' => 'invisible',
  );
  return $form;
}

/**
 * Callback handler for the donation ask amount form #ajax.
 */
function _fundraiser_donation_settings_form_amounts(&$form, &$form_state) {
  return $form['fundraiser_settings']['amount_wrapper']['donation_amounts'];
}

/**
 * Donation field definitions.
 */

/**
 * Provides a list of fields to be defined by the display module.
 * Requests additional field information from other modules that need to define them.
 */
function _fundraiser_field_info($refresh = FALSE) {
  static $fields;
  // Cache fundraiser content types during page execution.
  if (empty($fields) || $refresh == TRUE) {
    // Request additional fields from other modules.
    $fields = module_invoke_all('fundraiser_field_info');
    // Allow for others to modify as needed.
    drupal_alter('fundraiser_field_info', $fields);
  }
  // And return.
  return $fields;
}

/**
 * Implements hook_fundraiser_field_info(), providing the core set of fields that fundraiser must have.
 */
function fundraiser_fundraiser_field_info() {
  // Donation amounts are handled in a special case.
  $fields['donation'] = array(
    '#title' => t('Donation'),
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['donation']['amount'] = array(
    '#title' => t('Amount'),
    '#type' => 'textfield',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'width' => 10,
      'field_prefix' => '$',
    ),
    '#allow_update' => 1,
    '#reset_value' => 1,
    '#create_callback' => '_fundraiser_amount_field_create',
  );
  $fields['donation']['other_amount'] = array(
    '#title' => t('Other'),
    '#type' => 'textfield',
    '#required' => 0,
    '#extra' => array(
      'description' => t('Minimum payment $ @min.', array('@min' => number_format(variable_get('fundraiser_default_minimum', 10.00), 2))),
      'width' => 10,
      'field_prefix' => '$',
    ),
    '#allow_update' => 1,
    '#create_callback' => '_fundraiser_other_amount_field_create',
    '#validate_callback' => '_fundraiser_other_amount_field_validate',
    '#display_callback' => '_fundraiser_other_amount_field_display',
  );

  $fields['donation']['currency'] = array(
    '#title' => 'Currency',
    '#type' => 'hidden',
    '#value' => '',
    '#required' => 1,
    '#allow_update' => 1,
    '#reset_value' => 1,
    '#create_callback' => '_fundraiser_currency_field_create',
    '#display_callback' => '_fundraiser_currency_field_display',
  );

  $fields['donor_information'] = array(
    '#title' => t('Your Information'),
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['donor_information']['first_name'] = array(
    '#title' => t('First Name'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['donor_information']['last_name'] = array(
    '#title' => t('Last Name'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['donor_information']['mail'] = array(
    '#title' => t('E-mail address'),
    '#type' => 'email',
    '#required' => 1,
    '#validate_callback' => '_fundraiser_email_field_validate',
  );
  $fields['billing_information'] = array(
    '#title' => t('Billing Information'),
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['billing_information']['address'] = array(
    '#title' => t('Address'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['address_line_2'] = array(
    '#title' => t('Address Line 2'),
    '#type' => 'textfield',
    '#required' => 0,
  );
  $fields['billing_information']['city'] = array(
    '#title' => t('City'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['country'] = array(
    '#title' => t('Country'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['state'] = array(
    '#title' => t('State/Province'),
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['zip'] = array(
    '#title' => t('ZIP/Postal Code'),
    '#type' => 'textfield',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'width' => 10,
      'maxlength' => 10,
    ),
  );
  $fields['payment_information'] = array(
    '#title' => t('Payment Information'),
    '#type' => 'fieldset',
    '#required' => 0,
  );
  /**
   * These two fields are intended to hold the payment method information
   * And the array of user entered data for the payment method.
   * They replace previous implementations relying on CC fields.
   */
  $fields['payment_information']['payment_method'] = array(
    '#title' => t('Payment Method'),
    '#type' => 'payment_method',
    '#required' => 1,
    '#allow_update' => 1,
    '#create_callback' => '_fundraiser_payment_method_field_create',
  );
  $fields['payment_information']['payment_fields'] = array(
    '#title' => t('Payment Details'),
    '#type' => 'payment_fields',
    '#required' => 0,
    /**
     * Instead of returning the value of this field it's treated more like a variable fieldset.
     * The values returned are dependant on the value returned by payment method by gateway.
     * In the format:
     * 'payment_fields' => array(
     *   'credit' => array(
     *     'card_number' => '',
     *     'card_expiration_month' => '',
     *     'card_expiration_year' => '',
     *     'card_cvv' => '',
     *   )
     *   'paypal' => array(
     *     'paypal_email' => '',
     *   )
     *   'debit' => array(
     *     'debit_routing' => '',
     *     'debit_account' => '',
     *   )
     * );
     */
  );
  return $fields;
}

/**
 * Field callback, called at runtime to update the field with fundraiser specific settings during creation.
 */
function _fundraiser_amount_field_create($fundraiser, $field) {
  $currency = fundraiser_get_currency_from_node($fundraiser);
  $currency_symbol = check_plain($currency['symbol']);

  // If donation amounts don't exist, use amount as is.
  if (empty($fundraiser->donation_amounts) || !is_array($fundraiser->donation_amounts)) {
    // Show the minimum amount when only displaying an amount text box.
    $field['#extra']['description'] = 'Minimum payment ' . $currency_symbol . number_format($fundraiser->minimum_donation_amount, 2) . '.';
    return $field;
  }
  // Else we want a select field.
  if (is_array($fundraiser->donation_amounts)) {
    // Since we have an array of donation_amounts, set the field data to match.
    $keys = array_keys($fundraiser->donation_amounts);
    // Construct a set of options based on the configured amounts.
    $formatted_amounts = '';
    foreach ($fundraiser->donation_amounts as $value => $label) {
      if (empty($label)) {
        $label = $currency_symbol . $value;
      }
      $formatted_amounts[] = implode('|', array($value, $label));
    }
    if ($fundraiser->show_other_amount && count($fundraiser->donation_amounts)) {
      // Strip out other other|Other combiantions and make sure this is at the end.
      $formatted_amounts = array_diff($formatted_amounts, array('other|Other'));
      $formatted_amounts[] = 'other|Other';
    }
    $formatted_amounts = implode("\n", $formatted_amounts);
    $field['#title'] = t('Please select your tax-deductible gift amount below');
    $field['#type'] = 'select';
    $field['#extra'] = array(
      'description' => '',
      'items' => $formatted_amounts,
      'multiple' => 0,
    );
    $default = $keys[0];
    if (empty($fundraiser->default_amount)) {
      $default = '';
    }
    else if (in_array($fundraiser->default_amount, $keys)) {
      // Default is one of the defined ask amounts. Use it, but make sure the formatting matches the ask amount exactly.
      foreach ($keys as $ask_amount) {
        if ($ask_amount == $fundraiser->default_amount) {
          $default = $ask_amount;
          break;
        }
      }
    }

    // Extra settings may get clobbered in fundraiser_webform. if we don't flag them.
    // See "extra config" comment under _fundraiser_webform_update_component().
    if (!empty($field['#extra'])) {
      $field['#node_extra_settings'] = $field['#extra'];
    }

    $field['#value'] = $default;

  }

  return $field;
}

/**
 * Field callback, called at runtime to update the field with fundraiser specific settings during creation.
 */
function _fundraiser_other_amount_field_create($fundraiser, $field) {
  // If donation amounts don't exist, drop the amount_other field, and use amount as is.
  if (empty($fundraiser->donation_amounts) || !is_array($fundraiser->donation_amounts)) {
    return FALSE; // FALSE as opposed to empty, means we delete this field if it exists.
  }
  // If the show other options is disallowed, unset it.
  if (!$fundraiser->show_other_amount) {
    return FALSE; // FALSE as opposed to empty, means we delete this field if it exists.
  }
  // Update the min with fundraiser's min.
  $field['#extra']['description'] = $field['#node_extra_settings']['description'] =
    'Minimum payment [currency-symbol]' . number_format($fundraiser->minimum_donation_amount, 2) . '.';

  // Return the field to be created.
  return $field;
}

/**
 * Fundraiser field display callback for the other amount field.
 */
function _fundraiser_other_amount_field_display($form, $form_state, $field) {
  // Get the currency, either from a current donation or the node.
  if (!empty($form['#donation'])) {
    $currency = $form['#donation']->donation['currency'];
  }
  else {
    $currency = fundraiser_get_currency_from_node($form['#node']);
  }

  $field['#attributes']['class'][] = 'input-medium';
  $field['#field_prefix'] = $currency['symbol'];

  // Replace the currency-symbol token.
  if (isset($field['#description'])) {
    $field['#description'] = str_replace('[currency-symbol]', $currency['symbol'], $field['#description']);
  }

  return $field;
}

/**
 * Validation callback for field other_amount. Called during form validation.
 */
function _fundraiser_other_amount_field_validate($form, $form_state, $submission_fields, $value) {
  // Check for confusing selection.
  if (!empty($submission_fields['amount']) && $submission_fields['amount'] != "other" && !empty($submission_fields['other_amount'])) {
    return array(
      'amount' => t('You have entered a custom amount and selected a set amount. Please clarify which amount you ' .
        'intend to give, if you want to give the amount that appears in the other box, please select Other from ' .
        'the radio buttons.'),
      'other_amount' => '',
    );
  }
  $value = $submission_fields['amount'];
  // Look for other amount if set.
  if ($submission_fields['amount'] == 'other') {
    $value = $submission_fields['other_amount'];
  }
  // Check for valid value.
  if (!preg_match('/^\d*(\.\d*)?$/', $value)) {
    return array('other_amount' => t('Donation amount must be in a valid number format. No commas and only one decimal point.'));
  }
  // Check for minimum amount.
  $fundraiser = _fundraiser_get_fundraiser_by_nid($form['#node']->nid);
  $minimum_donation_amount = isset($fundraiser->minimum_donation_amount) ?
    $fundraiser->minimum_donation_amount :  variable_get('fundraiser_default_minimum', 10.00);
  $minimum_donation_amount = number_format($minimum_donation_amount, 2);
  if ($value < $minimum_donation_amount) {
    return array('other_amount' => t('Your donation amount must be greater than or equal to @min_amount.',
      array('@min_amount' => $minimum_donation_amount)));
  }
}

/**
 * Fundraiser field create callback.
 *
 * Sets the currency value from the node.
 */
function _fundraiser_currency_field_create($fundraiser, $field) {
  $currency = fundraiser_get_currency_from_node($fundraiser);
  $field['#value'] = $currency['code'];

  return $field;
}

/**
 * Fundraiser field display callback.
 *
 * Note this field is a value type, so not really displayed.
 */
function _fundraiser_currency_field_display($form, $form_state, $field) {
  // Get the currency, either from a current donation or the node.
  if (!empty($form['#donation'])) {
    $currency = $form['#donation']->donation['currency'];
  }
  else {
    $currency = fundraiser_get_currency_from_node($form['#node']);
  }

  $field['#value'] = $currency['code'];
  return $field;
}

/**
 * Validation callback for field email. Called during form validation.
 */
function _fundraiser_email_field_validate($form, $form_state, $submission_fields, $value) {
  if (!_fundraiser_validate_email(trim($value))) {
    return array('mail' => t('You must enter a valid email address.'));
  }
}

/**
 * Field callback, called at runtime to update the field with fundraiser specific settings during creation.
 */
function _fundraiser_payment_method_field_create($fundraiser, $field) {
  // If donation amounts don't exist, use amount as is.
  if (empty($fundraiser->gateways)) {
    // Leave it alone, do nothing else, don't overwrite existing values.
    $field['#allow_update'] = 0;
    return $field;
  }
  // Set all the fields for the gateways based on the configuration.
  $field['#extra'] = array(
    'payment_methods' => unserialize($fundraiser->gateways),
  );
  return $field;
}

/**
 * Asks the display glue module(s) for field information.
 * This allows other modules to find a field as needed in a form array.
 * For example - for retrieveing the AJAX return values of a form.
 */
function fundraiser_get_form_field($calling_module, $form, $field_key) {
  // Get the form element from the given form.
  if (module_hook($calling_module, 'fundraiser_get_form_field')) {
    return module_invoke($calling_module, 'fundraiser_get_form_field', $form, $field_key);
  }
  else {
    // Assume the form is a regularly constructed form and find it in a child somewhere.
    return _fundraiser_get_form_field($form, $field_key);
  }
}

/**
 * Asks the display glue module(s) to update field information.
 * This allows other modules to update a field as needed in a form array.
 */
function fundraiser_update_form_field($calling_module, $form, $field_key, $new_field) {
  // Save the changed form element.
  if (module_hook($calling_module, 'fundraiser_update_form_field')) {
    return module_invoke($calling_module, 'fundraiser_update_form_field', $form, $field_key, $new_field);
  }
  else {
    return _fundraiser_update_form_field($form, $field_key, $new_field);
  }
}

/**
 * There is no need for a creation function here to handle creating fields in a hook.
 * That is something the display glue module should be able to handle on it's own
 * given access to the callback information. No reason to put that in the central module.
 */

/**
 * Process through given submission fields to change their display form on the fly. Recursive.
 * Calling module provides the identity of the display glue module. Usually webform, could be sustainers.
 */
function fundraiser_display_form_fields($calling_module, &$form, $form_state, $field_info = NULL) {
  if ($field_info == NULL) {
    $field_info = _fundraiser_field_info();
  }
  $children = element_children($field_info);
  foreach ($children as $child) {
    if (isset($field_info[$child]['#display_callback']) && function_exists($field_info[$child]['#display_callback'])) {
      // Get the field, update it, and put it back.
      $this_field = fundraiser_get_form_field($calling_module, $form, $child);
      $new_field = call_user_func($field_info[$child]['#display_callback'], $form, $form_state, $this_field);
      $form = fundraiser_update_form_field($calling_module, $form, $child, $new_field);
    }
    // Check for any further children.
    fundraiser_display_form_fields($calling_module, $form, $form_state, $field_info[$child]);
  }
}

/**
 * Process through given submission fields to validate on the fly. Recursive.
 * This handles the calls to additional validation callbacks as defined in the field_info array.
 * May be called by any module that needs to perform validation on a submitted array. See sustainers.
 *
 * @return bool
 *   TRUE if there are validation errors.
 */
function fundraiser_validate_form_fields($form, $form_state, $submission_fields, $field_info = NULL, $errors = FALSE) {
  // Grab field info, we'll use this all the way down.
  if ($field_info == NULL) {
    $field_info = _fundraiser_field_info();
    drupal_alter('fundraiser_field_info_validate', $field_info, $form);
  }
  // Check for errors by field info array.
  $children = element_children($field_info);
  foreach ($children as $child) {
    $keys[$child] = '';
    // Check only if the submission field is set.
    // And the additional validate callback exists.
    if (isset($submission_fields[$child]) && isset($field_info[$child]['#validate_callback'])
       && function_exists($field_info[$child]['#validate_callback'])) {
      $error_messages = call_user_func($field_info[$child]['#validate_callback'], $form, $form_state,
        $submission_fields, $submission_fields[$child]);
      if (isset($error_messages) && !empty($error_messages)) {
        foreach ($error_messages as $form_field => $error_message) {
          // Set the error.
          $this_field = _fundraiser_get_form_field($form, $form_field);
          $parents = implode('][', $this_field['#parents']);
          form_set_error($parents, $error_message); // Coder: This is ok.
          $errors = TRUE;
        }
      }
    }
    // Recurse down.
    $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields, $field_info[$child], $errors);
  }
  return $errors;
}

/**
 * Donation form functions.
 */

/**
 * Default front end validation rules.
 */
function _fundraiser_donation_form_js_validation_config($node) {
  // jQuery Validate rules are objects, typecast here to recreate the format.
  // Zipcode validate
  $zip = (object) array(
    'required' => TRUE,
    'zipcode' => TRUE,
    'messages' => (object) array(
      'required' => t('This field is required.'),
      'zipcode' => t('Enter a valid zipcode.'),
    ),
  );
  // CVV validation
  $card_cvv = (object) array(
    'required' => TRUE,
    'number' => TRUE,
    'minlength' => 3,
    'maxlength' => 4,
    'messages' => (object) array(
      'required' => t('This field is required.'),
      'number' => t('Must be a number.'),
      'minlength' => t('Minimum of 3 characters.'),
      'maxlength' => t('Maximum of 4 characters.'),
    ),
  );
  // Credit card validation
  $card_number = (object) array(
    'required' => TRUE,
    'number' => TRUE,
    'creditcard' => TRUE,
    'messages' => (object) array(
      'required' => t('This field is required.'),
      'number' => t('Must be a number.'),
      'creditcard' => t('Enter a valid credit card number.'),
    ),
  );
  $settings = array(
    'zip' => $zip,
    'card_cvv' => $card_cvv,
    'card_number' => $card_number,
  );
  // Add validation to the amount textfield, which is only present
  // when no donation amounts are configured.
  if ($node->show_other_amount && count($node->donation_amounts) <= 1) {
    $settings['amount'] = array(
      'required' => TRUE,
      'number' => TRUE,
      'messages' => array(
        'required' => t('This field is required.'),
        'number' => t('Enter a valid amount.'),
      ),
    );
  }
  // Give 3rd party modules an opportunity to alter.
  drupal_alter('fundraiser_donation_form_js_validation', $settings, $node);

  return $settings;
}

/**
 * Donation form, display routine on data returned from glue display module.
 * Must be called from glue display module when displaying the donation form.
 */
function fundraiser_donation_form(&$form, &$form_state) {
  $node = $form['#node'];
  // Load any custom configuration options.
  $config = db_query('SELECT * FROM {fundraiser_webform_messages} f WHERE f.nid = :nid', array(':nid' => $form['#node']->nid))->fetchAssoc();

  // Attach the js files.
  $path = drupal_get_path('module', 'fundraiser');
  $form['#attached']['js'][] =  $path . '/js/jquery.alphanumeric.min.js';
  $form['#attached']['js'][] =  $path . '/js/jquery.validate.min.js';
  $form['#attached']['js'][] =  $path . '/js/donation_validation.js';
  // Add the validation configuration settings array.
  $form_validation_js = _fundraiser_donation_form_js_validation_config($node);
  if (!empty($form_validation_js)) {
    $form['#attached']['js'][] = array(
      'data' => array('fundraiser' => array('js_validation_settings' => $form_validation_js)),
      'type' => 'setting',
    );
  }

  if(isset($node->minimum_donation_amount)) {
    $min = array('minimum_donation_amount' => $node->minimum_donation_amount);
    $form['#attached']['js'][] = array(
      'data' => array('fundraiserWebform' => $min),
      'type' => 'setting',
    );
  }

  // Check to see if the form is being accessed over HTTPS.
  if ((!_fundraiser_is_secure() && !variable_get('fundraiser_development_mode', 0))) {
    // Return a 404 if the page isn't secure and should be.
    watchdog('fundraiser', 'The donation form <em>@title</em> is not protected with SSL.',
      array('@title' => $node->title), WATCHDOG_CRITICAL, l('View the donation form', 'node/' . $node->nid));
    $message = variable_get('fundraiser_http_error_message', t('We\'re sorry, but this donation form is experiencing a temporary problem. Please try again later.'));
    // Remove all other form elements.
    foreach (element_children($form) as $child) {
      unset($form[$child]);
    }
    // Display the message.
    $form['fundraiser_http_error'] = array(
      '#type' => 'item',
      '#markup' => $message,
    );
  }
  else {
    // Prevent caching on this form, this will keep the back button operational.
    drupal_add_http_header('Cache-Control', 'no-cache, no-store, must-revalidate, post-check=0, pre-check=0');
    $form['#attributes']['class'][] = 'fundraiser-donation-form';
    // Add validation and submit routines for fundraiser to get called during submission.
    // Otherwise, do nothing, rely on the glue modules to provide the form we need to the user.
    // We add these first to make sure they're available for the hook call.
    $form['#validate'][] = 'fundraiser_donation_validate';
    $form['#submit'][] = 'fundraiser_donation_submit';

    // When confirmations are moved, this goes elsewhere.
    $form['#submit'][] = 'fundraiser_donation_post_submit';

    // Apply currency data to the form.
    $currency = fundraiser_get_currency_from_node($node);
    $symbol = check_plain($currency['symbol']);

    // Make the currency available as a JS setting.
    // Used by quantity to set a Total value.
    $form['#attached']['js'][] = array(
      'data' => array('fundraiser' => array('currency' => $currency)),
      'type' => 'setting',
    );

    // Add class to quantity field (for legacy forms)
    $quantity = _fundraiser_get_form_field($form, 'quantity');
    if (!empty($quantity)) {
      $quantity['#attributes']['class'][] = 'input-medium';
      $form = _fundraiser_update_form_field($form, 'quantity', $quantity);
    }

    // Add class to zip code field
    $zip = _fundraiser_get_form_field($form, 'zip');
    $zip['#attributes']['class'][] = 'input-medium';
    $form = _fundraiser_update_form_field($form, 'zip', $zip);

    // Change ask amount labels.
    $amount = _fundraiser_get_form_field($form, 'amount');
    if (isset($amount) && !empty($amount)) {
      if (isset($amount['#options'])) {
        foreach ($amount['#options'] as $val => $label) {
          $amount['#options'][$val] = str_replace('$', $symbol, $label);
        }
      }
      else {
        $amount['#field_prefix'] = $symbol;
      }
    }
    $form = _fundraiser_update_form_field($form, 'amount', $amount);


    // Call hook to allow sub modules to add / manipulate the form.
    // NOTE: we are not using module_invoke_all on purpose here.
    // Node objects (common on webform objs) flag as recursive warnings.
    //$form = module_invoke_all('fundraiser_donation_form', $form, $form_state);
    foreach (module_implements('fundraiser_donation_form') as $module) {
      $result = module_invoke($module, 'fundraiser_donation_form', $form, $form_state);
      if (isset($result) && is_array($result)) {
        $form = array_merge($form, $result);
      }
    }
  }
}

/**
 * Donation form, validation routine on data returned from glue display module.
 * Called from glue display module to validate additional data.
 */
function fundraiser_donation_validate(&$form, &$form_state) {
  // Call hook to validate donation values against fundraiser needs and sub module needs.
  // Each is meant to return a not ok response or nothing.
  // No response = we're all good, otherwise we return an array of values for handling.
  drupal_alter('fundraiser_donation_validate', $form, $form_state);
  $errors = module_invoke_all('fundraiser_donation_validate', $form, $form_state);
  // Then handle our own business.
  if (!empty($errors)) {
    // Call the related donation process function.
    fundraiser_donation_failed_validation($errors);
  }
}

/**
 * Donation form, submission routine on data returned from glue display module.
 * Called from glue display module to submit additional data.
 * NOTE: This is the right function to call repeatedly (with different data as needed)
 * if you need to submit n+ donations on any single submission.
 * Assumption in all of the fundraiser system is that one submission of a form = one donation.
 * So keep that in mind as you work, if you need to make more than one donation at a time
 * then it is better to falsify multiple submissions to the form than to try and shove more than
 * one donation processed per submission.
 */
function fundraiser_donation_submit(&$form, &$form_state) {
  // Create the donation object and load it with the submitted information for the donation.
  $donation = new stdClass();
  // Using user load to avoid user object being carried by ref around.
  global $user;
  $donation->uid = $user->uid;
  $donation->user = user_load($user->uid);
  // Load the node from the form.
  $donation->nid = $form['#node']->nid;
  $donation->node = $form['#node'];

  // Since this is a form submission set the reference charge value to FALSE
  $donation->reference_charge = FALSE;

  // Call hook to gather submission donation values for the donation.
  module_invoke_all('fundraiser_donation_submit', $form, $form_state, $donation);
  // Call hook to allow modules to alter the form or donation.
  drupal_alter('fundraiser_donation_submit', $form, $form_state, $donation);
  // $donation->donation now contains the submitted values from the form.
  // Once we have a submission we can get to the real meat of things and attempt to create it.
  // This calls our set of functions to process the donation from there.
  if (!empty($donation->donation)) {
    _fundraiser_donation_submit_to_process($form, $form_state, $donation);
    _fundraiser_donation_submit_after_process($donation);
  }
  else {
    // No submission was able to be found. So we really have nothing to go on.
    // Mark this as a failure and move on.
    $donation->result['success'] = FALSE;
  }
  // Add the donation and result info to the form_state so we can reference it later.
  $form_state['#donation'] = $donation;
}

/**
 * Helper function, given a donation object, central function to create, process, and manage results.
 * Provided for other modules to use as needed for redirection style processes.
 */
function _fundraiser_donation_submit_to_process($form, $form_state, $donation) {
  // Create the donation to process, allows other modules to modify results by hooks.
  fundraiser_donation_create($donation);
  $did = $donation->did;
  // Caching form values are provided ONLY for the purpose of handling redirect submissions.
  // It is intended to allow redirects to pick back up with form submission after returning to site.
  cache_set('fundraiser-form-id-' . $did, $form_state['values']['form_build_id'], 'cache', strtotime('+15 minutes'));
  // Cache the CURRENT version of the forms as well, as they have been processed up to this point.
  cache_set('fundraiser-form-' . $did, $form, 'cache_form', strtotime('+15 minutes'));
  cache_set('fundraiser-form-state-' . $did, $form_state, 'cache_form', strtotime('+15 minutes'));
  // The created donation information should be at at $donation->donation, ready to process.
  fundraiser_donation_process($donation);
}

/**
 * Helper function, given a donation object, central function to create, process, and manage results.
 * Provided for other modules to use as needed for redirection style processes.
 */
function _fundraiser_donation_submit_after_process($donation) {
  // Clear caches.
  cache_clear_all('fundraiser-form-id-' . $donation->did, 'cache');
  cache_clear_all('fundraiser-form-' . $donation->did, 'cache_form');
  cache_clear_all('fundraiser-form-state-' . $donation->did, 'cache_form');

  // Finish donation processing.
  if (!isset($donation->result['message'])) {
    $donation->result['message'] = '';
  }
  // The results should be at $donation->result, ready to respond to the aftermath.
  if (isset($donation->result['success']) && $donation->result['success']) {
    fundraiser_donation_success($donation);
  }
  else {
    $donation->result['success'] = FALSE;
    fundraiser_donation_decline($donation);
  }
}

/**
 * Submit callback after donation submitted, but before confirmation.
 *
 * Provides a hook alter to allow for sub modules to change behavior after
 * submission. Such as in cases of failures or the like.
 */
function fundraiser_donation_post_submit(&$form, &$form_state) {

  drupal_alter('fundraiser_donation_post_submit', $form, $form_state, $form_state['#donation']);
}

/**
 * Donation processing functions.
 */

/**
 * Donation processing, a given donation needs to be commented on.
 */
function fundraiser_donation_comment($donation, $comment, $variables = array(), $severity = WATCHDOG_NOTICE, $link = NULL) {
  // Make a log entry
  if (variable_get('fundraiser_log_comments', 0)) {
    watchdog('fundraiser_comment', $comment, $variables, $severity, $link);
  }
  // Allow other modules to respond to the cancel. Including Ubercart, etc.
  module_invoke_all('fundraiser_donation_comment', $donation, $comment, $variables, $severity, $link);
}

/**
 * Given a donation id, gather information to display for that donation.
 * To be displayed when needed by other modules.
 */
function fundraiser_donation_information_table($did) {
  $rows = array();
  $donation = fundraiser_donation_get_donation($did);
  if (!$donation) {
    return;
  }

  $rows[] = array('Fundraiser user', t('User #@uid - !name',
    array('@uid' => $donation->uid, '!name' => l($donation->user->name, 'user/' . $donation->user->uid))));
  if (isset($donation->node->nid)) {
    $rows[] = array('Fundraiser node', t('Node #@nid - !title',
      array('@nid' => $donation->nid, '!title' => l($donation->node->title, 'node/' . $donation->node->nid))));
  }
  else {
    $rows[] = array('Fundraiser node', t('Node #@nid - !title',
      array('@nid' => '---', '!title' => t('No fundraiser node found.'))));
  }
  $variables = array(
    'header' => array(),
    'rows' => $rows,
  );
  drupal_alter('fundraiser_donation_information_table', $variables, $donation);
  return theme('table', $variables);
}

/**
 * Donation processing, a given donation failed to validate.
 */
function fundraiser_donation_failed_validation($errors) {
  // Handle our own tracking.
  _fundraiser_update_tracking_value($errors['nid'], 'local_failures');
  // Call hook to allow sub modules to respond to the failure as well.
  module_invoke_all('fundraiser_donation_failed_validation', $errors);
}

/**
 * Donation processing, a donation needs to be created prior to processing.
 */
function fundraiser_donation_create($donation) {
  // The gateway is selected by the user, was set during submission. Same as nid, uid, sid etc.
  // Call hooks to create the donation. The glue module handles everything else once handed fundraisers info.
  // This is a good location to update $donation->data for processing.
  module_invoke_all('fundraiser_donation_create', $donation);
  // For now, our creation system is responsible for creating a did.
  // Track the did, nid, uid internally so we can keep things in order.
  // Grab the submission path, if there is no alias, use the standard node path.
  global $base_url;
  $alias = drupal_lookup_path('alias', $_GET['q']);
  $form_url = '';
  if (!empty($alias)) {
    $form_url = $base_url . '/' . $alias;
  }
  else {
    $form_url = $base_url . '/node/' . $donation->nid;
  }

  $donation_record = array(
    'did' => $donation->did, // Donation id.
    'nid' => $donation->nid, // Fundraiser node id.
    'uid' => $donation->uid, // Submission user id.
    'sid' => $donation->sid, // Submission id.
    'status' => $donation->status,
    'amount' => $donation->amount,
    'currency' => $donation->currency,
    'txn_id' => '',
    'form_url' => $form_url,
    'created' => REQUEST_TIME,
    'changed' => REQUEST_TIME,
    'card_id' => !empty($donation->data['cardonfile']) ? $donation->data['cardonfile'] : NULL,
  );
  if (is_string($donation->gateway)) {
    $donation_record['gateway'] = $donation->gateway;
  }
  elseif (is_array($donation->gateway) && isset($donation->gateway['id']) && !empty($donation->gateway['id'])) {
    $donation_record['gateway'] = $donation->gateway['id'];
  }
  _fundraiser_create_donation($donation_record);
  // Add a comment.
  global $user;
  $username = isset($user->name) ? $user->name : 'Anonymous';
  fundraiser_donation_comment($donation, 'This donation was created on @date by @username.',
    array('@date' => format_date(strtotime('now')), '@username' => $username));
  // Respond after the creation of a donation. (Insert essentially)
  // At this point an order has been created by the charging module and etc.
  module_invoke_all('fundraiser_donation_post_create', $donation);
}

/**
 * Donation processing, a donation needs to be updated with new information prior to processing.
 * For example, in the course of updating a sustainers information.
 */
function fundraiser_donation_update($donation, $vocal_mode = TRUE) {
  // Call hooks to create the donation. The glue module handles everything else once handed fundraisers info.
  module_invoke_all('fundraiser_donation_update', $donation);
  // The additional fields $donation->additional, ready to process.
  // For now, our creation system is responsible for creating a did.
  // Track the did, nid, uid internally so we can keep things in order.
  $fundraiser_node = node_load($donation->nid);
  $donation_record = array('did' => $donation->did);
  if (isset($donation->nid) && !empty($donation->nid)) {
    $donation_record['nid'] = $donation->nid;
  }
  if (isset($donation->uid) && !empty($donation->uid)) {
    $donation_record['uid'] = $donation->uid;
  }
  if (isset($donation->sid) && !empty($donation->sid)) {
    $donation_record['sid'] = $donation->sid;
  }
  if (isset($donation->status) && !empty($donation->status)) {
    $donation_record['status'] = $donation->status;
  }
  if (isset($donation->amount) && !empty($donation->amount)) {
    $donation_record['amount'] = $donation->amount;
  }
  elseif (!empty($donation->donation['amount'])) {
    $donation_record['amount'] = $donation->donation['amount'];
    // was a quantity (of > 1) specified? (legacy forms)
    if (isset($donation->donation['quantity']) && $donation->donation['quantity'] > 1) {
      // multiply base donation amount by quantity to get the donation total
      $donation_record['amount'] = number_format($donation->donation['amount'] * $donation->donation['quantity'], 2);
    }
  }
  if (isset($donation->currency) && !empty($donation->currency)) {
    $donation_record['currency'] = $donation->currency;
  }
  if (isset($donation->gateway) && !empty($donation->gateway)) {
    if (is_string($donation->gateway)) {
      $donation_record['gateway'] = $donation->gateway;
    }
    elseif (is_array($donation->gateway) && isset($donation->gateway['id']) && !empty($donation->gateway['id'])) {
      $donation_record['gateway'] = $donation->gateway['id'];
    }
  }
  if (isset($donation->txn_id) && !empty($donation->txn_id)) {
    $donation_record['txn_id'] = $donation->txn_id;
  }
  if (isset($donation->form_url) && !empty($donation->form_url)) {
    $donation_record['form_url'] = $donation->form_url;
  }
  if (!empty($donation->data['cardonfile'])) {
    $donation_record['card_id'] = $donation->data['cardonfile'];
  }
  $donation_record['changed'] = REQUEST_TIME;
  _fundraiser_update_donation($donation_record);
  // Refresh the cache. No need to change the donation object passed in, but stored values should be zapped.
  fundraiser_donation_get_donation($donation->did, TRUE);
  // Add a comment.
  if ($vocal_mode) {
    global $user;
    $username = isset($user->name) ? $user->name : 'Anonymous';
    fundraiser_donation_comment($donation, 'This donation was updated on @date by @username.',
      array('@date' => format_date(strtotime('now')), '@username' => $username));
  }
  // Respond after the update of a donation.
  module_invoke_all('fundraiser_donation_post_update', $donation);
}

/**
 * Copy donation object without references to the original object
 */
function _fundraiser_donation_copy($donation) {
  return unserialize(serialize($donation));
}

/**
 * Donation processing, a given donation needs to be processed.
 */
function fundraiser_donation_process($donation) {
  // Create an array of values for the log.
  $log = array(
    'start' => microtime(TRUE),
    'transaction_type' => 'charge',
  );

  // Pass this down to the processing module.
  module_invoke_all('fundraiser_donation_process', $donation);

  // Mark the end time of the processing.
  $log['end'] = microtime(TRUE);

  // Log the processing details.
  fundraiser_log_donation_processing($donation, $log);

  // And save the donation as it is at this stage since it was created.
  // This makes sure that any changes made stay in place.
  fundraiser_donation_update($donation, FALSE);
  // Respond after the update of a donation.
  module_invoke_all('fundraiser_donation_post_process', $donation);
}

/**
 * Donation processing, a given donation was successful.
 */
function fundraiser_donation_success($donation) {
  // Track the success.
  _fundraiser_update_tracking_value($donation->nid, 'conversions');
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message && isset($donation->result['message'])) {
    drupal_set_message($donation->result['message']);
  }
  // Allow other modules to respond to the success.
  module_invoke_all('fundraiser_donation_success', $donation);
  // Add a comment.
  global $user;
  $username = isset($user->name) ? $user->name : 'Anonymous';
  fundraiser_donation_comment($donation, 'This donation was successfully completed on @date by @username.',
    array('@date' => format_date(strtotime('now')), '@username' => $username));
  // And save the donation as it is at this stage since it was created.
  // This makes sure that any changes made stay in place.
  fundraiser_donation_update($donation, FALSE);
}

/**
 * Donation processing, a given donation was declined.
 */
function fundraiser_donation_decline($donation) {
  // Track this failure.
  _fundraiser_update_tracking_value($donation->nid, 'gateway_failures');
  // Make a log entry.
  watchdog('fundraiser', 'Donation @id was declined by the payment gateway. Reason: @message',
    array('@id' => $donation->did, '@message' => $donation->result['message']), WATCHDOG_DEBUG, NULL);
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message) {
    drupal_set_message($donation->result['message']);
  }
  // Allow other modules to respond to the decline.
  module_invoke_all('fundraiser_donation_decline', $donation);
  // Add a comment.
  global $user;
  $username = isset($user->name) ? $user->name : 'Anonymous';
  fundraiser_donation_comment($donation, 'This donation was declined at the gateway on @date by @username.',
    array('@date' => format_date(strtotime('now')), '@username' => $username));
  // And save the donation as it is at this stage since it was created.
  // This makes sure that any changes made stay in place.
  fundraiser_donation_update($donation, FALSE);
}

// TODO how does this even get called? Is this functionally different from a decline?
/**
 * Donation processing, a given donation experienced an exception.
 */
function fundraiser_donation_exception($donation) {
  // Make a log entry.
  watchdog('fundraiser', 'An error occurred while processing donation @id. Error: @message',
    array('@id' => $donation->did, '@message' => $donation->result['message']), WATCHDOG_ERROR, NULL);
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message) {
    drupal_set_message($donation->result['message']);
  }
  // Add a comment.
  global $user;
  $username = isset($user->name) ? $user->name : 'Anonymous';
  fundraiser_donation_comment($donation, 'This donation encountered an exception on @date by @username.',
    array('@date' => format_date(strtotime('now')), '@username' => $username));
  // And save the donation as it is at this stage since it was created.
  // This makes sure that any changes made stay in place.
  fundraiser_donation_update($donation, FALSE);
  // Allow other modules to respond to the exception.
  module_invoke_all('fundraiser_donation_exception', $donation);
}

/**
 * Donation processing, a given donation needs to be cancelled.
 * Generally, only available for Authorize.net gateway donations. For example, during sustainer call.
 */
function fundraiser_donation_cancel($donation) {
  // Make a log entry
  watchdog('fundraiser', 'Donation @id was canceled by the user.',
    array('@id' => $donation->did), WATCHDOG_DEBUG, NULL);
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message) {
    drupal_set_message(t('Your payment #:did has been canceled.', array(':did' => $donation->did)));
  }
  // Add a comment.
  global $user;
  $username = isset($user->name) ? $user->name : 'Anonymous';
  fundraiser_donation_comment($donation, 'This donation was cancelled on @date by @username.',
    array('@date' => format_date(strtotime('now')), '@username' => $username));

  // Allow other modules such as Ubercart to respond to cancellation and
  // and update the commernce order status to reflect cancellation so that
  // the fundraiser_donation table's status will be correct when it is updated.
  module_invoke_all('fundraiser_donation_cancel', $donation);

  // Finally, save changes to the donation, updating this donation's status in the
  // fundraiser_donation table to reflect the status set within the commerce_order table:
  fundraiser_donation_update($donation, FALSE);
}

/**
 * Donation processing, a given donation needs to be deleted.
 * Generally, not called, but it does happen.
 */
function fundraiser_donation_delete($donation) {
  // Make a log entry
  watchdog('fundraiser', 'Donation @id was deleted.',
    array('@id' => $donation->did), WATCHDOG_DEBUG, NULL);
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message) {
    drupal_set_message(t('Your payment #:did has been deleted.', array(':did' => $donation->did)));
  }
  // Add a comment.
  global $user;
  $username = isset($user->name) ? $user->name : 'Anonymous';
  fundraiser_donation_comment($donation, 'This donation was deleted on @date by @username.',
    array('@date' => format_date(strtotime('now')), '@username' => $username));
  // And save the donation as it is at this stage since it was created.
  // This makes sure that any changes made stay in place.
  fundraiser_donation_update($donation, FALSE);
  // Allow other modules to respond to the cancel. Including Ubercart, etc.
  module_invoke_all('fundraiser_donation_delete', $donation);
}

/**
 * Utility function, given a donation id - get everything that goes with it.
 *
 * @param int $did
 *   The ID of the donation
 * @param bool $refresh
 *   If TRUE rebuild the entire donation even if it's statically cached.
 *
 * @return object|bool
 *    The fully loaded donation object or FALSE if no donation is found
 */
function fundraiser_donation_get_donation($did, $refresh = FALSE, $donation_record = NULL) {
  // Pull from cached donation unless we are refreshing the cache.
  static $donations;
  if (!$refresh && isset($donations[$did])) {
    return $donations[$did];
  }

  // Grab basic data from our own systems.
  if (empty($donation_record)) {
    $donation_record = _fundraiser_get_donation_by_did($did);
  }
  if (!$donation_record) {
    return FALSE;
  }

  // If refreshing, or first load, pull all data from database.
  $donation = (object) array();
  $donation->did = $did;
  $donation->nid = $donation_record->nid;
  $donation->node = node_load($donation_record->nid);
  $donation->uid = $donation_record->uid;
  $donation->user = user_load($donation_record->uid);
  $donation->sid = $donation_record->sid;
  // Additional fields.
  $donation->status = $donation_record->status;
  $donation->amount = $donation_record->amount;
  $donation->currency = $donation_record->currency;
  $donation->created = $donation_record->created;
  $donation->changed = $donation_record->changed;

  // Grab gateway information and replace it in the node too if found.
  $gateway = _fundraiser_get_donation_gateway($did);
  if (isset($gateway['id'] )) {
    $donation->gateway = $gateway;
  }
  // Grab the transaction id if it exists, add it here.
  $donation->txn_id = isset($donation_record->txn_id) ? $donation_record->txn_id : '';
  $donation->form_url = $donation_record->form_url;
  // And has refund grab them too
  $donation->refunds = FALSE;
  $donation->refunds = fundraiser_refund_get_refunds_by_did($did, TRUE);

  // Call hooks to re-create the donation info.
  // The glue modules handle everything else once handed fundraisers info.
  module_invoke_all('fundraiser_donation_get_donation', $donation);
  // Store the donation information into the cache.
  $donations[$did] = $donation;

  return $donation;
}

/**
 * Provide a menu router autoloader wrapper for fundraiser_donation_get_donation().
 */
function fundraiser_donation_load($did) {
  return fundraiser_donation_get_donation($did);
}

/**
 * Get the first donation ID that matches the given submission ID.
 *
 * Be aware that multiple donations may have the same submission ID.
 * For example, recurring donations will have the initial sid.
 *
 * @param int $sid
 *   The submission ID.
 *
 * @return int|bool
 *   The donation ID, or FALSE.
 */
function fundraiser_donation_get_did_by_sid($sid) {
  return db_query("SELECT MIN(did) FROM {fundraiser_donation} WHERE sid = :sid", array(':sid' => $sid))
    ->fetchField();
}

/**
 * Refund donation form functions.
 */

/**
 * Menu callback for refund tab on donations.
 */
function fundraiser_show_refund_form($did) {
  if (!user_access('refund donations')) {
    drupal_set_message(t('You do not have access to refund donations.'));
    return '';
  }
  drupal_add_css(drupal_get_path('module', 'fundraiser') . '/css/refund.css');
  drupal_add_js(drupal_get_path('module', 'fundraiser') . '/js/refund.js');
  return drupal_render( drupal_get_form('_fundraiser_refund', $did) );
}

/**
 * Refund form
 */
function _fundraiser_refund_form($form, &$form_state, $did) {
  $form = array();

  // Given a donation ID, grab all relevant information to create the form.
  $donation = fundraiser_donation_get_donation($did);
  $form_state['donation_id'] = $donation->did;

  $form['payment_summary'] = array(
    '#type' => 'fieldset',
    '#title' => t('Payment Summary'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  // Since we'll be doing math on these numbers we'll use the whole number values.
  $order_wrapper = entity_metadata_wrapper('commerce_order', commerce_order_load($donation->did));
  $order_total = $order_wrapper->commerce_order_total->value();

  $donation_amount = $order_total['amount'];
  $refund_summary = array();
  $refunded_total = 0;

  if (is_array($donation->refunds)) {
    foreach ($donation->refunds as $refund) {
      if ($refund->status == 'refunded' || $refund->status == 'partially_refunded') {
        $refunded_total += abs($refund->amount);
      }
      $refund_summary[] = t('%status #%id for $%amount on %date.',
        array(
        '%id' => $refund->rid,
        '%amount' => abs($refund->amount),
        '%date' => date('m/d/y', isset($refund->created) ? $refund->created : 0),
        '%status' => $refund->status,
      )
      ); //TODO fix up value display for international.
    }

    $refund_summary = !empty($refund_summary) ? theme('item_list', array('items' => $refund_summary)) : t('No refunds have been made.');
    $refunded_total = $refunded_total;
  }
  // Display form.
  if ($donation->refunds == FALSE) {
    $form['payment_summary']['no_payments'] = array(
      '#type' => 'item',
      '#markup' => t('No refunds have been made on this order yet.'),
      '#prefix' => '<div>',
      '#suffix' => '</div>',
    );
  }
  $form['payment_summary']['payment_total'] = array(
    '#type' => 'item',
    '#title' => t('Payment Total'),
    '#markup' => $donation->donation['amount_formatted'],
  );
  $form['payment_summary']['refunded_total'] = array(
    '#type' => 'item',
    '#title' => t('Refunded Total'),
    '#markup' => commerce_currency_format($refunded_total, $donation->currency, NULL, FALSE),
  );
  if (!empty($refund_summary)) {
    $form['payment_summary']['refunded_summary'] = array(
      '#type' => 'item',
      '#title' => t('Previously Refunded'),
      '#markup' => $refund_summary,
    );
  }

  // Form for submitting a refund.
  $form['refund_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Refund Options'),
    '#description' => t('Note that refunds can only be applied to payments that have been settled ' .
     'in the payment processor. This typically happens every night; if the payment was made today, ' .
     'you will probably need to wait until tomorrow to issue a refund.'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  // Only show the refund form if the payment was made through a payment gateway that can handle refunds
  if (isset($donation->gateway)) { // Set during fundraiser_donation_get_donation().
    $can_refund = FALSE;
    if (!empty($donation->gateway['allow_refund']) && in_array($donation->donation['payment_method'], $donation->gateway['allow_refund'])) {
      $can_refund = TRUE;
    }
    $able_to_refund = $donation->donation['amount'] - $refunded_total;
    if (!$can_refund || $able_to_refund <= 0) {
      // They've made a payment, but it cannot be refunded
      if ($able_to_refund <= 0) {
        $no_refund_text = t('As many refunds as can be made on this donation have been made.');
      }
      elseif (!$can_refund) {
        $no_refund_text = t('Refunds cannot be made on this order. The payment was made on a payment ' .
         'gateway that does not support refunds.');
      }
      // They have NOT made any payment yet, so there's nothing to refund
      else {
        $no_refund_text = t('No payments have been processed on this order, so no refunds can be made yet.');
        // Even once the payment is made, they won't be able to refund it
        if (!$can_refund) {
          $no_refund_text .= ' ' . t('However, because this order was made on a payment gateway that ' .
            'does not support refunds, you will not be able to make refunds after payments are processed ' .
            'on this order.');
        }
      }
      $form['refund_options']['no_refund_explanation'] = array(
        '#markup' => $no_refund_text,
        '#prefix' => '<strong>',
        '#suffix' => '</strong>',
      );
    }
    // Provide refund options
    else {
      $form['able_to_refund'] = array(
        '#type' => 'value',
        '#value' => $able_to_refund,
      );
      $form['refunded_total'] = array(
        '#type' => 'value',
        '#value' => $refunded_total,
      );
      $form['refund_options']['refund_type'] = array(
        '#title' => t('Refund options'),
        '#type' => 'radios',
        '#options' => array(
          'full' => t('Full Refund ( %amount )', array('%amount' => commerce_currency_format(commerce_currency_decimal_to_amount($able_to_refund, $donation->currency), $donation->currency))),
          'partial' => t('Partial Refund'),
        ),
        '#default_value' => isset($form_state['input']['refund_type']) ? $form_state['input']['refund_type'] : 'full',
      );
      $form['refund_options']['amount'] = array(
        '#type' => 'textfield',
        '#title' => t('Amount to Refund'),
        '#size' => 40,
        '#maxlength' => 255,
        '#states' => array(
          'required' => array(
            ':input[name="refund_type"]' => array('value' => 'partial'),
          ),
          'visible' => array(
            ':input[name="refund_type"]' => array('value' => 'partial'),
          ),
        ),
      );
      $form['refund_options']['refund_notes'] = array(
        '#type' => 'textarea',
        '#title' => t('Refund Notes'),
        '#description' => t('Please provide reference information about this refund (Requestor, reason, etc.)'),
        '#cols' => 60,
        '#rows' => 5,
        '#required' => TRUE,
      );
      $form['refund_options']['issue_refund'] = array(
        '#type' => 'submit',
        '#value' => t('Issue Refund'),
        '#required' => TRUE,
      );
      $form['able_to_refund'] = array(
        '#type' => 'hidden',
        '#value' => number_format($able_to_refund, 2),
      );
      $form['refunded_total'] = array(
        '#type' => 'hidden',
        '#value' => number_format($refunded_total, 2),
      );
    }
  }
  else {
    $form['refund_options']['no_refund_explanation'] = array(
      '#markup' => t('The gateway for this refund is no longer available. A refund cannot be offered on this transaction.'),
      '#prefix' => '<strong>',
      '#suffix' => '</strong>',
    );
  }

  return $form;
}

/**
 * Validate the form
 */
function _fundraiser_refund_form_validate($form, &$form_state) {
  // Get the donation.
  $donation = fundraiser_donation_get_donation($form_state['donation_id']);

  // Variables for tracking the refund type and amounts.
  $refund_type = $form_state['values']['refund_type'];
  $able_to_refund = $form_state['values']['able_to_refund'];
  $refund_amount = 0;

  if (empty($refund_type)) {
    form_set_error('refund_type', t('Select a type for the refund.'));
  }

  // A full refund uses the $able_to_refund amount, a partial refund needs to validate the entered amount.
  if ($refund_type != 'full') {
    // Convert the entered amount and refund amount to whole numbers.
    $amount = commerce_currency_decimal_to_amount(_fundraiser_amount_value_sanitize($form_state['values']['amount']), $donation->currency);
    $able_to_refund = commerce_currency_decimal_to_amount(_fundraiser_amount_value_sanitize($able_to_refund), $donation->currency);
    if ($amount <= 0) {
      form_set_error('amount', t('Enter a positive numerical refund amount.'));
    }
    else {
      // Check if the amount set to refund is less than the amount left to refund.
      if ($amount > $able_to_refund) {
        $context = array(
          'revision' => 'formatted-original',
          'type' => 'amount',
        );
        form_set_error('amount', t('The refund amount entered is too high. Only @paid in payments have been made, and no ' .
          'more than that can be refunded.', array('@paid' => commerce_currency_format($able_to_refund, $donation->currency))));
      }
      else {
        // Add the amount to refund to the form_state values.
        $refund_amount = $amount;
      }
    }
  }
  else {
    // Add the full amount to the form_state values.
    $refund_amount = $able_to_refund;
  }

  $form_state['values']['refund_amount'] = commerce_currency_amount_to_decimal($refund_amount, $donation->currency);

  $refund_notes = $form_state['values']['refund_notes'];
  if (empty($refund_notes)) {
    form_set_error('refund_notes', t('Please enter a reason for the refund.'));
  }
}

/**
 * Submit the refund form
 */
function _fundraiser_refund_form_submit($form, &$form_state) {
  // Get the donation.
  $donation = fundraiser_donation_get_donation($form_state['donation_id']);

  // Determine how much has been paid, less previous refunds
  $refunded_total = (float) $form_state['values']['refunded_total'];
  $able_to_refund = (commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->currency) - $refunded_total);

  // Partial refund.
  if ($form_state['values']['refund_type'] != 'full') {
    $amount = commerce_currency_decimal_to_amount($form_state['values']['refund_amount'], $donation->currency);

    $new_status = 'partially_refunded';
    // Prevent a refund of more than the amount paid.
    if ($amount >= $able_to_refund) {
      $amount = $able_to_refund;
      $new_status = 'refunded';
    }
  }
  // Full refund.
  else {
    $amount = $able_to_refund;
    $new_status = 'refunded';
  }

  // Set up the refund.
  $refund = new stdClass();
  $refund->did = $donation->did;
  $refund->amount = commerce_currency_amount_to_decimal($amount, $donation->currency);
  $refund->currency = $donation->currency;
  $refund->reason = $form_state['values']['refund_notes'];
  $refund->rid = time();  // Use a timestamp to avoid PayPal error 11607 (duplicate MSGSUBID value)
  $refund = fundraiser_refund_create($refund);
  // Then process it.
  $refund->new_status = $new_status;
  fundraiser_refund_process($refund);
  // At this point $donation->result is set and responses can be handled.
  if (!isset($refund->result['message'])) {
    $refund->result['message'] = '';
  }
  // The results should be at $donation->result, ready to respond to the aftermath.
  if (isset($refund->result['success']) && $refund->result['success'] == TRUE) {
    fundraiser_refund_success($refund);
  }
  else {
    $donation->result['success'] = FALSE;
    drupal_set_message(t('Your refund failed to be processed.'));
    fundraiser_refund_decline($refund);
    $form_state['rebuild'] = TRUE;
    $form_state['values']['abort'] = TRUE;
  }
}
/**
 * Refund processing functions.
 */

/**
 * Utility function, given a donation id - get all refunds.
 */
function fundraiser_refund_get_refunds_by_did($did, $refresh = FALSE) {
  // Pull from cached donation unless we are refreshing the cache.
  static $refunds;
  if (!$refresh && isset($refunds[$did])) {
    return $refunds[$did];
  }
  $refund_set = array();
  $found_refunds = _fundraiser_get_refunds_by_did($did);
  foreach ($found_refunds as $found_refund) {
    $refund_set[] = fundraiser_refund_get_refund($found_refund->rid);
  }
  // Store the refunds information into the cache by did.
  $refunds[$did] = $refund_set;
  return $refund_set;
}

/**
 * Create a refund object.
 */
function fundraiser_refund_create($refund) {
  // Call hooks to create the donation. The glue module handles everything else once handed fundraisers info.
  module_invoke_all('fundraiser_refund_create', $refund);
  $refund->receipt_id = 'no_receipt';
  $refund->status = 'unknown';
  $refund->txn_id = '';
  $refund->created = REQUEST_TIME;
  $refund->changed = REQUEST_TIME;
  // Create the record
  $refund = _fundraiser_create_refund($refund);
  // Refresh the cache. No need to change the donation object passed in, but stored values should be zapped.
  $refund = fundraiser_refund_get_refund($refund->rid, TRUE);
  // Respond after the update of a donation.
  module_invoke_all('fundraiser_refund_post_create', $refund);
  return $refund;
}

/**
 * Update a refund object.
 */
function fundraiser_refund_update($refund) {
  // Call hooks to create the donation. The glue module handles everything else once handed fundraisers info.
  module_invoke_all('fundraiser_refund_update', $refund);
  $refund->receipt_id = isset($refund->receipt_id) ? $refund->receipt_id : 'no_receipt';
  $refund->changed = REQUEST_TIME;
  $refund = _fundraiser_update_refund($refund);
  // Refresh the cache. No need to change the donation object passed in, but stored values should be zapped.
  $refund = fundraiser_refund_get_refund($refund->rid, TRUE);
  // Respond after the update of a donation.
  module_invoke_all('fundraiser_refund_post_update', $refund);
}

/**
 * Donation processing, a given donation needs to be refunded.
 */
function fundraiser_refund_process($refund) {
  // Pass this down to the processing module.
    module_invoke_all('fundraiser_refund_process', $refund);
  // And save the refund as it is at this stage since it was created.
  // This makes sure that any changes made stay in place.
  fundraiser_refund_update($refund, FALSE);
  if (!empty($refund->donation)) {
    fundraiser_donation_update($refund->donation, FALSE);
  }
  // Respond after the update of a donation.
  module_invoke_all('fundraiser_refund_post_process', $refund);
}

/**
 * Donation processing, a given refund was successful.
 */
function fundraiser_refund_success($refund) {
  drupal_set_message(t('Refund has been issued.'));
  // Allow other modules to respond to the refund success. Such as SF modules.
  module_invoke_all('fundraiser_refund_success', $refund);
  fundraiser_refund_update($refund, FALSE);
  if (!empty($refund->donation)) {
    fundraiser_donation_update($refund->donation, FALSE);
  }
}

/**
 * Donation processing, a given refund was declined.
 */
function fundraiser_refund_decline($refund) {
  watchdog('fundraiser', 'Refund on donation #%did failed gateway validation. Reason: %reason.',
    array('%did' => $refund->did, '%reason' => $refund->result['message']), WATCHDOG_DEBUG);
  drupal_set_message($refund->result['message'], 'error');
  // Allow other modules to respond to the refund decline.
  module_invoke_all('fundraiser_refund_decline', $refund);
  fundraiser_refund_update($refund, FALSE);
  if (!empty($refund->donation)) {
    fundraiser_donation_update($refund->donation, FALSE);
  }
}

/**
 * Utility function, given a refund id - get everything that goes with it.
 */
function fundraiser_refund_get_refund($rid, $refresh = FALSE) {
  // Pull from cached donation unless we are refreshing the cache.
  static $refunds;
  if (!$refresh && isset($refunds[$rid])) {
    return $refunds[$rid];
  }
  // If refreshing, or first load, pull all data from database.
  $refund = (object) array();
  $refund->rid = $rid;
  // Grab basic data from our own systems.
  $refund_record = _fundraiser_get_refund_by_rid($rid);
  // Store the refund information into the cache.
  $refunds[$rid] = $refund_record;
  return $refund_record;
}

/**
 * Fundraiser's own get/set functions for handling fields in forms.
 */

/**
 * Given a standard (non webform, nothing fancy, form array. Locate a given key and return it.
 * Recursive.
 */
function _fundraiser_get_form_field($form, $field_key) {
  // Walks a given form looking for the given key. Returns it when found.
  foreach (element_children($form) as $child) {
    if ($child == $field_key) {
      // Return the found array.
      return $form[$child];
    }
    else {
      // Check this child for other children.
      $found = _fundraiser_get_form_field($form[$child], $field_key);
      if (!empty($found)) {
        return $found;
      }
    }
  }
}

/**
 * Given a standard (non webform, nothing fancy, form array. Locate a given key and update it.
 * Recursive.
 */
function _fundraiser_update_form_field($form, $field_key, $new_field) {
  // Walks a given form looking for the given key. Returns it when found.
  foreach (element_children($form) as $child) {
    if ($child == $field_key) {
      // Update the array.
      $form[$child] = array_merge($form[$child], $new_field);
    }
    else {
      // Check this child for other children.
      $form[$child] = _fundraiser_update_form_field($form[$child], $field_key, $new_field);
    }
  }
  return $form;
}

/**
 * Helper functions.
 */

/**
 * Helper function, given the array from field_info - get the listed keys.
 * WARNING: Recursion is here to walk the field info array to gather form keys.
 */
function _fundraiser_get_field_keys($field_info = NULL, $keys = array()) {
  if ($field_info == NULL) {
    $field_info = _fundraiser_field_info();
  }
  $children = element_children($field_info);
  $keys = array_merge($keys, $children);
  foreach ($children as $child) {
    if ($field_info[$child] != NULL && !empty($field_info[$child])) {
      $keys = _fundraiser_get_field_keys($field_info[$child], $keys);
    }
  }
  return $keys;
}

/**
 * Helper function, given the array from field_info - get the listed fields.
 * WARNING: Recursion is here to walk the field info array to gather fields.
 */
function _fundraiser_get_field_fields($field_info = NULL, $fields = array()) {
  if ($field_info == NULL) {
    $field_info = _fundraiser_field_info();
  }
  $children = element_children($field_info);
  foreach ($children as $child) {
    $fields[$child] = $field_info[$child];
  }
  foreach ($children as $child) {
    if ($field_info[$child] != NULL && !empty($field_info[$child])) {
      $fields = _fundraiser_get_field_fields($field_info[$child], $fields);
    }
  }
  return $fields;
}

/**
 * Helper function, collects gateway information by calling hook_fundraiser_gateway_info.
 */
function _fundraiser_gateway_info($id = NULL) {
  static $gateways;
  // Cache the gateway during page execution.
  if (empty($gateways)) {
    // If not, we go asking anyone else - usually the payment glue module.
    $gateways = module_invoke_all('fundraiser_gateway_info');
    drupal_alter('fundraiser_gateway_info', $gateways);
  }
  // Look up the gateway needed.
  if ($id != NULL) {
    foreach ($gateways as $delta => $gateway) {
      if ($gateway['id'] == $id) {
        return $gateway;
      }
    }
    return array();
  }
  return (array) $gateways;
}

/**
 * Helper function, determine if this node type supports donation forms.
 */
function fundraiser_is_donation_type($type) {
  static $fundraiser_types;
  // Cache fundraiser content types during page execution.
  if (!isset($fundraiser_types[$type])) {
    $fundraiser_types[$type] = variable_get('fundraiser_' . $type, FALSE);
  }
  return $fundraiser_types[$type];
}

/**
 * Helper function, determine if this node type supports donation forms.
 */
function fundraiser_get_donation_types() {
  // For all types, check if they are a fundraiser type.
  $types = node_type_get_types();
  foreach ($types as $type => $type_info) {
    $fundraiser_types[$type] = variable_get('fundraiser_' . $type, FALSE);
  }
  return $fundraiser_types;
}

/**
 * Helper function. Check if the current page is SSL protected.
 */
function _fundraiser_is_secure() {
  return (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') ? TRUE : FALSE;
}

/**
 * Generic helper functions. These may need to go into a diff. module.
 */

/**
 * Helper function, check if given string is an email format. Generically useful function.
 * Future plans: this may need to be moved to a toolkit module for use by all our modules.
 */
function _fundraiser_validate_email($mail) {
  // eregi is depr in PHP 5.3. Replaced with preg_match, adding lower case options.
  return preg_match("/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/", $mail);
}

/**
 * DB functions.
 */

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_create_fundraiser($fundraiser) {
  $fundraiser = (array) $fundraiser;
  $fundraiser_data = FALSE;
  if (isset($fundraiser['nid'])) {
    $fundraiser_data = _fundraiser_get_fundraiser_by_nid($fundraiser['nid']);
  }
  if (!$fundraiser_data) {
    // Implode donation amounds for saving.
    $imploded_amounts = array();
    $donation_amounts = FALSE;
    foreach ($fundraiser['donation_amounts'] as $index => $donation_amount) {
      if (isset($donation_amount['amount']) && isset($donation_amount['label'])) {
        // Settings are coming from the node edit page, each amount should be
        // an associative array with amount, label, and weight keys.
        $donation_amounts[$donation_amount['weight']] = $donation_amount['amount'] . '|' . $donation_amount['label'];
      }
    }
    if ($donation_amounts) {
      ksort($donation_amounts);
      $imploded_amounts = array_unique($donation_amounts);
    }
    // On getting fundraiser this will be exploded into the correct values.
    $fundraiser['donation_amounts'] = implode('|||', $imploded_amounts);
    // TODO: we should also store the donation_default internally, instead of
    // relying on fundraiser_webform to store that value for us.
    // For now, this will have to do.
    // Serialize for storage, our configured gateway values for storage in components.
    $fundraiser['gateways'] = isset($fundraiser['gateways']) ? serialize($fundraiser['gateways']) : serialize('');
    // After the node is created, add additional data to fundraiser.
    $record = array(
      'receipt_email_from' => variable_get('site_name', ''),
      'receipt_email_address' => variable_get('site_mail', ''),
      'receipt_email_subject' => t('Thank you for your donation'),
      'redirect_url' => '<confirmation>',
    );
    $record = array_merge($record, $fundraiser);
    if (isset($record['default_amount']) && empty($record['default_amount'])) unset($record['default_amount']); // NULL > empty
    drupal_write_record('fundraiser', $record);
    // And invoke the hooks for all the other modules to respond.
    module_invoke_all('fundraiser_create_fundraiser_alter', (object) $fundraiser);
  }
  else {
    _fundraiser_update_fundraiser($fundraiser);
  }
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_get_fundraiser_by_nid($nid) {
  // Get fundraiser table information.
  $fundraiser = db_query('SELECT * FROM {fundraiser} WHERE nid = :nid', array(':nid' => $nid))->fetchObject();
  if ($fundraiser) {
    // Explode the donation amounts that were imploded during save.
    $donation_amounts = explode('|||', $fundraiser->donation_amounts);
    $donation_amounts = array_unique($donation_amounts);
    $exploded_amounts = array();
    foreach ($donation_amounts as $donation_amount) {
      $exploded_amounts[] = explode('|', $donation_amount);
    }
    $fundraiser->donation_amounts = $exploded_amounts;
    // Get the unserialized gateway configurations.
    $fundraiser->gateways = unserialize($fundraiser->gateways);
    // Get values from other modules for additional information.
    module_invoke_all('fundraiser_get_fundraiser_alter', $fundraiser);
  }
  return $fundraiser;
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_update_fundraiser($fundraiser) {
  $fundraiser = (array) $fundraiser;
  $fundraiser_data = FALSE;
  if (isset($fundraiser['nid'])) {
    $fundraiser_data = _fundraiser_get_fundraiser_by_nid($fundraiser['nid']);
  }
  if (!$fundraiser_data) {
    _fundraiser_create_fundraiser($fundraiser);
  }
  else {
    $fundraiser = array_merge((array) $fundraiser_data, $fundraiser);
    // Implode donation amounds for saving.
    $imploded_amounts = array();
    $donation_amounts = array();
    foreach ($fundraiser['donation_amounts'] as $index => $donation_amount) {
      if (isset($donation_amount['weight']) && isset($donation_amount['amount'])) {
        // Settings are coming from the node edit page, each amount should be
        // an associative array with amount, label, and weight keys.
        $donation_amounts[$donation_amount['weight']] = $donation_amount['amount'] . '|' . $donation_amount['label'];
      }
      else {
        // Settings loaded directly from webform component, this means
        // the amount and label are in a numerically indexed array
        // and weight is not available.
        if (isset($donation_amount[0]) && isset($donation_amount[1])) {
          $donation_amounts[] = $donation_amount[0] . '|' . $donation_amount[1];
        }
      }
    }
    if (count($donation_amounts)) {
      ksort($donation_amounts);
      $imploded_amounts = array_unique($donation_amounts);
      // On getting fundraiser this will be exploded into the correct values.
      $fundraiser['donation_amounts'] = implode('|||', $imploded_amounts);
    }
    else {
      $fundraiser['donation_amounts'] = '';
    }
    // Serialize for storage, our configured gateway values for storage in components.
    $fundraiser['gateways'] = serialize($fundraiser['gateways']);
    $record = $fundraiser;
    if (isset($record['default_amount']) && empty($record['default_amount'])) unset($record['default_amount']); // NULL > empty
    drupal_write_record('fundraiser', $record, 'nid');
    // And invoke the hooks for all the other modules to respond.
    module_invoke_all('fundraiser_update_fundraiser_alter', (object) $fundraiser);
    // Fire a hook that other modules can use to add additional processing when a donation form is created.
    // Called in sf_donation.module
    // This can, and should, be replaced with hook_node_insert() implementations.
    // THIS HOOK IS TO BE DEPR.
    // module_invoke_all('fundraiser_form_insert', $node, $components);
  }
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_delete_fundraiser($nid) {
  db_delete('fundraiser')->condition('nid', $nid)->execute();
  // And invoke the hooks for all the other modules to respond.
  module_invoke_all('fundraiser_delete_fundraiser_alter', $nid);
}

/**
 * DB function for fundraiser.
 */
function _fundraiser_get_fundraiser_by_nids($nids) {
  // Get fundraiser table information.
  $fundraisers = array();
  foreach ($nids as $nid) {
    $fundraisers[$nid] = _fundraiser_get_fundraiser_by_nid($nid);
  }
  return $fundraisers;
}

/**
 * DB function for fundraiser.
 */
function _fundraiser_delete_fundraisers($nodes) {
  foreach ($nodes as $node) {
    _fundraiser_delete_fundraiser($node->nid);
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_create_donation($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_get_donation_by_did($donation['did']);
  }
  if (!$donation_data) {
    $record = array_merge((array) $donation_data, $donation);
    drupal_write_record('fundraiser_donation', $record);
  }
  else {
    _fundraiser_update_donation($donation);
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_get_donation_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_donation} ' .
    'WHERE did = :did',
    array(':did' => $did))->fetchObject();
}

/**
 * DB function for fundraiser_donation.
 */
function _fundraiser_get_donations() {
  return db_query('SELECT * FROM {fundraiser_donation}')->fetchAll();
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_update_donation($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_get_donation_by_did($donation['did']);
  }
  if (!$donation_data) {
    _fundraiser_create_donation($donation);
  }
  else {
    $record = array_merge((array) $donation_data, $donation);
    drupal_write_record('fundraiser_donation', $record, 'did');
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_delete_donation($did) {
  db_delete('fundraiser_donation')->condition('did', $did)->execute();
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_create_refund($refund) {
  // Cast donation just in case.
  $refund = (array) $refund;
  // Check for old data.
  $refund_data = FALSE;
  if (isset($refund['rid'])) {
    $refund_data = _fundraiser_get_refund_by_rid($refund['rid']);
  }
  if (!$refund_data) {
    drupal_write_record('fundraiser_refund', $refund);
  }
  else {
    $refund = _fundraiser_update_refund($refund);
  }
  return (object) $refund;
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_get_refund_by_rid($rid) {
  return db_query('SELECT * FROM {fundraiser_refund} ' .
    'WHERE rid = :rid',
    array(':rid' => $rid))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_update_refund($refund) {
  // Cast donation just in case.
  $refund = (array) $refund;
  // Check for old data.
  $refund_data = FALSE;
  if (isset($refund['rid'])) {
    $refund_data = _fundraiser_get_refund_by_rid($refund['rid']);
  }
  if (!$refund_data) {
    $refund = _fundraiser_create_refund($refund);
  }
  else {
    $record = array_merge((array) $refund_data, $refund); // Merge data together so we get everything in the record.
    drupal_write_record('fundraiser_refund', $refund, 'rid');
  }
  return (object) $refund;
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_delete_refund($rid) {
  db_delete('fundraiser_refund')->condition('rid', $rid)->execute();
}

/**
 * DB function for fundraiser_refund.
 */
function _fundraiser_get_refunds_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_refund} ' .
    'WHERE did = :did',
    array(':did' => $did))->fetchAll();
}

/**
 * DB function for fundraiser_refund.
 */
function _fundraiser_get_refund_by_txn_id($txn_id) {
  return db_query('SELECT * FROM {fundraiser_refund} ' .
    'WHERE txn_id = :txn_id',
    array(':txn_id' => $txn_id))->fetchAll();
}

/**
 * DB Function, Check if the given order was made on a payment gateway that supports refunds
 */
function _fundraiser_get_donation_gateway($did) {
  // First check the donation table. It trumps the fundraiser table in case the FR has changed since.
  $found_gateway = db_query('SELECT d.gateway FROM {fundraiser_donation} d ' .
    'WHERE d.did = :did', array(':did' => $did))->fetchField();
  // Now ask if any other module wants to override this result.
  module_invoke('fundraiser_get_donation_gateway_alter', $did, $found_gateway);
  // Now translate that into something we can use by getting the rest of the dateway info.
  if (isset($found_gateway)) {
    return _fundraiser_gateway_info($found_gateway);
  }
  // If nothing has been found, return nothing.
  return array();
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_create_tracking($tracking) {
  $tracking = (array) $tracking;
  $tracking_data = FALSE;
  if (isset($tracking['nid'])) {
    $tracking_data = _fundraiser_get_tracking_by_nid($tracking['nid']);
  }
  if (!$tracking_data) {
    $record = array(
      'pageviews' => 1,
      'conversions' => 0,
      'local_failures' => 0,
      'gateway_failures' => 0,
      'latest_load_time' => 0,
    );
    $tracking = array_merge($record, $tracking);
    drupal_write_record('fundraiser_tracking', $tracking);
  }
  else {
    _fundraiser_update_tracking($tracking);
  }
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_get_tracking_by_nid($nid) {
  return db_query('SELECT * FROM {fundraiser_tracking} WHERE nid = :nid', array(':nid' => $nid))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_update_tracking($tracking) {
  /**
   * Code commented out on 2/18/2016 by pcave for performance reasons.
   * When a donation form encounters significant traffic, updating a single row
   * in this table over and over during a request can cause lock contentions.
   * This eventually cascades to other database operations thus slowing down
   * the entire response.
   *
   * $tracking = (array) $tracking;
   * $tracking_data = FALSE;
   * if (isset($tracking['nid'])) {
   *   $tracking_data = _fundraiser_get_tracking_by_nid($tracking['nid']);
   * }
   * if (!$tracking_data) {
   *   _fundraiser_create_tracking($tracking);
   * }
   * else {
   *   $tracking = array_merge((array) $tracking_data, $tracking);
   *   drupal_write_record('fundraiser_tracking', $tracking, 'nid');
   * }
   */
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_delete_tracking($nid) {
  /**
   * Code commented out on 2/18/2016 by pcave for performance reasons.
   * When a donation form encounters significant traffic, updating a single row
   * in this table over and over during a request can cause lock contentions.
   * This eventually cascades to other database operations thus slowing down
   * the entire response.
   *
   * db_delete('fundraiser_tracking')->condition('nid', $nid)->execute();
   */
}

/**
 * DB function for updating the stats in fundraiser_tracking.
 */
function _fundraiser_update_tracking_value($nid, $field) {
   /**
   * Code commented out on 2/18/2016 by pcave for performance reasons.
   * When a donation form encounters significant traffic, updating a single row
   * in this table over and over during a request can cause lock contentions.
   * This eventually cascades to other database operations thus slowing down
   * the entire response.
   *
   * $tracking = _fundraiser_get_tracking_by_nid($nid);
   * // No tracking data? Create one.
   * if (!$tracking) {
   *   $tracking = new stdClass();
   *   $tracking->nid = $nid;
   *   _fundraiser_create_tracking($tracking);
   *   $tracking = _fundraiser_get_tracking_by_nid($nid);
   * }
   * // Check to make sure we weren't handed a non-existing track.
   * if (isset($tracking->$field)) {
   *   $tracking->$field++;
   *   _fundraiser_update_tracking($tracking);
   * }
   */
  }

/**
 * Implements hook_webform_token_selector_blacklist_alter().
 *
 * Filter out credit card webform components.
 * Note: this replaces _fundraiser_field_blacklist().
 */
function fundraiser_webform_token_selector_blacklist_alter(&$tokens) {
  // These fields may or may not even have a value depending on the user's selected form of submission.
  // So this may not be a viable solution anymore.
  $fundraiser_blacklist = array(
    'card_number',
    'card_cvv',
    'recurs_monthly',
    'card_expiration_month',
    'card_expiration_year',
  );
  $tokens = array_merge($fundraiser_blacklist, $tokens);
}

/**
 * Total donation amount donated across multiple forms.
 *
 * Ecommerce-agnostic lookup of total dollar amount donated via multiple
 *   donation forms.
 *
 * Looks up by multiple nids in the hopes of a single faster IN query.
 *
 * @param array $nids
 *   Node IDs.
 * @param int|bool $start
 *   Start timestamp or FALSE for no range.
 * @param int|bool $end
 *   Ending timestamp or FALSE for no range.
 *
 * @return float|bool
 *   Total successful donation amount or FALSE if none found.
 */
function fundraiser_get_total_donations_by_nids($nids, $start = FALSE, $end = FALSE) {
  $total_donations = module_invoke_all('fundraiser_get_total_donations_by_nids', $nids, $start, $end);
  $total = isset($total_donations[0]) ? $total_donations[0] : FALSE;
  return $total;
}

/**
 * Implements hook_action_info().
 */
function fundraiser_action_info() {
  return array(
    '_fundraiser_gateway_switch_action' => array(
      'description' => t('Gateway Bulk Switch'),
      'label' => t('Switch the gateway configurations of multiple forms at once.'),
      'type' => 'node',
      'configurable' => TRUE,
      'triggers' => array('any'),
    ),
  );
}

/**
 * An action to change the gateway of a node
 */
function _fundraiser_gateway_switch_action($node, $context = array()) {
  $orig_config = $node->gateways;
  // Only update the methods that have been selected
  foreach ($context['update_methods'] as $method) {
    $node->gateways[$method] = $context['gateways'][$method];

    // If we're updating the default setting
    if (!empty($context['update_default']) && !empty($context['gateways']['_default'])) {
      $node->gateways[$method]['default'] = ($context['gateways']['_default'] == $method) ? 1 : 0;
    }
    // Else use the original setting, if not in the original setting then set it to 0
    else {
      $node->gateways[$method]['default'] = !empty($orig_config[$method]['default']) ? $orig_config[$method]['default'] : 0;
    }

    // If we're updating the weights
    if (!empty($context['update_weights'])) {
      $node->gateways[$method]['weight'] = $context['gateways'][$method]['weight'];
    }
    // Else use the original setting, if not in the original setting then set it to 0
    else {
      $node->gateways[$method]['weight'] = !empty($orig_config[$method]['weight']) ? $orig_config[$method]['weight'] : 0;
    }
  }

  _fundraiser_update_fundraiser($node);
}

/**
 * Configuration form for the gateway switching action
 */
function _fundraiser_gateway_switch_action_form($context) {
  $gateways = _fundraiser_gateway_info();

  if (empty($gateways)) {
    return array();
  }

  // Create an array of available payment methods
  foreach ($gateways as $gateway) {
    $types = isset($gateway['payment_method']) ? $gateway['payment_method'] : array();
    foreach ($types as $type) {
      $methods[$type] = $type;
    }
  }

  // Checkboxes to select which payment methods will be updated
  $form['update_methods'] = array(
    '#title' => 'Payment Methods to Update',
    '#description' => t('Select the payment methods to update. Only select a payment method if you want its settings to be changed on all the forms.'),
    '#type' => 'checkboxes',
    '#options' => $methods,
  );

  // Option to update the default method across all the forms
  $form['update_default'] = array(
    '#title' => 'Update the default method',
    '#description' => t('Check this to change the default method across all these forms.'),
    '#type' => 'checkbox',
    '#return_value' => 1,
  );

  // Option to update the ordering accross all the forms
  $form['update_weights'] = array(
    '#title' => 'Update the ordering',
    '#description' => t('Check this to change the ordering of methods across all these forms.'),
    '#type' => 'checkbox',
    '#return_value' => 1,
  );

  $fieldset = array(
    '#type' => 'fieldset',
    '#title' => t('Payment methods'),
    '#description' => t('Enable donation form payment methods and their corresponding gateways.'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => TRUE,
    '#theme' => 'fundraiser_form_payment_methods',
  );

  $configuration = variable_get('fundraiser_payment_method_config_defaults', array());
  $form['gateways'] = _fundraiser_form_payment_method_config_fieldset($gateways, $configuration, $fieldset, 'gateways');

  foreach ($methods as $method) {
    foreach (element_children($form['gateways'][$method]) as $field_name) {
      // Add states to each config field to disable it if that payment method hasn't been selected
      $form['gateways'][$method][$field_name]['#states'] = array(
        'disabled' => array(
          ':input[name="update_methods[' . $method . ']"]' => array('checked' => FALSE),
        ),
      );
    }

    // Add states to hide the default and weight fields if that option isn't checked
    $form['gateways'][$method]['_default']['#states']['visible'][] = array(':input[name="update_default"]' => array('checked' => TRUE));
    $form['gateways'][$method]['weight']['#states']['visible'][] = array(':input[name="update_weights"]' => array('checked' => TRUE));
  }

  return $form;
}

/**
 * Validate handler for the gateway switch action form
 */
function _fundraiser_gateway_switch_action_validate($form, $form_state) {
  $update_methods = array_filter($form_state['values']['update_methods']);
  // Ensure at least one method has been selected
  if (empty($update_methods)) {
    form_set_error('update_methods', 'Please select at least one payment method.');
    return;
  }

  // If updating the default method ensure an enabled payment method is selected as default
  $default_enabled = FALSE;
  if (!empty($form_state['values']['update_default'])) {
    foreach ($update_methods as $method) {
      if ($form_state['values']['gateways'][$method]['status'] == 1 && $form_state['values']['gateways']['_default'] == $method) {
        $default_enabled = TRUE;
      }
    }
    if (!$default_enabled) {
      form_set_error('update_default', "You've selected to update the default method but haven't chosen an enabled method.");
    }
  }
}

/**
 * Submit handler for the gateway switch action form
 */
function _fundraiser_gateway_switch_action_submit($form, $form_state) {
  return array(
    'update_methods' => array_filter($form_state['values']['update_methods']),
    'update_default' => $form_state['values']['update_default'],
    'update_weights' => $form_state['values']['update_weights'],
    'gateways' => $form_state['values']['gateways'],
  );
}
/**
 * Implements hook_cron.
 * Needed for gateway test mode status check.
 */
function fundraiser_cron() {
  if (module_exists("rules")) {
    $rule = rules_config_load('rules_gateway_test_mode_alert');
    if (!empty($rule->active) && in_array('fundraiser_gateway_test_mode_detected', $rule->events())) {
      fundraiser_gateway_status_check();
    }
  }
}

/**
 * Test to see if a published donation form's gateway is non-live
 * Send alert ot admin if so.
 */
function fundraiser_gateway_status_check() {
  $bad_gateways = array();
  $gateways = _fundraiser_gateway_info();
  //grab all fundraiser nodes along with publication status
  $fundraisers = db_query('SELECT f.nid, f.gateways, n.status FROM {fundraiser} f INNER JOIN {node} n on n.nid = f.nid');

  foreach ($fundraisers as $fundraiser) {
    $fundraiser->gateways = unserialize($fundraiser->gateways);
    foreach($fundraiser->gateways as $type => $gateway) {
      $global_status = FALSE;
      if (!empty($gateway['id']) && $gateway['status'] == 1) {
        //grab the rules_config settings
        $fundraiser->gateways[$type]['gateway_details'] = isset($gateways[$gateway['id']]['gateway_details']) ? $gateways[$gateway['id']]['gateway_details'] : FALSE;
        //detect disabled or unconfigured gateways
        if ($fundraiser->gateways[$type]['gateway_details'] === FALSE) {
          $global_status = array('disabled');
        }
        else if (empty($fundraiser->gateways[$type]['gateway_details']['settings'])) {
          $global_status = array('unconfigured');
        }

        if (empty($global_status)) {
          $status = module_invoke_all("fundraiser_gateway_status_cron_check", $fundraiser->gateways[$type]['gateway_details']);
          if (!empty($status)) {
            $global_status = $status;
          }
        }
        //set up the token values for the alert
        if ($fundraiser->status == 1 &&  !empty($global_status[0]) && $global_status[0] != 'live') {
          $bad_gateways[$gateway['id']]['status'] = $global_status[0];
          $bad_gateways[$gateway['id']]['urls'][] = url('node/' . $fundraiser->nid, array('absolute' => TRUE));
          $bad_gateways[$gateway['id']]['type'] = $type;
        }
      }
    }
  }
  //build the info
  foreach ($bad_gateways as $id => $gateway) {
    //prepare the node urls for tokens
    $nodes = implode("\n\r", $gateway['urls']);
    //get the edit link for token
    $pos = strpos($id, '|');
    if ($pos !== FALSE) {
      $name = substr($id, $pos + 1);
      $edit_link = url('admin/commerce/config/payment-methods/manage/' . $name, array('absolute' => TRUE));
    }
    else {
      //this may never happen. but  you never know.
      $edit_link = t('(There was a problem determining the correct link. See below for additional info.)');
    }
    _fundraiser_gateway_status_alert($nodes, $gateway['type'], $id, $gateway['status'], $edit_link);
  }
}

function _fundraiser_gateway_status_alert($nodes, $method_type, $gateway_id, $status, $edit_link) {
  if (module_exists("rules")) {
    rules_invoke_event("fundraiser_gateway_test_mode_detected", $nodes, $method_type, $gateway_id, $status, $edit_link);
    watchdog('fundraiser', 'A test mode gateway configuration has been detected on a live donation form. Gateway: %gateway. Type: %type, Donation forms: %nodes', array('%gateway' => $gateway_id, '%type' => $method_type, '%nodes' => $nodes), WATCHDOG_EMERGENCY);

  }
}

/**
 * Get the relevant currency data array from a donation enabled node.
 *
 * @param stdClass $node
 *   The donation enabled node.
 *
 * @param array
 *   The currency data as an associative array. Includes keys such as 'name',
 *   'code', 'symbol', and others provided by Drupal Commerce.
 */
function fundraiser_get_currency_from_node($node) {
  try {
    // See if we have the currency field on the node.
    // If we don't then entity_metadata_wrapper will throw an exception.
    $wrapper = entity_metadata_wrapper('node', $node);
    $currency_code = $wrapper->field_fundraiser_currency->value();

    $currency = commerce_currency_load($currency_code);
    // If that currency doesn't exist, use the site default.
    if (!is_array($currency)) {
      $currency = commerce_currency_load();
    }
  }
  catch (Exception $e) {
    // Load the default currency as set by Commerce.
    $currency = commerce_currency_load();
  }

  return $currency;
}

/**
 * Retrieves and formats the currencies for a form select element.
 *
 * @return array
 *   The options array for a select form element.
 */
function fundraiser_currency_field_get_currency_options() {
  $options = array();

  foreach (commerce_currencies(TRUE, TRUE) as $currency_code => $currency) {
    $options[$currency_code] = t('@code - !name', array('@code' => $currency['code'], '!name' => $currency['name']));

    if (!empty($currency['symbol'])) {
      $options[$currency_code] .= ' - ' . check_plain($currency['symbol']);
    }
  }

  return $options;
}

/**
 * Implements hook_springboard_admin_alias_patterns().
 */
function fundraiser_springboard_admin_alias_patterns() {
  return array(
    'admin/commerce/config/currency' => array(
      'path' => array(
        'regex' => '|^/admin/commerce/config/currency|',
        'replacement' => 'admin/commerce/config/currency',
      ),
      'alias' => array(
        'regex' => '|^springboard/settings/config/currency|',
        'replacement' => 'springboard/settings/config/currency',
      ),
    ),
  );
}

/**
 * Implements hook_springboard_admin_admin_menu_items_alter().
 */
function fundraiser_springboard_admin_admin_menu_items_alter(&$items) {
  $items['admin/springboard/settings']['_children']['admin/springboard/settings/config']['_children']['admin/commerce/config/currency'] = array(
    'link_path' => 'admin/commerce/config/currency',
    'link_title' => 'Manage Currencies',
    'menu_name' => 'springboard_admin_menu',
    'expanded' => 0,
    'customized' => 1,
    'weight' => 0,
  );
}

/**
 * Log that a donation has processed and some other details for Log Analysis.
 *
 * @param object $donation
 *   The donation object.
 * @param array $log
 *   Additional log details, should include start/end times, and the type of transaction: charge, refund.
 */
function fundraiser_log_donation_processing($donation, $log = array()) {
  // Calculate the execution time.
  $exec_time = round($log['end'] - $log['start'], 4);

  // Setup the gateway details, the gateway name and config (rule name) are contained in the id.
  list($gateway, $gateway_config) = explode('|', $donation->gateway['id']);

  $pieces = array(
    'datetime',
    'category',
    'unique_transaction_id',
    'client_identifier',
    'payment_gateway',
    'payment_gateway_config',
    'transaction_type',
    'transaction_total_exec_time',
    'donation_value',
    'donation_currency',
    'country',
    'origin_ip',
    'success',
    'reference_charge',
  );

  $message = '|%' . implode('|%', $pieces);

  $variables = array(
    '%datetime' => date('c', $log['start']),
    '%category' => 'INFO',
    '%unique_transaction_id' => $donation->did,
    '%client_identifier' => $donation->uid,
    '%payment_gateway' => $gateway,
    '%payment_gateway_config' => $gateway_config,
    '%transaction_type' => $log['transaction_type'],
    '%transaction_total_exec_time' => $exec_time,
    '%donation_value' => !empty($donation->donation['amount']) ? $donation->donation['amount'] : '0.00',
    '%donation_currency' => !empty($donation->donation['currency']['code']) ? $donation->donation['currency']['code'] : 'N/A',
    '%country' => !empty($donation->donation['country']) ? $donation->donation['country'] : 'N/A',
    '%origin_ip' => ip_address(),
    '%success' => isset($donation->result['success']) ? (int) $donation->result['success'] : 0,
    '%reference_charge' => isset($donation->reference_charge) ? (int) $donation->reference_charge : 0,
  );

  watchdog('fundraiser_donation_tracker', $message, $variables, WATCHDOG_INFO);
}

/**
 * Clean up the input for an amount field.
 *
 * @param string $amount
 *   The amount entered from the submission.
 *
 * @return string
 *   The input amount stripped of any values other than a decimal point.
 */
function _fundraiser_amount_value_sanitize($amount) {
  return preg_replace('/[^\d\.]/i', '', $amount);
}

/**
 * Implements hook_springboard_node_expire_expiration_message().
 */
function fundraiser_springboard_node_expire_node_view_alter(&$node) {
  $node->content['webform']['#access'] = FALSE;
}

/**
 * Load the card on file card data for a donation.
 *
 * @param object $donation
 *   Fundraiser donation object.
 * @param bool $active
 *   Flag to select only active cards, defaults to TRUE.
 *
 * @return object
 *   Card on file card entity
 *
 * @todo This is just a copy of `_fundraiser_commerce_donation_cardonfile_card`
 * which needs to be removed and any instances replaced with this function.
 */
function _fundraiser_donation_cardonfile_card($donation, $active = TRUE) {
  // If this donation has the cardonfile value set in its data array, load the
  // card data from that.
  if (!empty($donation->data['cardonfile'])) {
    return commerce_cardonfile_load($donation->data['cardonfile']);
  }

  // Allow modules to provide their own card on file profile field values.
  if (!empty($donation->gateway['cardonfile callback'])) {
    $cardonfile_fields = $donation->gateway['cardonfile callback']($donation);
  }
  // If this is a credit purchase use the default credit function.
  elseif ($donation->donation['payment_method'] == 'credit') {
    module_load_include('inc', 'fundraiser_commerce', 'includes/fundraiser_commerce.credit_card');
    $cardonfile_fields = _fundraiser_commerce_credit_card_cardonfile_fields($donation);
  }

  if (empty($cardonfile_fields)) {
    return FALSE;
  }

  return _fundraiser_cardonfile_match($cardonfile_fields, $active);
}

/**
 * Search the card on file table for a record.
 *
 * @param array $fields
 *    Array of fields to search card on file table.
 *
 * @return object
 *    Card on file card entity or FALSE if no record.
 *
 * @todo This is a copy of `_fundraiser_commerce_cardonfile_match` which needs
 * to be removed and any instances replaced with this function.
 */
function _fundraiser_cardonfile_match($fields, $active = TRUE) {
  // Query for the card on file profile using the provided values.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_cardonfile')
    ->propertyCondition('uid', $fields['uid'])
    ->propertyCondition('instance_id', $fields['instance_id'])
    ->propertyCondition('card_number', $fields['card_number']);

  if (!empty($fields['card_exp_month'])) {
    $query->propertyCondition('card_exp_month', $fields['card_exp_month']);
  }

  if (!empty($fields['card_exp_year'])) {
    $query->propertyCondition('card_exp_year', $fields['card_exp_year']);
  }

  if ($active) {
    $query->propertyCondition('status', TRUE);
  }

  $result = $query->execute();

  if (isset($result['commerce_cardonfile'])) {
    $ids = array_keys($result['commerce_cardonfile']);
    return commerce_cardonfile_load($ids[0]);
  }
  else {
    return FALSE;
  }
}

/**
 * Returns a form for updating billing information.
 *
 * @param array $form
 *   The form.
 * @param array &$form_state
 *   The form state.
 * @param array $data
 *   An array of data values:
 *   - "update billing": (boolean|optional) TRUE if you want this module to
 *   handle the validation and updating of billing information. If FALSE, the
 *   module calling this function is expected to handle the billing updating
 *   information itself.
 *   - "update cardonfile": (boolean|optional) TRUE if you would like to
 *   automatically add the necessary validation and submission handlers for
 *   updating a cardonfile card.
 *   - "card": (object|optional) The card object used to update the cardonfile
 *   card record. Useful if you want to override the card that will be updated
 *   as determined by $form_state['card'].
 *   - "calling module": (string|optional) The name of the module calling this
 *   function. Required if you would like to use the more granular preprocess,
 *   alter, and postprocess hooks called by this function.
 *   - "donation": (object|required) The donation object.
 *   - "payment fields": (array|optional) A form render array which will replace
 *   the "payment fields".
 *
 * @return array
 *   The form element.
 */
function fundraiser_update_billing_form($form, &$form_state, $data) {
  // Merge defaults with $data.
  $defaults = array(
    'update billing' => TRUE,
    'update cardonfile' => TRUE,
    'calling module' => 'fundraiser',
    'donation' => NULL,
    'card' => NULL,
  );
  $data = array_replace_recursive($defaults, $data);

  // Allow other modules to stop the process if something doesn't meet one of
  // their conditions. If return value is empty, we assume we can continue.
  // Otherwise we expect a form render array to return to the calling method.
  $functions = array(
    'fundraiser_update_billing_form_preprocess',
  );
  // If the 'calling module' array element is set, also provide a more granular
  // hook for modules to hook into. This granular hook name will be
  // `fundraiser_update_billing_form__{calling module}__preprocess`.
  if (isset($data['calling module']) && !empty($data['calling module'])) {
    $functions[] = sprintf('fundraiser_update_billing_form__%s__preprocess', $data['calling module']);
  }
  foreach ($functions as $function) {
    $continue = module_invoke_all($function, $form, $form_state, $data);
    if (!empty($continue)) {
      return $continue;
    }
  }

  $fundraiser_path = drupal_get_path('module', 'fundraiser');
  $form['#attached']['js'] = array(
    $fundraiser_path . '/js/jquery.alphanumeric.min.js',
    $fundraiser_path . '/js/jquery.validate.min.js',
    $fundraiser_path . '/js/donation_validation.js',
  );

  // Add the validation configuration settings array.
  $form_validation_js = _fundraiser_donation_form_js_validation_config($data['donation']->node);
  if (!empty($form_validation_js)) {
    $form['#attached']['js'][] = array(
      'data' => array('fundraiser' => array('js_validation_settings' => $form_validation_js)),
      'type' => 'setting',
    );
  }

  $form['#attributes']['class'][] = 'fundraiser-donation-form';
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $data['donation']->uid,
  );

  $field_info = _fundraiser_field_info();
  // The parts we need to allow for updating: donor info, billing and credit
  // card.
  $form['billing_information'] = array(
    '#type' => 'fieldset',
    '#title' => t('Billing Address'),
    '#attributes' => array('id' => 'billing-address'),
  );
  $billing_fields = array_merge($field_info['donor_information'], $field_info['billing_information']);
  foreach (element_children($billing_fields) as $field_key) {
    $field = $billing_fields[$field_key];
    $form['billing_information'][$field_key] = _fundraiser_create_field_from_info($field_key, $field, $data['donation']->donation);
  }

  // CC info.
  $form['payment_method'] = array(
    '#type' => 'hidden',
    '#value' => $data['donation']->donation['payment_method'],
  );
  $form['payment_fields'] = array(
    '#type' => 'fieldset',
    '#title' => 'Payment Information',
    '#attributes' => array('id' => 'credit-card-info'),
    '#tree' => TRUE,
  );
  $form['payment_fields'][$data['donation']->donation['payment_method']] = array(
    '#type' => 'fieldset',
    '#attributes' => array('id' => 'credit-card-info'),
  );

  // Pull the gateway form from the donation gateway.
  // Once set a gateway CANNOT be changed on a donation series.
  // Check against the gateway config for a specific form to go with this
  // payment gateway.
  if (isset($data['donation']->gateway['form callback'])) {
    $form_func = $data['donation']->gateway['form callback'];
    if (function_exists($form_func)) {
      $form['payment_fields'][$data['donation']->donation['payment_method']] += $form_func($data['donation']->donation['payment_method']);
    }
  }

  $form_state['op'] = 'update';

  $form['actions']['submit']['#type'] = 'submit';
  $form['actions']['submit']['#value'] = t('Save changes');
  $form['#validate'] = array();

  $form['#donation'] = $data['donation'];

  // Make the card number and cvv optional by default.
  $form['#attached']['js'][3]['data']['fundraiser']['js_validation_settings']['card_cvv']->required = FALSE;
  $form['#attached']['js'][3]['data']['fundraiser']['js_validation_settings']['card_number']->required = FALSE;

  if (!empty($data['card'])) {
    $form_state['card'] = $data['card'];
  }

  // If the "update cardonfile" element is non-empty, add the cardonfile
  // validation and submission handlers.
  if ($data['update cardonfile']) {
    $use_cardonfile = FALSE;
    if (!empty($data['card'])) {
      $use_cardonfile = TRUE;
    }
    elseif (($card = _fundraiser_donation_cardonfile_card($data['donation'])) !== FALSE) {
      $form_state['card'] = $data['card'] = $card;
      $use_cardonfile = TRUE;
    }

    if ($use_cardonfile) {
      // Using this instead of form_load_include because if this function isn't
      // called from a form constructor (fundraiser_sustainers), the include
      // isn't included.
      $form_state['build_info']['files']["commerce_cardonfile:includes/commerce_cardonfile.pages.inc"] = array(
        'type' => 'inc',
        'module' => 'commerce_cardonfile',
        'name' => 'includes/commerce_cardonfile.pages',
      );
      $form['#validate'][] = '_fundraiser_update_billing_form_commerce_cardonfile_card_form_alter_validate';
      $form['#validate'][] = 'commerce_cardonfile_card_form_validate';
      $form['actions']['submit']['#submit'][] = '_fundraiser_update_billing_form_commerce_cardonfile_card_form_submit';
    }
    elseif (empty($cardonfile)) {
      if (!function_exists('_fundraiser_commerce_credit_card_pane_values')) {
        module_load_include('module', 'fundraiser_commerce');
      }

      $stored_card = _fundraiser_commerce_credit_card_pane_values($data['donation']);

      if (empty($stored_card)) {
        drupal_set_message(t("A request to access a cardonfile card was made but either no matching card was available, or the card's gateway does not support the cardonfile module."), 'warning', FALSE);
      }
      else {
        $data['payment_fields']['credit']['expiration_date']['card_expiration_month']['#default_value'] = $stored_card['credit_card']['exp_month'];
        $data['payment_fields']['credit']['expiration_date']['card_expiration_year']['#default_value'] = $stored_card['credit_card']['exp_year'];
      }
    }
  }

  // Set any payment information from the $data variable.
  if (isset($data['payment_fields'])) {
    $form['payment_fields'] = array_replace_recursive($form['payment_fields'], $data['payment_fields']);
  }

  if (empty($form_state['donation'])) {
    $form_state['donation'] = $data['donation'];
  }

  // Allow other modules to make any further alterations to this form before we
  // finish with our own stuff.
  $functions = array(
    'fundraiser_update_billing_form',
  );
  if (!empty($data['calling module'])) {
    $functions[] = sprintf('fundraiser_update_billing_form__%s_', $data['calling module']);
  }
  foreach ($functions as $function) {
    drupal_alter($function, $form, $form_state, $data);
  }

  // If the "update billing" element is non-empty, add validation and submission
  // handlers that will validate and update the billing information. This
  // defaults to TRUE and is only FALSE if the calling module will handle this
  // itself.
  if ($data['update billing']) {
    $form['#validate'][] = 'fundraiser_update_billing_form_validate';
    $form['actions']['submit']['#submit'][] = 'fundraiser_update_billing_form_submit';
  }

  $form['#calling_module'] = empty($data['calling module']) ? 'fundraiser' : $data['calling module'];
  fundraiser_display_form_fields(empty($data['calling module']) ? 'fundraiser' : $data['calling module'], $form, $form_state);

  // And finally, call a post process hook for any modules that want to alter
  // the final output of the form, knowing we won't alter anything they do from
  // here on out.
  $functions = array(
    'fundraiser_update_billing_form_postprocess',
    sprintf('fundraiser_update_billing_form__%s__postprocess', $data['calling module']),
  );
  foreach ($functions as $function) {
    if (count(module_implements($function))) {
      $form = module_invoke_all($function, $form, $form_state, $data);
    }
  }

  return $form;
}

/**
 * Validation handler for commerce_cardonfile handling.
 *
 * Sets some array elements so the cardonfile module can correctly validate and
 * submit.
 *
 * @see fundraiser_quick_donate_form_commerce_cardonfile_card_form_alter
 */
function _fundraiser_update_billing_form_commerce_cardonfile_card_form_alter_validate(&$form, &$form_state) {
  $input = $form_state['input'];
  $values = &$form_state['values'];

  $card = $form_state['card'];
  // Ensure card number and cvv are set if expiration is changed.
  if ($card->card_exp_month != $values['payment_fields']['credit']['expiration_date']['card_expiration_month'] || $card->card_exp_year != $values['payment_fields']['credit']['expiration_date']['card_expiration_year']) {
    if (empty($values['payment_fields']['credit']['card_number'])) {
      form_set_error('payment_fields][credit][card_number', t('Please verify your card number to change the expiration date.'));
    }
    if (empty($values['payment_fields']['credit']['card_cvv'])) {
      form_set_error('payment_fields][credit][card_cvv', t('Please verify your card CVV to change the expiration date.'));
    }
  }

  $values['credit_card']['owner'] = $input['first_name'] . ' ' . $input['last_name'];
  $values['credit_card']['exp_month'] = $values['payment_fields']['credit']['card_expiration_month'] = $values['payment_fields']['credit']['expiration_date']['card_expiration_month'] = sprintf('%02d', $input['payment_fields']['credit']['expiration_date']['card_expiration_month']);
  $values['credit_card']['exp_year'] = $values['payment_fields']['credit']['expiration_date']['card_expiration_year'] = $values['payment_fields']['credit']['card_expiration_year'] = $input['payment_fields']['credit']['expiration_date']['card_expiration_year'];

  $form['credit_card']['number']['#default_value'] = $form_state['card']->card_number;
  if (!empty($values['payment_fields']['credit']['card_number'])) {
    $_SESSION['card_number'] = $values['credit_card']['number'] = $values['payment_fields']['credit']['card_number'];
  }
  else {
    $_SESSION['card_number'] = $values['credit_card']['number'] = $values['payment_fields']['credit']['card_number'] = $form_state['card']->card_number;
  }

  $form['credit_card']['code'] = $values['payment_fields']['credit']['card_cvv'];
  $values['credit_card']['cardonfile_instance_default'] = $form_state['card']->instance_default;
}

/**
 * Submit callback for fundraiser_update_billing_form().
 *
 * Copy of commerce_cardonfile_card_form_submit() from commerce_cardonfile.pages
 * .inc, needed to support some functionality for the billing update form.
 *
 * @see commerce_cardonfile_card_form_submit()
 */
function _fundraiser_update_billing_form_commerce_cardonfile_card_form_submit($form, &$form_state) {
  $op = $form_state['op'];
  $card = $form_state['card'];
  $values = $form_state['values'];

  $card->card_name = $form_state['values']['credit_card']['owner'];
  $card->card_exp_month = $form_state['values']['credit_card']['exp_month'];
  $card->card_exp_year = $form_state['values']['credit_card']['exp_year'];
  if ($op == 'create') {
    $card->card_number = substr($form_state['values']['credit_card']['number'], -4);
    $card->card_type = $form_state['values']['credit_card']['type'];
  }
  $card->instance_default = $form_state['values']['credit_card']['cardonfile_instance_default'];

  // Invoke the payment method's card create/update callback.
  $payment_method = commerce_payment_method_instance_load($card->instance_id);
  $callback = $payment_method['cardonfile'][$op . ' callback'];
  $success = FALSE;

  // If updating and CC number is empty, mark $success as TRUE since the
  // callback function shouldn't be called.
  if ($op == 'update' && (empty($values['credit_card']['number']) || $values['credit_card']['number'] == $card->card_number)) {
    $success = TRUE;
  }

  if (function_exists($callback) && !$success) {
    $callback_return = $callback($form, $form_state, $payment_method, $card);
    if ($callback_return) {
      if ($op == 'create') {
        $card_save = $callback_return;
        $confirm_message = t('A new card has been added.');
      }
      else {
        $card_save = $card;
        $confirm_message = t('The card has been updated.');
      }
      commerce_cardonfile_save($card_save);
      drupal_set_message($confirm_message);
      $form_state['values']['cardonfile']['old_card'] = clone $card;
      $form_state['values']['cardonfile']['card'] = $card_save;
      $success = TRUE;
    }
  }

  if (!$success) {
    if ($op == 'create') {
      drupal_set_message(t('We encountered an error attempting to save your card data. Please try again and contact us if this error persists.'), 'error');
    }
    else {
      drupal_set_message(t('We encountered an error attempting to update your card data. Please try again and contact us if this error persists.'), 'error');
    }
  }
  $form_state['redirect'] = 'user/' . $card->uid . '/cards';
}

/**
 * Helper function, generate fields from given field_info.
 */
function _fundraiser_create_field_from_info($field_key, $field_info, $data) {
  $field = array(
    '#type' => $field_info['#type'],
    '#title' => t('@title', array('@title' => $field_info['#title'])),
    '#required' => (isset($field_info['#required']) && $field_info['#required'] == 1) ? TRUE : FALSE,
    '#default_value' => !isset($data[$field_key]) ? '' : $data[$field_key],
  );
  if ($field_info['#type'] == 'select') {
    $options = array();
    $items = $field_info['#extra']['items'];
    $items = explode("\n", $items);
    foreach ($items as $item) {
      $items_values = explode('|', $item);
      $key = trim($items_values[0]);
      $label = isset($items_values[1]) ? trim($items_values[1]) : $key;
      if (!empty($key)) {
        $options[$key] = $label;
      }
    }
    $field['#options'] = $options;
    $field['#multiple'] = (isset($field_info['#extra']['multiple']) && $field_info['#extra']['multiple'] == 1) ? TRUE : FALSE;
  }
  return $field;
}

/**
 * Afterbuild for the billing form.
 */
function fundraiser_update_billing_form_after_build($form, &$form_state) {
  return fundraiser_donation_form_after_build($form, $form_state);
}

/**
 * Form validation handler for billing address update form.
 */
function fundraiser_update_billing_form_validate($form, &$form_state) {
  $submission_fields = $form_state['values'];
  $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields);

  if (form_get_errors() || $errors) {
    drupal_set_message(t('Unable to update credit card information.'));
  }
}

/**
 * Form submit handler for billing address update form.
 */
function fundraiser_update_billing_form_submit($form, &$form_state) {
  $donation = $form['#donation'];
  $submission_fields = $form_state['values'];
  $donation->donation = array_merge($donation->donation, $submission_fields);
  $donation->update_billing = TRUE;
  $donation->update_payment = TRUE;
  fundraiser_donation_update($donation);
}

/**
 * Helper function to get donation IDs by user ID.
 */
function fundraiser_donation_get_donations_by_uid($uid, $limit = 0, $order_by = 'DESC', $gateway = NULL, $card_id = NULL) {
  $query = db_select('fundraiser_donation', 'fd')
    ->fields('fd')
    ->condition('uid', $uid, '=');
  if (!empty($gateway)) {
    $query->condition('gateway', $gateway, '=');
  }
  if (!empty($card_id)) {
    $query->condition('card_id', $card_id, '=');
  }
  $query = $query->range(0, $limit)
    ->orderBy('did', $order_by)
    ->execute();
  if (!$query->rowCount()) {
    return FALSE;
  }
  $donation_record = $query->fetchObject();
  return fundraiser_donation_get_donation($donation_record->did, FALSE, $donation_record);
}

/**
 * Helper function to get latest donation ID by user ID.
 */
function fundraiser_donation_get_newest_donation_by_uid($uid) {
  return fundraiser_donation_get_donations_by_uid($uid, 1);
}
