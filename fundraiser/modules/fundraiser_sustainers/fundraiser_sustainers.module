<?php

/**
 * @file
 * Sustainer page callbacks for the fundraiser module.
 *
 * Why? Footprint again. Not all sites need recurring / sustainer maintained fundraising.
 * (Use this module to model behavior and actions for peer-to-peer and other fundraiser types.)
 */

require_once 'includes/fundraiser_sustainers.goals.inc';

/**
 * Implements hook_cron().
 */
function fundraiser_sustainers_cron() {
  if (variable_get('fundraiser_standalone_cron_enabled', 0)) {
    return 0;
  }
  else {
    watchdog('fundraiser_cron', 'Standard cron run.', NULL, WATCHDOG_INFO);
    fundraiser_sustainers_standalone_cron();
  }
}

/**
 * Implements hook_permission().
 */
function fundraiser_sustainers_permission() {
  return array(
    'cancel future donations' => array(
      'title' => t('Cancel future donations'),
      'description' => t('Cancel future donations.'),
    ),
    'administrate recurring donations' => array(
      'title' => t('Administrate recurring donations'),
      'description' => t('Administrate recurring donations.'),
    ),
    'fastforward recurring donations' => array(
      'title' => t('Fastforward recurring donations'),
      'description' => t('Fastforward recurring donations.'),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function fundraiser_sustainers_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'fundraiser_sustainers') . '/includes',
  );
}

/**
 * Implements hook_menu().
 */
function fundraiser_sustainers_menu() {
  // Add the cron handler if it's enabled.
  $items['fundraiser_cron'] = array(
    'page callback' => 'fundraiser_sustainers_standalone_cron',
    'access callback' => 'fundraiser_sustainers_standalone_cron_access',
    'type' => MENU_CALLBACK,
  );
  // User interface.
  $items['user/%user/recurring_overview'] = array(
    'title' => 'My recurring donations',
    'page callback' => 'fundraiser_sustainers_user_overview',
    'page arguments' => array(1),
    'access callback' => 'user_edit_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  $items['fundraiser_sustainers/ffwd/%'] = array(
    'title' => 'Charge recurring donation now',
    'page callback' => 'fundraiser_sustainers_charge_now',
    'page arguments' => array(2),
    'access arguments' => array('fastforward recurring donations'),
    'type' => MENU_CALLBACK,
  );
  // Admin interface.
  $items['admin/config/system/fundraiser/recurring'] = array(
    'title' => 'Recurring donations',
    'page callback' => 'fundraiser_sustainers_admin',
    'access arguments' => array('administrate recurring donations'),
    'file' => 'fundraiser_sustainers.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/system/fundraiser/recurring/%'] = array(
    'title' => 'View donation',
    'page callback' => 'fundraiser_sustainers_admin_view',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_CALLBACK,
    'tab_parent' => 'admin/config/system/fundraiser/recurring',
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  $items['admin/config/system/fundraiser/recurring/%/view'] = array(
    'title' => 'View donation',
    'page callback' => 'fundraiser_sustainers_admin_view',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  $items['admin/config/system/fundraiser/recurring/%/edit'] = array(
    'title' => 'Edit donation',
    'page callback' => 'fundraiser_sustainers_admin_edit',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  // If Ubercart exists. Show these as a tab there as well.
  if (module_exists('uc_order')) {
    $items['admin/store/orders/%/recurring'] = array(
      'title' => 'Recurring donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/store/orders/%/recurring/recurring'] = array(
      'title' => 'View donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/store/orders/%/recurring/edit'] = array(
      'title' => 'Edit donation set',
      'page callback' => 'fundraiser_sustainers_admin_edit',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'file' => 'fundraiser_sustainers.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );
  }
  // If Commerce exists. Show these as a tab there as well.
  if (module_exists('commerce')) {
    $items['admin/commerce/orders/%/recurring'] = array(
      'title' => 'Recurring donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/commerce/orders/%/recurring/recurring'] = array(
      'title' => 'View donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/commerce/orders/%/recurring/edit'] = array(
      'title' => 'Edit donation set',
      'page callback' => 'fundraiser_sustainers_admin_edit',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'file' => 'fundraiser_sustainers.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );
  }
  return $items;
}

/**
 * Access callback for running standalone cron.
 */
function fundraiser_sustainers_standalone_cron_access() {
  if (variable_get('fundraiser_standalone_cron_enabled', 0)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Menu access callback, check if the order has recurring orders (as master id).
 */
function fundraiser_sustainers_check_access($did) {
  // First check if this even has a recurring donation.
  $donations = _fundraiser_sustainers_get_donations_recurr_by_member($did);
  if (!$donations) {
    return FALSE;
  }
  // Then check if the user is allowed.
  return user_access('administrate recurring donations');
}

/**
 * Menu callback function, determines if a user has any recurring donations.
 */
function _fundraiser_sustainers_user_has_recurring_donations($user) {
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  if (!$donations) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Menu callback for the standalone cron.
 */
function fundraiser_sustainers_standalone_cron() {
  // Process recurring donations.
  $process_recurring = TRUE;
  $processor_key_match = fundraiser_sustainers_processor_key_match();
  drupal_alter('fundraiser_sustainers_process_recurring', $process_recurring);

  if ($process_recurring && $processor_key_match) {
    fundraiser_sustainers_process_recurring_donations();
  }
  if (!$process_recurring) {
    $message = t('Standalone sustainer processing has been disabled by another module.');
    drupal_set_message($message);
  }
  if (!$processor_key_match) {
    $message = t('The fundraiser sustainer key has not been configured correctly. Recurring donations will not be processed.');
    drupal_set_message($message, 'warning');
    watchdog('fundraiser_cron', $message, NULL, WATCHDOG_CRITICAL);
  }
}

/**
 * Menu callback to ffwd a charge (for testers).
 */
function fundraiser_sustainers_charge_now($did) {
  // Given a did, update the charge date to now.
  $donation->did = $did;
  $donation->next_charge = strtotime('now');
  _fundraiser_sustainers_update_recurring($donation);
  drupal_set_message(t('The charge date for donation #@did has been advanced to @date. It will be charged on the next Fundraiser cron.',
    array('@did' => $did, '@date' => format_date(strtotime('now')))));
  // Afterwards return where we came from.
  drupal_goto( drupal_get_destination() );
}

/**
 * Implements hook_tokens_alter().
 */
function fundraiser_sustainers_tokens_alter(&$replacements, $context) {
  $type = $context['type'];
  $tokens = $context['tokens'];
  $data = $context['data'];
  $options = $context['options'];
  if ($type = 'donation' && !empty($data['donation'])) {
    $donation = $data['donation'];
    $replacements['[donation:recurs_monthly]'] = t('No');
    if (!empty($donation->donation['recurs_monthly']) && $donation->donation['recurs_monthly']) {
      $replacements['[donation:recurs_monthly]'] = t('Yes');
    }
  }
}

/**
 * Implements hook_mail().
 */
function fundraiser_sustainers_mail($key, &$message, $params) {
  switch ($key) {
    case 'fundraiser_cc_notification':
      $message['subject'] = variable_get('fundraiser_cc_exp_subject', 'Your credit card is about to expire');
      $message['body'][] = $params['fundraiser_sustainers_body'];
      break;
  }
}

/**
 * Salesforce hooks and integrations.
 */

/**
 * Implements hook_salesforce_genmap_map_fields().
 */
function fundraiser_sustainers_salesforce_genmap_map_fields(stdClass $donation, Entity $map, $node, $op) {
  // Donation properties map.
  if (isset($map->field_map['fundraiser_sustainers_map'])) {
    if (isset($map->field_map['fundraiser_sustainers_map']['full_name'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['full_name'];
      $date = strtotime('now');
      if (!empty($donation->transaction_date)) {
        $date = strtotime($donation->transaction_date);
      }
      $fields[$sf_field] =  t('Recurring Donation - !first !last (!date)',
        array(
        '!first' => $donation->donation['first_name'],
        '!last' => $donation->donation['last_name'],
        '!date' => gmdate('Y-m-d H:i:s\Z', $date),
      ));
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['amount'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['amount'];
      $fields[$sf_field] = $donation->donation['amount'];
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['contact'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['contact'];
      $fields[$sf_field] = '[Contact:user:' . $donation->uid . ']';
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['installment_period'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['installment_period'];
      $fields[$sf_field] = 'Monthly';
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['schedule_type'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['schedule_type'];
      $fields[$sf_field] = 'Multiply By';
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['installments'])) {
      $info = _fundraiser_get_donation_gateway($donation->did);
      $months = 0;
      if ($op == 'update') {
        // This created donation is the master, so passing it in to create the set.
        // We can't predict the form key for these values, so ask the gateway to provide.
        if (isset($info['expire callback'])) {
          $expiration_func = $info['expire callback'];
          $expires = $expiration_func($donation->donation);
          $month = $expires['month'];
          $year = $expires['year'];
          $start = strtotime("now");
          $stop = mktime(0, 0, 0, $month, 1, $year);
          $months = ((idate('Y', $stop) * 12) + idate('m', $stop)) - ((idate('Y', $start) * 12) + idate('m', $start));
          $create_limit = variable_get('fundraiser_sustainers_create_limit', 50);
          if ($months > $create_limit) {
            $months = $create_limit;
          }
        }
      }
      $sf_field = $map->field_map['fundraiser_sustainers_map']['installments'];
      $fields[$sf_field] = $months;
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['last_payment_date'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['last_payment_date'];
      $fields[$sf_field] = date('Y-m-d H:i:s');
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['next_payment_date'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['next_payment_date'];
      $fields[$sf_field] = date('Y-m-d H:i:s', $donation->recurring->next_charge);
    }
  }
  return $fields;
}

/**
 * Implements hook_salesforce_genmap_map_fields_alter().
 */
function fundraiser_sustainers_salesforce_genmap_map_fields_alter(&$fields, $context) {
  // Alter donations based on recurring status.
  if ($context['module'] == 'salesforce_donation') {
    $donation = $context['object'];
    $info = _fundraiser_get_donation_gateway($donation->did);
    $offsite_recurring = _fundraiser_sustainers_offsite_recurring($info['offsite_recurring'], $donation->donation['payment_method']);
    $map = $context['map'];

    // Add recurring item marker if recurring or not.
    $fields['Is_Recurring_Donation__c'] = FALSE;
    if ($donation->donation['recurs_monthly'] == TRUE) {
      $fields['Is_Recurring_Donation__c'] = TRUE;
    }

    // Add additional values for where not offsite recurring.
    if (!$offsite_recurring) {
      if (isset($map->field_map['salesforce_donation_map']['probability'])) {
        if ($donation->donation['recurs_monthly'] == TRUE && $donation->status_charged != 1) {
          $sf_field = $map->field_map['salesforce_donation_map']['probability'];
          $fields[$sf_field] = 50;
        }
      }
      if (isset($map->field_map['salesforce_donation_map']['stage'])) {
        $sf_field = $map->field_map['salesforce_donation_map']['stage'];
        if ($fields[$sf_field] == 'Posted' && $donation->donation['recurs_monthly'] == TRUE && $donation->status_charged != 1) {
          $sf_field = $map->field_map['salesforce_donation_map']['stage'];
          $fields[$sf_field] = 'Pledged';
        }
      }
      if (isset($map->field_map['salesforce_donation_map']['transaction_date'])) {
        $sf_field = $map->field_map['salesforce_donation_map']['transaction_date'];
        if ($donation->donation['recurs_monthly'] == TRUE && $donation->status_charged != 1) {
          $sf_field = $map->field_map['salesforce_donation_map']['transaction_date'];
          unset($fields[$sf_field]);
        }
      }
      // Lastly, add a field iff recurring object.
      if ($donation->donation['recurs_monthly'] == TRUE && !empty($donation->master_did) ) {
        $fields['npe03__Recurring_Donation__c'] = '[npe03__Recurring_Donation__c:recurring_donation:' . $donation->master_did . ']';
      }
      // Lastly, add a field iff recurring object.
      if ($donation->donation['recurs_monthly'] == TRUE && empty($donation->master_did) ) {
        $fields['npe03__Recurring_Donation__c'] = '[npe03__Recurring_Donation__c:recurring_donation:' . $donation->did . ']';
      }

      // If we're dealing with a sustainer charge, only send a subset of data so that other fields
      // that may have been changed in Salesforce isn't overwritten.
      if ($donation->donation['recurs_monthly'] == TRUE && $donation->status_charged == 1
         && !empty($donation->master_did) && $donation->did != $donation->master_did) {
        // @TODO: Add a configuration screen for specifying which fields get sent back
        // to Salesforce when a recurring donation charge is processed.
        $fields_to_update_on_charge = variable_get('fundraiser_sustainers_recurring_donation_charge_fields',
          array('StageName', 'Transaction_Date_Time__c', 'Probability'));
        $mapped_fields = array_keys($fields);
        // Remove fields that are not to be updated when a sustainer is charged.
        foreach ($mapped_fields as $field) {
          if (!in_array($field, $fields_to_update_on_charge)) {
            unset($fields[$field]);
          }
        }
      }

    }
  }
}

/**
 * Node API Functions. Handle for each case of node operation.
 */

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node forms.
 */
function fundraiser_sustainers_form_node_form_alter(&$form, &$form_state, $form_id) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($form['#node']->type)) {
    $form['fundraiser_settings']['fundraiser_sustainers'] = array(
      '#type' => 'fieldset',
      '#title' => t('Fundraiser Recurring Display Settings'),
      '#desciption' => t('Modify the way the recurring option is displayed on this form, or if it is even available.'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['fundraiser_settings']['fundraiser_sustainers']['recurring_setting'] = array(
      '#type' => 'select',
      '#title' => t('Display setting'),
      '#options' => array(
        'user_choice' => t('Recurring is an option on this form, but users may opt out.'),
        'always' => t('Recurring is an option on this form, and users cannot opt out.'),
        'never' => t('Recurring is not an option on this form.'),
      ),
      '#default_value' => isset($form['#node']->recurring_setting) ? $form['#node']->recurring_setting : 'user_choice',
    );
  }
}

/**
 * Implements hook_node_insert().
 * Insert a copy of the default map when a Fundraiser node is created.
 */
function fundraiser_sustainers_node_insert($node) {
  if (fundraiser_is_donation_type($node->type)) {
    // If node is a donation type.
    $sustainers_node = array(
      'nid' => $node->nid,
      'recurring_setting' => $node->recurring_setting,
    );
    _fundraiser_sustainers_update_sustainers_node($sustainers_node);
  }

  if (fundraiser_is_donation_type($node->type) && module_exists('salesforce_genmap')) {
    // And if we have a default map.
    $nid = -1;
    if (!empty($node->clone_from_original_nid)) {
      $nid = $node->clone_from_original_nid;
    }
    $map = salesforce_genmap_load_map($nid, 'fundraiser_sustainers');
    if (!empty($map)) {
      // Copy the map to the node.
      unset($map->mid);
      $map->nid = $node->nid;
      salesforce_genmap_save_map($map, 'fundraiser_sustainers');
    }
  }
}

/**
 * Implements hook_node_load().
 */
function fundraiser_sustainers_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    // If this isn't a fundraiser type, ignore it.
    if (fundraiser_is_donation_type($node->type)) {
      // Get the fundraiser information.
      $fundraiser_sustainers = _fundraiser_sustainers_get_sustainers_node_by_nid($node->nid);
      // Merge data from fundraiser with node. Default to user_choice if no entry yet.
      $nodes[$node->nid]->recurring_setting = isset($fundraiser_sustainers->recurring_setting) ?
        $fundraiser_sustainers->recurring_setting : 'user_choice';
    }
  }
}

/**
 * Implements hook_node_update().
 */
function fundraiser_sustainers_node_update($node) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($node->type)) {
    $sustainers_node = array(
      'nid' => $node->nid,
      'recurring_setting' => $node->recurring_setting,
    );
    _fundraiser_sustainers_update_sustainers_node($sustainers_node);
  }
}

/**
 * Implements hook_node_delete().
 * Insert a copy of the default map when a Fundraiser node is created.
 */
function fundraiser_sustainers_node_delete($node) {
  if (fundraiser_is_donation_type($node->type)) {
    _fundraiser_sustainers_delete_sustainers_node($node->nid);
  }
  // If node is a donation type.
  if (fundraiser_is_donation_type($node->type) && module_exists('salesforce_genmap')) {
    salesforce_genmap_delete_map($node->nid, 'fundraiser_sustainers');
  }
}

/**
 * Implements hook_salesforce_sync_complete_item().
 * Acts when the queue returns a success.
 */
function fundraiser_sustainers_salesforce_sync_complete_item($item, $result) {
  if ($result->success) {
    if ($item->operation == 'CREATE') {
      if ($item->module == 'fundraiser_sustainers' && $item->object_type == 'npe03__Recurring_Donation__c') {
        $donation = fundraiser_donation_get_donation($item->drupal_id, TRUE);
        salesforce_genmap_send_object_to_queue('fundraiser_sustainers', 'update',
          $donation->node, $donation->did, $donation, 'recurring_donation');
      }
    }
  }
}

/**
 * Implements hook_fundraiser_donation_delete().
 */
function fundraiser_sustainers_fundraiser_donation_delete($donation) {
  if ($donation->donation['recurs_monthly'] == TRUE) {
    // If a recurring donation has been cancelled, we should drop it out of the recurring table.
    _fundraiser_sustainers_delete_recurring($donation->did);
  }
}

/**
 * Helper function, kick off recurring donations for payment. Called on cron usually.
 */
function fundraiser_sustainers_process_recurring_donations() {
  // And after all of that is done, provide a hook to allow for modules to respond.
  module_invoke_all('fundraiser_donation_recurring');
  $log = array(
    'successes' => 0,
    'fails' => 0,
  );
  $donations = _fundraiser_sustainers_cron_get_recurring();
  $sustainer_key = fundraiser_sustainers_get_sustainer_key_value();

  // Loop over the found orders
  foreach ($donations as $recurring) {
    fundraiser_sustainers_process_single_recurring_donation($log, $recurring, $sustainer_key);

  }
  if ($log['successes'] > 0 || $log['fails'] > 0) {
    watchdog('fundraiser_sustainers', '!successes recurring donations processed successfully; !fails failed.',
      array('!successes' => $log['successes'], '!fails' => $log['fails']));
  }
  // And after all of that is done, provide a hook to allow for modules to respond.
  module_invoke_all('fundraiser_donation_post_recurring');
}

/**
 * Process an individual sustainer record.
 */
function fundraiser_sustainers_process_single_recurring_donation(&$log, $recurring, $sustainer_key) {
  if ($sustainer_key == $recurring->sustainer_key) {
    // Prepare a log record.
    $log_record = array(
      'did' => $recurring->did,
      'gateway' => $recurring->gateway,
      'date_processed' => time(),
      'lock_id' => $recurring->lock_id,
    );

    // Get the donation information that we need.
    $donation = fundraiser_donation_get_donation($recurring->did);

    // Set the reference charge flag to TRUE
    $donation->reference_charge = TRUE;

    // Then go through each one of these to charge.
    // Since we already created the donation (and saved any CC info at that time).
    // All we need to do is process it and respond afterwards as needed.
    fundraiser_donation_process($donation);
    if (!isset($donation->result['message'])) {
      $donation->result['message'] = '';
    }
    // The results should be at $donation->result, ready to respond to the aftermath.
    if (isset($donation->result['success']) && $donation->result['success']) {
      fundraiser_donation_success($donation);
      // Record the success.
      $log['successes']++;
      $log_record['success'] = TRUE;
    }
    else {
      $donation->result['success'] = FALSE;
      $log_record['success'] = FALSE;
      fundraiser_donation_decline($donation);
      // Record the fail.
      $log['fails']++;
    }

    // Write the log record.
    drupal_write_record('fundraiser_sustainers_log', $log_record);
  }
  else {
    // TODO: Unlock the sustainer record. Currently the lock has not been ported from D6.
    // Log the bad sustainer key check.
    watchdog('fundraiser_sustainers', 'Sustainer order id !did not processed because of sustainer key mismatch. ' .
      'Key file value (!key_file) did not match record value (!record_value).',
      array('!did' => $recurring->did, '!key_file' => $sustainer_key, '!record_value' => $recurring->sustainer_key), WATCHDOG_CRITICAL);
  }
}

/**
 * Menu callback for the my recurring payments tab of the user profile.
 */
function fundraiser_sustainers_user_overview($user, $did = NULL) {
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  if (!$donations) {
    return '<div>' . t('You have no recurring donations.') . '</div>';
  }
  else {
    if (!empty($did)) {
      return fundraiser_sustainers_edit_form($did);
    }
    else {
      // Else display the list.
      // Get the whole set of user donations (in case there's more than just this one). IIF the user owns this one.
      $donations_header = array('Amount', 'Start Date', 'Next Charge Date', 'Expire Date', 'Status');
      $donations_rows = array();
      foreach ($donations as $master_donation) {
        $this_donation = fundraiser_donation_get_donation($master_donation->master_did);
        // Grab the next to be charged for misc info.
        $remaining = _fundraiser_sustainers_get_donations_recurr_remaining($master_donation->master_did);
        $this_next_donation = $this_donation;
        if ($remaining) {
          $this_next_donation = fundraiser_donation_get_donation($remaining[0]->did);
        }
        $edit_link = l('$' . money_format('%i', $this_next_donation->donation['amount']),
          'user/' . $this_next_donation->user->uid . '/recurring_overview/' . $master_donation->master_did);
        $donations_rows[] = array(
          'data' => array(
            'amount' => $edit_link,
            'start_date' => date('m/d/y', $master_donation->start_date),
            'next_charge' => !empty($master_donation->next_charge) ? date('m/d/y', $master_donation->next_charge) : '--/--/--',
            'expire_date' => date('m/d/y', $master_donation->expire_date),
            'status' => $master_donation->status,
          ),
          'class' => array('recurring-order'),
        );
      }
      $recurring_donations = theme('table', array('header' => $donations_header, 'rows' => $donations_rows));
      return $recurring_donations;
    }
  }
}

/**
 * Implements hook_order().
 * From http://www.ubercart.org/docs/api/hook_order
 * When an order is deleted, keep fundraiser sustainer tables in sync if it's a donation too.
 */
function fundraiser_sustainers_order($op, &$arg1, $arg2) {
  switch ($op) {
    case 'delete':
      $donation = fundraiser_donation_get_donation($arg1->order_id); // Allowed use of order_id, ubercart is passing in an actual order.
      if ($donation) {
        fundraiser_donation_cancel($donation);
      }
      break;
  }
}

/**
 * Implements hook_fundraiser_field_info().
 */
function fundraiser_sustainers_fundraiser_field_info() {
  $fields['payment_information']['recurs_monthly'] = array(
    '#title' => 'Recurring Payment',
    '#type' => 'select',
    '#required' => 0,
    '#extra' => array(
      'description' => t('Selecting "Yes" will cause your credit card to be charged once per month until its expiration date.'),
      'items' => 'recurs|Yes',
      'multiple' => 'Y',
    ),
    '#allow_update' => 1,
    '#allow_respawn' => 1,
    '#reset_value' => 1,
    '#create_callback' => '_fundraiser_sustainers_recurs_monthly_field_create',
    '#display_callback' => '_fundraiser_sustainers_recurs_monthly_field_display',
    // Display callback, hide this field if the gateway Currently selected by the user is not supportive of recurring.
  );
  // Add a display callback for the gateways, to make sure the selected one is flagged for gateway support or not.
  return $fields;
}

/**
 * Field create callback, adjsut the type of the recurring page shown, based on fundraiser settings.
 */
function _fundraiser_sustainers_recurs_monthly_field_create($fundraiser, $field) {
  // If recurring_settingdon't exist, drop the recurring field.
  if (empty($fundraiser->recurring_setting)) {
    return FALSE;
  }
  // If the show other options is disallowed, unset it.
  if ($fundraiser->recurring_setting == 'always') {
    $field['#type'] = 'hidden';
    $field['#extra'] = array(
      'description' => '',
      'hidden_type' => 'hidden',
    );
    $field['#value'] = 'recurs';
  }
  // If the show other options is disallowed, unset it.
  if ($fundraiser->recurring_setting == 'never') {
    $field['#type'] = 'hidden';
    $field['#extra'] = array(
      'description' => '',
      'hidden_type' => 'hidden',
    );
    $field['#value'] = 'NO_RECURR';
  }
  // Return the field to be created. Aka: user_choice
  return $field;
}

/**
 * Field display callback, show/hide recurring feature.
 */
function _fundraiser_sustainers_recurs_monthly_field_display($form, $form_state, $field) {
  if (!isset($form['#node'])) {
    return $field;
  }
  // Supporting gateway types from the gateway on the node.
  $supporting_gateways = array();
  foreach ($form['#node']->gateways as $type => $gateway) {
    if (!empty($gateway['id'])) {
      $this_gateway = _fundraiser_gateway_info($gateway['id']);
      if (isset($this_gateway['allow_recurring']) && _fundraiser_sustainers_supports_recurring($this_gateway['allow_recurring'], $type)) {
        $supporting_gateways[] = $type;
      }
    }
  }
  // Generate the right selector for the field type.
  $selector = '.fundraiser-payment-methods input[type="radio"]';
  if (count($form['#node']->gateways) == 1) { // If only one is set, then the hidden field should be used.
    $selector = '.fundraiser-payment-methods';
  }
  // Set the states.
  $field['#states'] = array(
    'visible' => array(),
  );
  if (!empty($supporting_gateways)) {
    foreach ($supporting_gateways as $supporting_gateway) {
      $field['#states']['visible'][$selector][] = array('value' => $supporting_gateway);
      // See: http://drupal.org/node/735528
    }
  }
  else {
    $field = array(); // Else, remove the field from display entirely.
  }
  return $field;
}

/**
 * Add validation to the recurring component edit form
 */
function fundraiser_sustainers_form_webform_component_edit_form_alter(&$form, $form_state) {
  list($node, $component, $clone) =  $form_state['build_info']['args'];
  if (fundraiser_is_donation_type($node->type)
   && $component['form_key'] == 'recurs_monthly') {
    $form['#validate'][] = '_fundraiser_sustainers_form_webform_component_edit_form_validate';
  }
}

/**
 * Validates the recurring component edit form to ensure the 'recurs' value is in the Options
 */
function _fundraiser_sustainers_form_webform_component_edit_form_validate(&$form, $form_state) {
  if (strpos($form_state['values']['extra']['items'], 'recurs|') === FALSE) {
    form_set_error('extra][items', t('The Options for this field must contain the value \'recurs\'.'));
  }
}

/**
 * Implements hook_fundraiser_donation_information_table_alter().
 */
function fundraiser_sustainers_fundraiser_donation_information_table_alter(&$variables, $donation) {
  if ($donation->sid == 0) {
    $recurring = _fundraiser_sustainers_get_recurring_by_did($donation->did);
    if (!empty($recurring->master_did)) {
      $variables['rows'][] = array(t('This donation is part of a sustainer donation set.'), '');
      $master_donation = fundraiser_donation_get_donation($recurring->master_did);
      if (!empty($master_donation->did)) {
        $variables['rows'][] = array('Fundraiser parent donation submission', t('#@sid - !title',
          array('@sid' => $master_donation->sid, '!title' => l(t('View submission'),
            'node/' . $master_donation->node->nid . '/submission/' . $master_donation->sid))));
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Adds the admin form for crons to the fundraiser settings form.
 */
function fundraiser_sustainers_form_fundraiser_admin_settings_alter(&$form, &$form_state) {
  // Turn on option to process sustainer donations on own cron.
  $form['fundraiser_sustainers'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fundraiser sustainers'),
    '#description' => t('Configure fundraiser sustainers settings.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['fundraiser_sustainers']['fundraiser_sustainers_create_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Creation limit'),
    '#description' => t('How many charges max to make off a successful charge.'),
    '#default_value' => variable_get('fundraiser_sustainers_create_limit', 50),
  );
  $form['fundraiser_sustainers']['fundraiser_cron'] = array(
    '#type' => 'fieldset',
    '#title' => t('Cron settings'),
    '#description' => t('Configure cron settings.'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['fundraiser_sustainers']['fundraiser_cron']['fundraiser_standalone_cron_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable standalone cron.'),
    '#description' => t('If this option is enabled all fundraiser related cron tasks will be removed from the ' .
      'standard cron run. These tasks will need to be cronned separately via sitename/fundraiser_cron'),
    '#default_value' => variable_get('fundraiser_standalone_cron_enabled', 0),
  );
  // CC expiration message to send when sustainer donation is almost out.
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message'] = array(
    '#type' => 'fieldset',
    '#title' => t('Credit card expiration email'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_sustainers_send_email'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send expiration email'),
    '#description' => t('If this option is enabled then emails will be sent when a card is about to expire.'),
    '#default_value' => variable_get('fundraiser_sustainers_send_email', TRUE),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_cc_exp_subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Email subject'),
    '#default_value' => variable_get('fundraiser_cc_exp_subject', 'Your credit card is about to expire'),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_cc_exp_body'] = array(
    '#type' => 'textarea',
    '#title' => t('Email body'),
    '#default_value' => variable_get('fundraiser_cc_exp_body',
      'Your card ending in [donation:card_number] is about to expire on [donation:card_expiration_month]/[donation:card_expiration_year].'),
    '#description' => t('The body of the email. Available tokens are below.'),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['tokens'] = array(
    '#type' => 'fieldset',
    '#title' => t('Donor replacement tokens'),
    '#description' => t('The following tokens are available for sustainer emails.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $token_set = array('donation', 'user', 'node');
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['tokens']['token_help'] = array(
    '#type' => 'item',
    '#title' => t('Drupal tokens'),
    '#description' => theme('token_tree', array('token_types' => $token_set, 'recursion_limit' => 2, 'click_insert' => FALSE)),
  );
  $form['#submit'][] = 'fundraiser_update_cron_settings';
}

/**
 * Submit handler updates cron menu handler.
 */
function fundraiser_update_cron_settings($form, $form_state) {
  $cron_enabled = variable_get('fundraiser_standalone_cron_enabled', 0);
  if ($cron_enabled != $form_state['values']['fundraiser_standalone_cron_enabled']) {
    variable_set('fundraiser_standalone_cron_enabled', $form_state['values']['fundraiser_standalone_cron_enabled']);
    // Refresh menu cache.
    menu_rebuild();
  }
}

/**
 * Provide administrative form for editting a donation set.
 */
function fundraiser_sustainers_edit_form($did) {
  // Add js and css to the form.
  $base = drupal_get_path('module', 'fundraiser_sustainers');
  drupal_add_js($base . '/js/sustainer.js');
  drupal_add_css($base . '/css/sustainer.css');

  // Grab all associated donation information.
  $donation = fundraiser_donation_get_donation($did);

  // Check permissions, we don't want to show this to someone who doesn't have permission.
  global $user;
  if (($donation->user->uid != $user->uid) && !user_access('administrate recurring donations')) {
    return t('You do not have access to this recurring donation.');
  }

  // Grab the next to be charged for misc info.
  $remaining = _fundraiser_sustainers_get_donations_recurr_remaining($donation->did);
  $next_donation = $donation;
  if ($remaining) {
    $next_donation = fundraiser_donation_get_donation($remaining[0]->did);
  }

  // Gather further donation data.
  $remaining_donation_count = _fundraiser_sustainers_count_donations_recurr_remaining($did);
  $payment_info = '<div id="payment-info">' .
  '<h2>Recurring Payment Info</h2>' .
  '<dl>' .
  '<dt>Recurring Donation Amount</dt>' .
  '<dd>$' . money_format('%i', $next_donation->donation['amount'] ) . '</dd>' .
  '<dt>Recurring Charges Processed</dt>' .
  '<dd>' . _fundraiser_sustainers_count_donations_recurr_processed($did) . '</dd>' .
  '<dt>Recurring Charges Remaining</dt>' .
  '<dd>' . $remaining_donation_count . '</dd>' .
  '</dl>' .
  '</div>';

  $billing_info = '<div id="billing-info">' .
  '<h2>Billing Address</h2>' .
  '<address>' .
  $next_donation->donation['address'] . '<br />' .
  $next_donation->donation['city'] . ', ' . $next_donation->donation['state'] . ' ' . $next_donation->donation['zip'] .
  '</address>';
  // If the logged in viewing user is NOT the same as the donation user.
  if ($donation->user->uid != $user->uid) {
    $billing_info .= '<div id="additioanl-billing-info">Customer Account: <a href=\'/user/' . $next_donation->uid . '\'>' .
      $next_donation->user->name . '</a>' .
      '<br />Primary email: ' . $next_donation->user->mail . '</div>';
  }
  $billing_info .= '</div>';

  // Format payment schedule into a data table
  $donation_set = _fundraiser_sustainers_get_donations_recurr_by_member($did);
  $donations_header = array('Amount', 'Charge Date', 'Processed Status');

  if (user_access('fastforward recurring donations')) {
    // Add a button to fastforward this particular donation
    $donations_header[] = t('Advance Charge to Today');
  }
  $donations_rows = array();
  if ($donation_set) {
    foreach ($donation_set as $this_donation) {
      $this_donation = fundraiser_donation_get_donation($this_donation->did);
      $donations_row['amount'] = '$' . money_format('%i', $this_donation->donation['amount']);
      $donations_row['charge_date'] = date('m/d/y', $this_donation->recurring->next_charge);
      if (empty($this_donation->status)) {
        $this_donation->status = t('Pending');
      }
      $donations_row['status'] = !empty($this_donation->status_label) ? $this_donation->status_label : $this_donation->status;
      if (user_access('fastforward recurring donations')) {
        if (isset($this_donation->status_charged) && !$this_donation->status_charged) {
          // Add a button to fastforward this particular donation
          $donations_row['ffwd'] = l(t('advance charge'), 'fundraiser_sustainers/ffwd/' . $this_donation->did,
            array('query' => drupal_get_destination()) );
        }
        else {
          $donations_row['ffwd'] = t('cannot update');
        }
      }
      $donations_rows[] = $donations_row;
    }
  }
  $future_orders = theme('table', array('header' => $donations_header, 'rows' => $donations_rows));
  $future_orders = '<div id="payment-schedule">' .
  '<h2>Payment Schedule</h2>' .
  $future_orders .
  '</div>';

  // Check if this order is already cancelled.
  $cancelled = isset($next_donation->recurring->cancellation_reason) ? $next_donation->recurring->cancellation_reason : '';

  // Generate forms, or error messages as needed.
  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $donation_amount_form_array = drupal_get_form('fundraiser_sustainers_donation_amount_form', $donation, $next_donation);
    $donation_amount_form = drupal_render($donation_amount_form_array);
  }
  elseif ($remaining_donation_count == 0) {
    $donation_amount_form = t('There are no further charges for this recurring donation.');
  }
  else {
    $donation_amount_form = t('This recurring donation has been cancelled.');
  }
  $donation_amount_form = '<div id="donation-amount-form"><h2>Update Donation Amount</h2>' . $donation_amount_form . '</div>';

  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $billing_update_form_array = drupal_get_form('fundraiser_sustainers_billing_update_form', $next_donation);
    $billing_update_form = drupal_render($billing_update_form_array);
  }
  elseif ($remaining_donation_count == 0) {
    $billing_update_form = t('There are no further charges for this recurring donation.');
  }
  else {
    $billing_update_form = t('This recurring donation has been cancelled.');
  }
  $billing_update_form = '<div id="donation-billing-form"><h2>Update Your Credit Card Information</h2>' . $billing_update_form . '</div>';

  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $cancel_form_array = drupal_get_form('fundraiser_sustainers_cancel_form', $next_donation);
    $cancel_form = drupal_render($cancel_form_array);
  }
  elseif ($remaining_donation_count == 0) {
    $cancel_form = t('There are no further charges for this recurring donation.');
  }
  else {
    $cancel_form = t('This recurring donation has been cancelled. Your reason given was: %reason', array('%reason' => $cancelled));
  }
  if (user_access('cancel future donations')) {
    $cancel_form = '<div id="donation-cancel-form"><h2>Cancel Future Donations</h2>' . $cancel_form . '</div>';
  }
  else {
    $cancel_form = '';
  }
  // Put together the output.
  drupal_set_title(t('Recurring donation #@did', array('@did' => $did)));
  $parts = array($payment_info, $billing_info, $future_orders, $donation_amount_form, $billing_update_form, $cancel_form);
  return implode('', $parts);
}

/**
 * Creates a form for donation amount update.
 */
function fundraiser_sustainers_donation_amount_form($form, &$form_state, $donation, $next_donation) {
  // Abort if the gateway does not support recurring.
  $info = _fundraiser_get_donation_gateway($donation->did);
  if (!_fundraiser_sustainers_supports_recurring($info['allow_recurring'], $donation->donation['payment_method'])) {
    $form['fundraiser-sustainer-billing'] = array(
      '#markup' => '<div class="fundraiser-sustainer-no-recur-support">' .
        t('This payment gteway does not support recurring donations and cannot be updated.') .
        '</div>',
    );
    return $form;
  }

  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['min_amount'] = array(
    '#type' => 'hidden',
    '#value' => isset($donation->node->minimum_donation_amount) ? $donation->node->minimum_donation_amount : 0,
  );
  $form['fee_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Donation Amount'),
    '#size' => 10,
    '#required' => TRUE,
    '#description' => t('Your current donation amount is %amount. Minimum donation %minimum.',
      array(
        '%amount' => money_format('%i', $next_donation->donation['amount']),
        '%minimum' => money_format('%i', isset($donation->node->minimum_donation_amount) ? $donation->node->minimum_donation_amount : 0))
      ),
    '#field_prefix' => '$',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update donation amount'),
  );
  $form['#donation'] = $donation;
  return $form;
}

/**
 * Form validation handler for donation amount update form.
 */
function fundraiser_sustainers_donation_amount_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['fee_amount'])) {
    form_set_error('amount', t('Donation amount must be a valid number.'));
  }
  if ($form_state['values']['fee_amount'] < $form_state['values']['min_amount']) {
    form_set_error('amount', t('Donation amount must be greater than %minimum',
      array('%minimum' => money_format('%i', $form_state['values']['min_amount']))));
  }
}

/**
 * Form submit handler for donation amount update form.
 */
function fundraiser_sustainers_donation_amount_form_submit($form, &$form_state) {
  $amount = $form_state['values']['fee_amount'];
  $master_did = $form_state['values']['master_did'];
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  foreach ($donations as $donation) {
    $donation = fundraiser_donation_get_donation($donation->did);
    $old_amount = $donation->donation['amount'];
    $donation->donation['amount'] = $amount;
    $donation->donation['old_amount'] = $old_amount;

    // Let other modules know the amount has been updated
    $donation->update_amount = TRUE;

    fundraiser_donation_update($donation);

    // Add a comment.
    global $user;
    $username = isset($user->name) ? $user->name : 'Anonymous';
    fundraiser_donation_comment($donation, 'The amount of this gift was changed from $@old_amount to $@new_amount on @date by @username.',
      array(
      '@old_amount' => $donation->donation['old_amount'],
      '@new_amount' => $donation->donation['amount'],
      '@date' => format_date(strtotime('now')),
      '@username' => $username,
    ));
  }
  drupal_set_message(t('The amount of all future donations has been updated to @amount.', array('@amount' => $amount)));
}

/**
 * Creates form for billing address update.
 */
function fundraiser_sustainers_billing_update_form($form, &$form_state, $donation) {
  // Attach the js files
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'fundraiser') . '/js/jquery.alphanumeric.min.js',
    drupal_get_path('module', 'fundraiser') . '/js/jquery.validate.min.js',
    drupal_get_path('module', 'fundraiser') . '/js/donation_validation.js',
  );
  // Abort if the gateway does not support recurring.
  $info = _fundraiser_get_donation_gateway($donation->did);
  if (!_fundraiser_sustainers_supports_recurring($info['allow_recurring'], $donation->donation['payment_method'])) {
    $form['fundraiser-sustainer-billing'] = array(
      '#markup' => '<div class="fundraiser-sustainer-no-recur-support">' .
        t('This payment gteway does not support recurring donations and cannot be updated.') .
        '</div>',
    );
    return $form;
  }
  $form['#attributes']['class'][] = 'fundraiser-donation-form';
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $donation->uid,
  );

  // The rest of this is based on fields generated from fundraiser.
  $field_info = _fundraiser_field_info();
  // The parts we need to allow for updating: donor info, billing and credit card.
  $form['billing_information'] = array(
    '#type' => 'fieldset',
    '#title' => t('Billing Address'),
    '#attributes' => array('id' => 'billing-address'),
  );
  $billing_fields = array_merge($field_info['donor_information'], $field_info['billing_information']);
  foreach (element_children($billing_fields) as $field_key) {
    $field = $billing_fields[$field_key];
    $form['billing_information'][$field_key] = _fundraiser_sustainers_create_field_from_info($donation, $field_key, $field);
  }

  // CC info.
  $form['payment_method'] = array(
    '#type' => 'hidden',
    '#value' => $donation->donation['payment_method'],
  );
  $form['payment_fields'] = array(
    '#type' => 'fieldset',
    '#title' => 'Payment Information',
    '#attributes' => array('id' => 'credit-card-info'),
    '#tree' => TRUE,
  );
  $form['payment_fields'][$donation->donation['payment_method']] = array(
    '#type' => 'fieldset',
    '#attributes' => array('id' => 'credit-card-info'),
  );
  // Pull the gateway form from the donation gateway.
  // Once set a gateway CANNOT be changed on a donation series.
  // Check against the gateway config for a specific form to go with this payment gateway.
  if (isset($donation->gateway['form callback'])) {
    $form_func = $donation->gateway['form callback'];
    if (function_exists($form_func)) {
      $form['payment_fields'][$donation->donation['payment_method']] += $form_func($donation->donation['payment_method']);
    }
  }

  // And add a submit button.
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save changes'),
  );
  $form['#donation'] = $donation;

  // Modify form displays according to callback settings.
  // This allows any other systems to modify the available options with callbacks.
  $form['#calling_module'] = 'fundraiser_sustainers';
  fundraiser_display_form_fields('fundraiser_sustainers', $form, $form_state);

  return $form;
}

/**
 * Afterbuild for the billing form.
 */
function fundraiser_sustainers_billing_update_after_build($form, &$form_state) {
  return fundraiser_donation_form_after_build($form, $form_state);
}

/**
 * Helper function, generate fields from given field_info.
 */
function _fundraiser_sustainers_create_field_from_info($donation, $field_key, $field_info) {
  $field = array(
    '#type' => $field_info['#type'],
    '#title' => t('@title', array('@title' => $field_info['#title'])),
    '#required' => (isset($field_info['#required']) && $field_info['#required'] == 1) ? TRUE : FALSE,
    '#default_value' => $donation->donation[$field_key],
  );
  if ($field_info['#type'] == 'select') {
    $options = array();
    $items = $field_info['#extra']['items'];
    $items = explode("\n", $items);
    foreach ($items as $item) {
      $items_values = explode('|', $item);
      $key = trim($items_values[0]);
      $label = isset($items_values[1]) ? trim($items_values[1]) : $key;
      if (!empty($key)) {
        $options[$key] = $label;
      }
    }
    $field['#options'] = $options;
    $field['#multiple'] =
      (isset($field_info['#extra']['multiple']) && $field_info['#extra']['multiple'] == 1) ? TRUE : FALSE;
  }
  return $field;
}

/**
 * Form validation handler for billing address update form.
 */
function fundraiser_sustainers_billing_update_form_validate($form, &$form_state) {
  // Submission fields are keyed according to the fields in _fundraiser_field_info().
  // Select only the ones we want to validate with fundraiser.
  $submission_fields = $form_state['values'];
  // Clean up the gateway information as needed on validation.
  if (isset($form['#donation']->gateway['cleanup callback'])) {
    $validate_cleanup_func = $form['#donation']->gateway['cleanup callback'];
    if (function_exists($validate_cleanup_func)) {
      $submission_fields = $validate_cleanup_func($submission_fields);
    }
  }

  // If it's a credit card, do some generic validation.
  // This is because the gateway's validation doesn't happen during a
  // billing update.
  $credit_card_errors = array();
  if ($submission_fields['payment_method'] == 'credit') {
    // This returns an array.
    $credit_card_errors = fundraiser_commerce_generic_credit_card_validate($submission_fields['payment_fields']);
    if (count($credit_card_errors)) {
      foreach ($credit_card_errors as $form_key => $message) {
        form_set_error('payment_fields][credit][' . $form_key, $message);
      }
    }
  }

  // This returns a boolean.
  // From fundraiser.module.
  $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields);

  if (form_get_errors() || count($credit_card_errors) || $errors) {
    // We've set a form_error by now.
    drupal_set_message(t('Unable to update credit card information.'));
  }
}

/**
 * Form submit handler for billing address update form.
 */
function fundraiser_sustainers_billing_update_form_submit($form, &$form_state) {
  $master_did = $form_state['values']['master_did'];
  // We only update donations to come, not ones already processed.
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  $submission_fields = $form_state['values'];
  // Clean up the gateway information as needed on validation.
  if (isset($form['#donation']->gateway['cleanup callback'])) {
    $validate_cleanup_func = $form['#donation']->gateway['cleanup callback'];
    if (function_exists($validate_cleanup_func)) {
      $submission_fields = $validate_cleanup_func($submission_fields);
    }
  }

  // Remove unnecessary values.
  unset($submission_fields['master_did']);
  unset($submission_fields['uid']);

  // Set a flag for other modules to respond to the first order being updated in series
  $sustainer_update_first = TRUE;

  foreach ($donations as $donation) {
    // Get the original donation.
    $donation = fundraiser_donation_get_donation($donation->did);
    // Update it.
    $donation->donation = array_merge($donation->donation, $submission_fields);

    // Mark the billing information as needing to be updated.
    $donation->update_billing = TRUE;

    // Mark the payment information as needing to be updated.
    $donation->update_payment = TRUE;

    // Let other modules know this is a sustainer update
    $donation->sustainer_update = TRUE;

    // Let other modules know the first donation being updated in the series
    if ($sustainer_update_first) {
      $sustainer_update_did = $donation->did;
    }
    else {
      $donation->sustainer_update_did = $sustainer_update_did;
    }

    $donation->sustainer_update_first = $sustainer_update_first;

    // Save each donation.
    fundraiser_donation_update($donation);

    // The first donation will be used by the create recurring function
    if ($sustainer_update_first) {
      $source_donation = $donation;
    }

    // Set the first flag to false for the rest of the donations
    $sustainer_update_first = FALSE;

    // Add a comment.
    global $user;
    $username = isset($user->name) ? $user->name : 'Anonymous';
    fundraiser_donation_comment($donation, 'The card to be charged was changed on @date by @username.',
      array('@date' => format_date(strtotime('now')), '@username' => $username));
    watchdog('fundraiser_sustainers', 'Billing information updated for #@did.',
      array('@did' => $donation->did));
  }
  // Load the master donation.
  $master_donation = fundraiser_donation_get_donation($master_did);
  // Update this donation (don't save it) so we have the right parentage with the new billing.
  $master_donation->donation = array_merge($master_donation->donation, $submission_fields);
  // Create new orders based on expiration date as needed.
  // But we need to retrieve the month / year values from gateway form.
  // We can't predict the form key for these values, so ask the gateway to provide.
  if (isset($form['#donation']->gateway['expire callback'])) {
    $expiration_func = $form['#donation']->gateway['expire callback'];
    if (function_exists($expiration_func)) {
      $expires = $expiration_func($submission_fields);
      if (isset($expires['month']) && isset($expires['year'])) {
        // Set master donation amount to next recurring amount, so if we've updated amounts we get the right one.
        $master_donation->donation['amount'] = $donation->donation['amount'];
        // Create new orders.
        _fundraiser_sustainers_create_future_orders($master_donation, $expires['month'], $expires['year'], $source_donation);
      }
    }
  }
  drupal_set_message(t('Billing information successfully updated'));
}

/**
 * Create recurring donations up until the date given.
 *
 * If the recurring donations exist already update,
 * cancelling those that are past expiration.
 *
 * @param object $donation
 *   The donation that will become the master donation..
 * @param int $month
 *   The month number to stop on.  Usually the credit card expiration.
 * @param int $year
 *   The year number to stop on.  Usually the credit card expiration.
 * @param object $source_donation
 *   The donation to copy if different than the master donation.
 * @param int $start
 *   The timestamp to start from.  If not set will default to now.
 *   The first non-master donation will happen one month after the $start.
 *
 */
function _fundraiser_sustainers_create_future_orders($donation, $month, $year, $source_donation = NULL, $start = NULL) {
  // Handle the rest of the set based on the given donation.
  if (is_null($start)) {
    $start = strtotime("now");
  }

  $stop = mktime(0, 0, 0, $month, 1, $year);
  $months = ((idate('Y', $stop) * 12) + idate('m', $stop)) - ((idate('Y', $start) * 12) + idate('m', $start));
  $processed_months = 0;
  $sustainer_key = fundraiser_sustainers_get_sustainer_key_value();

  // Start counting.
  $create_limit = variable_get('fundraiser_sustainers_create_limit', 50);
  // Get existing donations, if they exist.
  $existing_recurring = _fundraiser_sustainers_get_donations_recurr_by_masterdid($donation->did);
  unset($existing_recurring[0]); // 0 is the master, we don't need to count it.
  while ($processed_months < $months && $processed_months < $create_limit) {
    $processed_months++;
    // Check if we have a donation for this next month.
    if (!isset($existing_recurring[$processed_months])) {
      // Create a new one donation from the source or master donation
      $new_donation = !empty($source_donation) ? clone $source_donation : clone $donation;
      $new_donation->sid = 0; // Not actually submitted, it's automated, so no sid.
      // Create the new donation object, but do not process it. Processing doesn't occur till cron.
      // New donation has all of the old donation information already loaded.

      // Add a flag so modules know this is being created by the sustainer system
      $new_donation->sustainer_create = TRUE;

      // Remove the reference charge flag
      unset($new_donation->reference_charge);

      fundraiser_donation_create($new_donation);
      $next_charge = strtotime('+ ' . $processed_months . ' months');

      $context = array(
        'master_did' => $donation->did,
        'did' => $new_donation->did,
      );
      // Allow other modules to adjust next_charge as needed.
      drupal_alter('fundraiser_sustainers_recurring_next_charge', $next_charge, $context);

      fundraiser_donation_comment($new_donation, 'Sustainer donation scheduled to be charged at @next_charge',
        array('@next_charge' => format_date($next_charge)));
      // After this, the donation did and donation data is set.
      // The new donation object, with new did, needs to be saved to recurring so we can grab it later.
      $recurring_donation = array(
        'master_did' => $donation->did,
        'did' => $new_donation->did,
        'next_charge' => $next_charge,
        'sustainer_key' => $sustainer_key,
      );
      // Update the recurring table.
      _fundraiser_sustainers_create_recurring($recurring_donation);
      // Load the newly created individual donation into salesforce_donation.
      if (module_exists('salesforce_genmap')) {
        $sf_donation = fundraiser_donation_get_donation($new_donation->did, TRUE);
        salesforce_genmap_send_object_to_queue('salesforce_donation', 'insert',
          $sf_donation->node, $sf_donation->did, $sf_donation, 'donation');
      }
    }
    else {
      // Unset this from the existing recurring.
      // By the time this loop is done, only recurring outside of our range wills till be in the set.
      unset($existing_recurring[$processed_months]); // This donation existed already, mark it off.
    }
  }

  // Done with the loop, everything has been created that needs to be created.
  // But now we need to remove anything that existed in the set beyond our expiration date.
  global $user;
  foreach ($existing_recurring as $key => $recurring) {
    $this_donation = fundraiser_donation_get_donation($recurring->did);
    // Cancel the donation with an informative message.
    watchdog('fundraiser', 'Donation @id was deleted by @user while updating the card expiration date.',
      array('@id' => $donation->did, '@user' => $user->name), WATCHDOG_DEBUG, NULL);
    fundraiser_donation_delete($this_donation);
  }
}

/**
 * Creates form to cancel donations.
 */
function fundraiser_sustainers_cancel_form($form, &$form_state, $donation) {
  // Only allow certain users to cancel future donations.
  $form['#access'] = user_access('cancel future donations');
  // Otherwise, provide cancel button.
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['reason'] = array(
    '#type' => 'textarea',
    '#title' => t('Reason'),
    '#default_value' => t('Please enter a brief description of why you are cancelling. ' .
      'This will help us better serve you in the future.'),
    '#maxlength' => 500,
    '#cols' => 70,
    '#rows' => 3,
    '#resizable' => FALSE,
    '#required' => TRUE,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel all future payments'),
  );
  $form['#donation'] = $donation;
  return $form;
}

/**
 * Form submit handler for cancel donations form.
 */
function fundraiser_sustainers_cancel_form_submit($form, &$form_state) {
  global $user;
  $master_did = $form_state['values']['master_did'];
  $reason = $form_state['values']['reason'];
  if (empty($reason) || $reason == t('Please enter a brief description of why you are cancelling. ' .
      'This will help us better serve you in the future.')) {
    $reason = t('No reason given.');
  }
  // Cancel the donations.
  $sustainer_donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  foreach ($sustainer_donations as $sustainer_donation) {
    $donation = fundraiser_donation_get_donation($sustainer_donation->did);
    fundraiser_donation_cancel($donation);
    watchdog('fundraiser_sustainers', 'Donation cancelled for #@did. Reason: @reason',
      array('@did' => $donation->did, '@reason' => $reason));
  }
  _fundraiser_sustainers_cancel_recurring_by_master($master_did, $reason);
  drupal_set_message(t('All future payments cancelled.'));
}

/**
 * Implements hook_fundraiser_donation_get_donation().
 */
function fundraiser_sustainers_fundraiser_donation_get_donation($donation) {
  // Add recurring data to the fundraiser donation.
  $recurring = _fundraiser_sustainers_get_recurring_by_did($donation->did);
  if ($recurring) {
    $donation->recurring = $recurring;
    // Skip this for the master donation
    if (isset($donation->recurring->master_did) && $donation->recurring->master_did != $donation->did) {
      // Use the same submission information from the original donation.
      $master_donation = fundraiser_donation_get_donation($donation->recurring->master_did);
      if (isset($master_donation->submission_data)) {
        $donation->submission_data = $master_donation->submission_data;
      }
      $donation->sid = $master_donation->sid;
      $donation->master_did = $master_donation->did;
    }
    if (empty($donation->close_date)) {
      $donation->close_date = date('Y-m-d', $donation->recurring->next_charge);
    }
    $donation->donation['recurs_monthly'] = TRUE;
  }
  else {
    $donation->donation['recurs_monthly'] = FALSE;
  }
}

/**
 * Implements hook_fundraiser_donation_create().
 */
function fundraiser_sustainers_fundraiser_donation_create($donation) {
  // If this has been flagged as a recurring donation, mark it properly so all following systems can understand.
  $recurs = FALSE;
  if (!isset($donation->donation['recurs_monthly'])) { // In case the recurs_monthly field doesn't exist.
    $donation->donation['recurs_monthly'] = FALSE;
  }
  if (is_bool($donation->donation['recurs_monthly'])) {
    $recurs = $donation->donation['recurs_monthly'];
  }
  elseif (is_array($donation->donation['recurs_monthly']) && isset($donation->donation['recurs_monthly'][0])) {
    $recurs = ($donation->donation['recurs_monthly'][0] == 'recurs') ? TRUE : FALSE;
  }
  else {
    $recurs = ($donation->donation['recurs_monthly'] == 'recurs') ? TRUE : FALSE;
  }
  // Set the value for the donation.
  $donation->donation['recurs_monthly'] = $recurs;
}

/**
 * Implements hook_fundraiser_donation_success().
 */
function fundraiser_sustainers_fundraiser_donation_success($donation) {
  // If we don't have a master id already set, check if this is a new recurring order.
  if (!isset($donation->recurring->master_did)) {
    // If this is in fact a recurring donation, then we act.
    if ($donation->donation['recurs_monthly'] == TRUE) {
      $info = _fundraiser_get_donation_gateway($donation->did);
      if (_fundraiser_sustainers_supports_recurring($info['allow_recurring'], $donation->donation['payment_method'])) { // Allows recurring
        // Then we do all the creating of offline values, table, SF object, and extra orders.
        $donation->recurring = new stdClass();
        $donation->recurring->master_did = $donation->did;
        // Add the master to the recurring table.
        $recurring_donation = array(
          'did' => $donation->did,
          'master_did' => $donation->did,
          'next_charge' => strtotime('now'),
          'gateway_resp' => 'success',
          'attempts' => 1,
        );
        // Update the recurring table.
        _fundraiser_sustainers_create_recurring($recurring_donation);
        // Now handle the recurring object, and the rest of the orders.
        if (!_fundraiser_sustainers_offsite_recurring($info['offsite_recurring'], $donation->donation['payment_method'])) { // Is not an offline recurring
          // Load the newly created recurring donation into salesforce.
          if (module_exists('salesforce_genmap')) {
            $sf_donation = fundraiser_donation_get_donation($donation->did, TRUE);
            salesforce_genmap_send_object_to_queue('fundraiser_sustainers', 'insert',
              $sf_donation->node, $sf_donation->did, $sf_donation, 'recurring_donation');
          }
          $info = _fundraiser_get_donation_gateway($donation->did);
          // This created donation is the master, so passing it in to create the set.
          // We can't predict the form key for these values, so ask the gateway to provide.
          if (isset($info['expire callback'])) {
            $expiration_func = $info['expire callback'];
            if (function_exists($expiration_func)) {
              $expires = $expiration_func($donation->donation);
              if (isset($expires['month']) && isset($expires['year'])) {
                _fundraiser_sustainers_create_future_orders($donation, $expires['month'], $expires['year']);
              }
            }
          }
        }
        else {
          // ALERT: This gateway does it's own recurring stuff, so we skipped it here.
          // But we should probably tell someone this was attempted.
          watchdog('fundraiser_sustainers', 'A offsite recurring donation was created, for master donation id #@nid',
            array('@nid' => $donation->nid));
        }
      }
      else {
        // ALERT: This gateway does not support recurring stuff, so we skipped it here.
        // But we should probably tell someone this was attempted. We have protections on the form, but they
        // are JS based to hide the form element, so we check server side too.
        watchdog('fundraiser_sustainers', 'A recurring donation for a non-recurring gateway was attempted, for master donation id #@nid',
          array('@nid' => $donation->nid));
      }
    }
  }
  else {
    // And update the sustainer table.
    db_query('UPDATE {fundraiser_sustainers} SET ' .
      'gateway_resp = \'success\', attempts = attempts + 1 ' .
      'WHERE did = :did', array(':did' => $donation->did)
    );
    // For all recurring when processed, check if we need to send a notice about the set almost done.
    if (_fundraiser_sustainers_count_donations_recurr_remaining($donation->recurring->master_did) == 1) {
      _fundraiser_sustainers_send_cc_notification($donation->recurring->master_did, $donation->uid);
    }
  }
}

/**
 * Implements hook_fundraiser_donation_decline().
 */
function fundraiser_sustainers_fundraiser_donation_decline($donation) {
  if ($donation->donation['recurs_monthly'] == TRUE) {
    // Update data internal to fundraiser. TODO move this db stuff.
    db_query('UPDATE {fundraiser_sustainers} SET ' .
      'gateway_resp = \'failed\', attempts = attempts + 1, ' .
      'next_charge = unix_timestamp(timestampadd(DAY, 1, from_unixtime(next_charge))) ' .
      'WHERE did = :did', array(':did' => $donation->did)
    );
    // Get the number of times this order has been attempted
    $attempt_count = db_query('SELECT attempts FROM {fundraiser_sustainers} WHERE did = :did',
      array(':did' => $donation->did))->fetchColumn();
    if ($attempt_count == 3) {
      // Final attempt, add debug alert.
      watchdog('fundraiser_sustainers', 'Payment for recurring donation @id has failed 3 times. ' .
        'The donation will not be submitted for payment again. Gateway message: @message',
        array('@id' => $donation->did, '@message' => $donation->result['message']), WATCHDOG_DEBUG);
    }
    else {
      // Log this failure
      watchdog('fundraiser_sustainers', 'Payment for recurring donation @id has failed @attempts times. It will be processed again in 1 day. Gateway message: @message',
        array('@id' => $donation->did, '@attempts' => $attempt_count, '@message' => $donation->result['message']), WATCHDOG_DEBUG);
    }
  }
}

/**
 * Helper function, loads the recurring donation processor key.
 */
function fundraiser_sustainers_processor_key_match() {
  static $key;
  if (!empty($key)) {
    return ($key == $_SERVER['HTTP_HOST']);
  }
  // This is to check that we have everything configured for safe charging.
  // If not, we should throw an issue about it and not try to process stuff.
  // This value is normally set in the glue module for payment.
  // Get the key and see if it matches the server's host.
  $key = fundraiser_sustainers_get_sustainer_key_value();
  if (trim($key) == trim($_SERVER['HTTP_HOST'])) {
    return TRUE;
  }

  // If we get here key is no good.
  return FALSE;
}

/**
 * Attempts to open and read the contents of the sustainer key file.
 */
function fundraiser_sustainers_get_sustainer_key_value() {
  static $value; // Cache per page load.
  if (empty($value)) {
    $value = FALSE;
    $filename = fundraiser_sustainers_sustainer_key_file_exists();
    if ($filename && $file = fopen($filename, 'r')) {
      $filesize = filesize($filename);
      if ($filesize > 0) {
        $value = trim(fread($file, $filesize));
        fclose($file);
      }
      else {
        watchdog('fundraiser_sustainers', 'Unable to read the contents of the sustainer key file @file.', array('@file' => $filename), WATCHDOG_CRITICAL);
      }
    }
    else {
      watchdog('fundraiser_sustainers', 'Unable to get the value of the sustainer key file because the file does not exist.', NULL, WATCHDOG_CRITICAL);
    }
  }
  // Return FALSE or the actual value of the key file.
  return $value;
}

/**
 * Determines if the sustainer key file exists in the file system.
 *
 * @return
 *   The filename of of the sustainer key file or FALSE if it doesn't
 *   exist.
 */
function fundraiser_sustainers_sustainer_key_file_exists() {
  $dir = module_invoke_all('fundraiser_get_credit_encryption_path');
  $dir = $dir[0];
  if (!empty($dir) && $dir !== t('Not configured, see below.')) {
    $filename = rtrim($dir, '/\\') . '/sustainer.key';
    if (file_exists($filename) && $file = fopen($filename, 'r')) {
      return $filename;
    }
  }

  return FALSE;
}

/**
 * Helper function, kicks off an email to a sustainer to remind them their credit card is about to expire.
 */
function _fundraiser_sustainers_send_cc_notification($master_did, $uid) {
  // Short circuit this email if the configuration for fundraiser says don't send it.
  if (!variable_get('fundraiser_sustainers_send_email', TRUE)) {
    return;
  }
  // Otherwise, send it.
  $user = user_load($uid);
  // Load the last remaining order so we can get some info for the email.
  $did = db_query('SELECT did FROM {fundraiser_sustainers} WHERE master_did = :master_did AND gateway_resp IS NULL LIMIT 0,1', // Coder: this is ok.
    array(':master_did' => $master_did))->fetchColumn();
  $donation = fundraiser_donation_get_donation($did);
  // Do token replacement on body.
  $body = variable_get('fundraiser_cc_exp_body',
    'Your card ending in [donation:card_number] is about to expire on [donation:card_expiration_month]/[donation:card_expiration_year].');
  $token_set = array(
    'node' => $donation->node,
    'donation' => $donation,
    'user' => $user,
  );
  $body = token_replace($body, $token_set);
  // Pass tokens as param so hook_mail has access.
  $params['fundraiser_sustainers_token_set'] = $token_set;
  $params['fundraiser_sustainers_body'] = $body;
  watchdog('fundraiser_sustainers', 'Credit card expiration email sent to @mail', array('@mail' => $user->mail), WATCHDOG_INFO);
  drupal_mail('fundraiser_sustainers', 'fundraiser_cc_notification', $user->mail, user_preferred_language($user), $params);
}

/**
 * Helper function, given a gateway determine if the gateway supports recurring donations.
 */
function _fundraiser_sustainers_supports_recurring($allow_recurring, $payment_method) {
  if (isset($allow_recurring) && !empty($allow_recurring) && in_array($payment_method, $allow_recurring)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function, given a gateway determine if the gateway supports recurring donations.
 */
function _fundraiser_sustainers_offsite_recurring($offsite_recurring, $payment_method) {
  if (isset($offsite_recurring) && !empty($offsite_recurring) && in_array($payment_method, $offsite_recurring)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Database functions.
 */

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_create_recurring($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_sustainers_get_recurring_by_did($donation['did']);
  }
  if (!$donation_data) {
    $record = $donation;
    drupal_write_record('fundraiser_sustainers', $record);
  }
  else {
    _fundraiser_sustainers_update_recurring($donation);
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_get_recurring_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_sustainers} ' .
    'WHERE did = :did',
    array(':did' => $did))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_update_recurring($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_sustainers_get_recurring_by_did($donation['did']);
  }
  if (!$donation_data) {
    _fundraiser_sustainers_create_recurring($donation);
  }
  else {
    $record = array_merge((array) $donation_data, $donation); // Merge data together so we get everything in the record.
    drupal_write_record('fundraiser_sustainers', $record, 'did');
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_delete_recurring($did) {
  db_delete('fundraiser_sustainers')->condition('did', $did)->execute();
}

/**
 * DB function, cancel recurring given a master did. (Do not delete!)
 */
function _fundraiser_sustainers_cancel_recurring_by_master($master_did, $reason) {
  db_query('UPDATE {fundraiser_sustainers} ' .
    'SET gateway_resp = \'canceled\', cancellation_reason = :reason ' .
    'WHERE master_did = :master_did AND (gateway_resp IS NULL OR gateway_resp = \'failed\')',
    array(':reason' => $reason, ':master_did' => $master_did));
}

/**
 * DB funct, get user donation set information that are recurring.
 */
function _fundraiser_sustainers_get_donation_sets_recurr_by_uid($uid) {
  $donation_sets = db_query('SELECT r.master_did, MIN(r.next_charge) AS start_date, ' .
    'MAX(r.next_charge) AS expire_date FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE d.uid = :uid ' .
    'GROUP BY r.master_did ' .
    'ORDER BY r.master_did DESC', array(':uid' => $uid))->fetchAll();
  foreach ($donation_sets as $index => $donation_set) {
    $next_charge = _fundraiser_sustainers_get_donations_next_charge($donation_set->master_did);
    if (isset($next_charge->next_charge)) {
      $donation_sets[$index]->next_charge = $next_charge->next_charge;
      $donation_sets[$index]->status = empty($next_charge->cancellation_reason) ? t('Active') : t('Cancelled');
    }
    else {
      $donation_sets[$index]->next_charge = '';
      $donation_sets[$index]->status = t('No next charge');
    }
  }
  return $donation_sets;
}

/**
 * DB funct, get user donation set information that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donation_sets() {
  $donation_sets = db_query('SELECT r.master_did, MIN(r.next_charge) AS start_date, ' .
    'MAX(r.next_charge) AS expire_date FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = r.did ' .
    'GROUP BY r.master_did ' .
    'ORDER BY r.master_did DESC')->fetchAll();
  foreach ($donation_sets as $index => $donation_set) {
    $next_charge = _fundraiser_sustainers_get_donations_next_charge($donation_set->master_did);
    if (isset($next_charge->did)) {
      $donation_sets[$index]->next_charge = $next_charge->next_charge;
      $donation_sets[$index]->status = empty($next_charge->cancellation_reason) ? t('active') : t('cancelled');
    }
  }
  return $donation_sets;
}


/**
 * DB funct, get order donations that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donations_recurr_by_member($did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE d.did = :did OR r.master_did = :master_did ' .
    'ORDER BY r.next_charge ASC', array(':did' => $did, ':master_did' => $did))->fetchAll();
  return $donations;
}

/**
 * DB func, get the next charge date for a donation set.
 */
function _fundraiser_sustainers_get_donations_next_charge($master_did) {
  $now = strtotime('now');
  return db_query('SELECT * FROM {fundraiser_sustainers} ' .
    'WHERE master_did = :master_did ' .
    'AND next_charge > :now ' .
    'ORDER BY next_charge ASC ' .
    'LIMIT 0, 1',
    array(':master_did' => $master_did, ':now' => $now))->fetchObject();
}

/**
 * DB funct, get order donations that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donations_recurr_by_masterdid($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB funct, count order donation sets that are remaining.
 */
function _fundraiser_sustainers_count_donations_recurr_remaining($master_did) {
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  $count = 0;
  foreach ($donations as $donation) {
    $count++;
  }
  return $count;
}

/**
 * DB funct, get order donation sets that are remaining.
 */
function _fundraiser_sustainers_get_donations_recurr_remaining($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'AND (r.gateway_resp IS NULL OR r.gateway_resp = \'failed\') ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB funct, count order donation sets that are processed.
 */
function _fundraiser_sustainers_count_donations_recurr_processed($master_did) {
  $donations = _fundraiser_sustainers_get_donations_recurr_processed($master_did);
  if ($donations) {
    return count($donations);
  }
  return 0;
}

/**
 * DB funct, get order donation sets that are processed.
 */
function _fundraiser_sustainers_get_donations_recurr_processed($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'AND r.gateway_resp = \'success\' ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * Counts the number of sustainers in a sustainer series, including the master.
 *
 * @param int $master_did
 *   The donation ID of the master donation.
 *
 * @return int
 *   Number of sustainer rows with the given master donation ID.
 */
function fundraiser_sustainers_count_donations_in_series($master_did) {
  return db_query('SELECT COUNT(*) FROM {fundraiser_sustainers}
    WHERE master_did = :did', array(':did' => $master_did))->fetchField();
}

/**
 * DB function, get unlocked donations ready to be processed.
 * Lock them.
 */
function _fundraiser_sustainers_cron_get_recurring($limit = 1000) {
  $now = strtotime('now');
  $uni_batch_id = uniqid();
  // Lock them (faster to lock, then query, than the other way around).
  // Since large data set returns => delay.
  $donations = db_query('SELECT r.did FROM {fundraiser_sustainers} r ' .
    'WHERE (r.gateway_resp IS NULL OR r.gateway_resp = \'failed\') ' .
    'AND r.next_charge < :now ' .
    'AND r.attempts < 3 ' . // If already been tried 3 times, Stop Trying.
    'AND r.lock_id = 0 ' . // And not locked.
    'LIMIT 0, ' . $limit,
    array(':now' => $now)
  )->fetchAllKeyed(0, 0);
  if (!empty($donations)) {
    db_query('UPDATE {fundraiser_sustainers} r1 ' .
      'SET r1.lock_id = :uni_batch_id ' .
      'WHERE r1.did IN (:donations)',
      array(':uni_batch_id' => $uni_batch_id, ':donations' => $donations)
    );
  }
  // Grab the locked donations for this batch.
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.lock_id = :uni_batch_id ' . // Locked to this unique ID.
    'ORDER BY r.next_charge ASC',
    array(':uni_batch_id' => $uni_batch_id))->fetchAll();
  // Return them.
  return $donations;
}

/**
 * Get total sustainer count by wdonation form node id.
 * @param int $nid
 *
 * @return
 * Count of distinct sustainer series for this donation form
 */
function _fundraiser_sustainers_get_total_sustainers_by_nid($nid, $start = FALSE, $end = FALSE) {
  static $data = array();
  if (module_exists('fundraiser_commerce')) {
    if (empty($data[$nid])) {
      // SELECT COUNT(DISTINCT(s.master_did))
      // FROM fundraiser_sustainers s
      // JOIN fundraiser_donations d
      //   ON s.master_did = d.did
      // JOIN commerce_orders c         // optional
      //   ON c.order_id = s.master_did // optional
      // WHERE d.nid = :nid
      //   AND o.created >= :start      // optional
      //   AND 0.created >= :end;       // optional
      $query = db_select('fundraiser_sustainers', 's');
      $query->join('fundraiser_donation', 'd', 'd.did = s.master_did');
      if ($start || $end) {
        $query->join('commerce_order', 'o', 'o.order_id = s.master_did');
      }
      $query->addExpression('COUNT(DISTINCT(s.master_did))', 'count');
      $query->condition('d.nid', $nid, '=');
      // add conditionals for start/end date
      if ($start) {
        $query->condition('o.created', $start, '>=');
      }
      if ($end) {
        $query->condition('o.created', $end, '<=');
      }
      $data[$nid] = $query->execute()->fetchField();
    }
    return $data[$nid];
  }

  // TODO: add accompanying query for fundraiser_ubercart
}

/**
 * CRUD style DB function for fundraiser_sustainers_sustainers_node.
 */
function _fundraiser_sustainers_create_sustainers_node($sustainers_node) {
  $sustainers_node = (array) $sustainers_node;
  $sustainers_node_data = FALSE;
  if (isset($sustainers_node['nid'])) {
    $sustainers_node_data = _fundraiser_sustainers_get_sustainers_node_by_nid($sustainers_node['nid']);
  }
  if (!$sustainers_node_data) {
    drupal_write_record('fundraiser_sustainers_nodes', $sustainers_node);
  }
  else {
    _fundraiser_sustainers_update_sustainers_node($sustainers_node);
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers_sustainers_node.
 */
function _fundraiser_sustainers_get_sustainers_node_by_nid($nid) {
  return db_query('SELECT * FROM {fundraiser_sustainers_nodes} WHERE nid = :nid', array(':nid' => $nid))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_sustainers_sustainers_node.
 */
function _fundraiser_sustainers_update_sustainers_node($sustainers_node) {
  $sustainers_node = (array) $sustainers_node;
  $sustainers_node_data = FALSE;
  if (isset($sustainers_node['nid'])) {
    $sustainers_node_data = _fundraiser_sustainers_get_sustainers_node_by_nid($sustainers_node['nid']);
  }
  if (!$sustainers_node_data) {
    _fundraiser_sustainers_create_sustainers_node($sustainers_node);
  }
  else {
    $sustainers_node = array_merge((array) $sustainers_node_data, $sustainers_node);
    drupal_write_record('fundraiser_sustainers_nodes', $sustainers_node, 'nid');
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers_sustainers_node.
 */
function _fundraiser_sustainers_delete_sustainers_node($nid) {
  db_delete('fundraiser_sustainers_nodes')->condition('nid', $nid)->execute();
}

/**
 * Returns the cid of the recurring webform component for a given node.
 *
 * @param object $node
 *   Node object.
 *
 * @return bool|int
 *   The component ID, or FALSE if one can't be found.
 */
function fundraiser_sustainers_get_recurring_cid_by_node($node) {
  $form_key = 'recurs_monthly';

  if (count($node->webform['components'])) {
    foreach ($node->webform['components'] as $cid => $component) {
      if ($component['form_key'] == $form_key) {
        return $cid;
      }
    }
  }

  return FALSE;
}

/**
 * Determine if the webform component value indicates that a submission is recurring.
 *
 * @param string|array $value
 *   The value of the recurring webform component to check.
 *
 * @return bool
 *   TRUE if this value indicates the submission is recurring.
 */
function fundraiser_sustainers_component_value_is_recurring($value) {
  $recurs_string = 'recurs';

  // The component is usually a select or checkbox.
  // So $value would be an array.
  if (is_array($value) && in_array($recurs_string, $value)) {
    return TRUE;
  }
  // If recurring is required, the component will be hidden.
  // And $recurring_value will be a string.
  elseif (is_string($value) && $value == $recurs_string) {
    return TRUE;
  }

  return FALSE;
}
