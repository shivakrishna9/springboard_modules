<?php

/**
 * @file
 * Commerce based hook implementations for the fundraiser module donations.
 */

// Commerce mail rules can / should be turned off on installation, so no need to implement hook_mail_alter().

/**
 * Implements hook_menu
 */
function fundraiser_commerce_menu() {
  $items = array();
  $items['node/%node/fundraiser-redirect/%'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_fundraiser_commerce_fundraiser_donation_process_external_form', 3),
    'access callback' => TRUE,
  );
  $items['node/%node/fundraiser-cancel/%'] = array(
    'page callback' => '_fundraiser_commerce_fundraiser_donation_process_external_form_cancel',
    'page arguments' => array(3), // Pass the donation ID along.
    'access callback' => TRUE,
  );
  $items['node/%node/fundraiser-return/%'] = array(
    'page callback' => '_fundraiser_commerce_fundraiser_donation_process_external_form_return',
    'page arguments' => array(3), // Pass the donation ID along.
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function fundraiser_commerce_menu_alter(&$items) {
  // Deny access to the the void and credit forms provided by the gateways
  foreach ($items as $path => $item) {
    if (strpos($path, 'admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/') !== FALSE) {
      // If not view or delete change the access callback to deny access
      if (($path != 'admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/view') &&
        ($path != 'admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/delete')) {
        $items[$path]['access callback'] = '_fundraiser_commerce_deny_gateway_credit_form_access';
      }
    }
  }

  // Custom refund form for fundraiser
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/refund'] = array(
    'title' => 'Refund',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_commerce_refund_form', 3, 5),
    'access callback' => 'fundraiser_commerce_refund_form_access',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );
}

/**
 * Menu access for the gateway credit and void forms
 */
function _fundraiser_commerce_deny_gateway_credit_form_access($order, $transaction) {
  return FALSE;
}

/**
 * Menu access for refund operation.
 */
function fundraiser_commerce_refund_form_access($order, $transaction) {
  // Return FALSE if the transaction doesn't have a
  // success status or has an amount of 0 or less.
  if ($transaction->status != 'success' || $transaction->amount <= 0) {
    return FALSE;
  }
  // Return FALSE if it is more than 120 days past the original capture.
  if (time() - $transaction->created > 86400 * 120) {
    return FALSE;
  }
  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Form callback, override Commerce provided refund forms with our own.
 * This is just a wrapper, to get the rest of the goodies in place.
 */
function fundraiser_commerce_refund_form($form, &$form_state, $order, $transaction) {
  return drupal_get_form('_fundraiser_refund_form', $order->order_id);
}

/**
 * Implements hook_entity_view().
 */
function fundraiser_commerce_entity_view($entity, $type, $view_mode, $langcode) {
  switch ($type) {
    case 'commerce_order':
      if (($view_mode == 'administrator' || $view_mode == 'full') && fundraiser_donation_get_donation($entity->order_id)) {
        $entity->content['fundraiser_donation'] = array(
          '#prefix' => '<div class="field field-name-fundraiser-donation field-type-fundraiser-donation field-label-above">' .
            '<div class="field-label">' . t('Fundraiser information') . ': </div>' .
            '<div class="field-items"><div class="field-item even">',
          '#markup' => fundraiser_donation_information_table($entity->order_id), // Table format.
          '#suffix' => '</div></div></div>',
        );
      }
      break;
    default:
  }
}

/**
 * Implements hook_token_info_alter
 */
function fundraiser_commerce_token_info_alter(&$data) {
  if (!empty($data['tokens']['donation'])) {
    // Add Commerce related tokens
    $data['tokens']['donation']['order'] = array(
      'name' => t('Donation Order'),
      'description' => t('Ther order used to process the donation.'),
      'type' => 'commerce-order',
    );
    $data['tokens']['donation']['payment-transaction'] = array(
      'name' => t('Donation Order Transaction'),
      'description' => t('The transaction data from the payment processor.'),
      'type' => 'commerce-payment-transaction',
    );
  }
}

/**
 * Implements hook_tokens_alter
 *
 * Add support for order and transaction tokens from a donation
 */
function fundraiser_commerce_tokens_alter(&$replacements, $context) {
  // Make sure we have a donation to work with
  if ($context['type'] == 'donation' && !empty($context['data']['donation'])) {
    $donation = $context['data']['donation'];

    // Load the order and do token replacement on the order and transaction tokens
    $order = !empty($donation->order) ? $donation->order : commerce_order_load($donation->did);

    // Replace the order tokens
    if (!empty($order) && $order_tokens = token_find_with_prefix($context['tokens'], 'order')) {
      $replacements += token_generate('commerce-order', $order_tokens, array('commerce-order' => $order), $context['options']);
    }

    // Replace the transaction tokens using the latest transaction
    if (!empty($order) && $transaction_tokens = token_find_with_prefix($context['tokens'], 'payment-transaction')) {
      $transactions = commerce_payment_transaction_load_multiple(array(), array('order_id' => $order->order_id));
      $transaction = reset($transactions);
      $replacements += token_generate('commerce-payment-transaction', $transaction_tokens, array('commerce-payment-transaction' => $transaction), $context['options']);
    }
  }
}

/**
 * Implements fundraiser_donation_information_table_alter().
 */
function fundraiser_commerce_fundraiser_donation_information_table_alter(&$variables, $donation) {
  // Add refund information to the display table.
  if (!empty($donation->refund) && $donation->refund != FALSE) {
    $refunded_donation = fundraiser_donation_get_donation($donation->refund['refunded_donation']);
    $variables['rows'][] = array('Refund for donation', t('Donation #!did on Form #@nid - !title',
      array(
        '!did' => l($refunded_donation->did, 'admin/commerce/orders/' . $refunded_donation->did . '/view'),
        '@nid' => $refunded_donation->nid,
        '!title' => l($refunded_donation->node->title, 'node/' . $refunded_donation->node->nid),
      )
    ));
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Adds the admin form to fundraiser's admin form.
 */
function fundraiser_commerce_form_fundraiser_admin_settings_alter(&$form, &$form_state) {
  $countries = _fundraiser_commerce_get_countries();
  $options = array('' => t('-- No default --'));
  foreach ($countries as $country) {
    $options[$country->country_id] = $country->country_name;
  }
  $form['fundraiser']['fundraiser_default_country'] = array(
    '#type' => 'select',
    '#title' => t('Default country'),
    '#options' => $options,
    '#default_value' => variable_get('fundraiser_default_country', 'US'),
    '#description' => t('Enter the default initial country to be used on donation forms.'),
  );
}

/**
 * Implements hook_commerce_line_item_type_info().
 */
function fundraiser_commerce_commerce_line_item_type_info() {
  $line_item_types = array();
  $line_item_types['donation'] = array(
    'type' => 'donation',
    'name' => t('Donation'),
    'description' => t('A donation charge, no product referenced here just the amount.'),
    'product' => FALSE,
    'add_form_submit_value' => t('Add donation'),
    'base' => 'commerce_donation_line_item',
  );
  return $line_item_types;
}

/**
 * Implements hook_LINE_ITEM_BASE_title().
 * Returns an appropriate title for this line item.
 */
function commerce_donation_line_item_title($line_item) {
  $donation = fundraiser_donation_get_donation($line_item->order_id);
  return t('Donation for Fundraiser #%nid %title', array(
    '%nid' => $donation->nid,
    '%title' => isset($donation->node->title) ? $donation->node->title : '',
  ));
}

/**
 * Implements hook_LINE_ITEM_BASE_add_form().
 * Returns the elements necessary to add a product line item through a line item manager widget.
 */
function commerce_donation_line_item_add_form($element, &$form_state) {
  $form = array();
  $form['amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Amount'),
    '#description' => t('Enter the amount of the donation to add to the order.'),
    '#size' => 60,
    '#maxlength' => 255,
  );
  if (function_exists('fundraiser_multi_currency_get_currencies')) {
    $multi_currancy = fundraiser_multi_currency_get_currencies();
    $available_currancy = array();
    foreach ($multi_currancy as $currancy) {
      $available_currancy[$currancy->code] = $currancy->name;
    }
    $form['currency'] = array(
      '#type' => 'select',
      '#title' => t('Currency'),
      '#description' => t('Enter the currency of the donation to add to the order.'),
      '#options' => $available_currancy,
    );
  }
  // TODO - select a fundraiser to associate this with.
  // AND add support when a donation is submitted via this order form, to update a donation obj and submission with the given amount.
  // All this for later.
  // For now, display a 'not from here' message.
  $form['fundraiser_donation'] = array(
    '#markup' => '<div class="commerce-donation-line-item-warning">' .
      t('Warning: Donation line items added through this interface do not generate an additional donation object in the Fundraiser system,' .
        'or update a donation associated with this order to the new amount. Please do not use this to update donations on orders.') . '</div>',
  );
  return $form;
}

/**
 * Submit handler for commerce_donation_line_item_add_form().
 */
function commerce_donation_line_item_add_form_submit(&$line_item, $element, &$form_state, $form) {
  $values = $element['actions'];
  if (!empty($values['amount']['#value']) && is_numeric($values['amount']['#value'])) {
    $values['currency']['#value'] = isset($values['currency']['#value']) ? $values['currency']['#value'] : 'USD';
    // Create a line item for this order. Contains order amount info.
    $line_item->line_item_label = t('Donation');
    $line_item->quantity = 1;
    $line_item->commerce_unit_price[LANGUAGE_NONE][0] = array(
      'amount' => commerce_currency_decimal_to_amount($values['amount']['#value'], $values['currency']['#value']),
      'currency_code' => $values['currency']['#value'],
    );
    // Make sure the line item will be included in the update for order total.
    $line_item->commerce_unit_price[LANGUAGE_NONE][0]['data'] = commerce_price_component_add(
      $line_item->commerce_unit_price[LANGUAGE_NONE][0],
      'base_price',
      array(
      'amount' => commerce_currency_decimal_to_amount($values['amount']['#value'], $values['currency']['#value']),
      'currency_code' => $values['currency']['#value'],
      'data' => array(),
    ),
      TRUE
    );
  }
  else {
    return t('You have entered an invalid amount.');
  }
}

/**
 * Implements hook_commerce_order_status_info().
 */
function fundraiser_commerce_commerce_order_status_info() {
  $fundraiser_statuses = array(
    'pending_future_payment' => array(
      'name' => 'pending_future_payment',
      'title' => 'Pending Future Payment',
      'state' => 'pending',
    ),
    'failed' => array(
      'name' => 'failed',
      'title' => 'Failed',
      'state' => 'canceled',
    ),
    'failed_refund' => array(
      'name' => 'failed_refund',
      'title' => 'Failed refund',
      'state' => 'canceled',
    ),
    'refunded' => array(
      'name' => 'refunded',
      'title' => 'Refunded',
      'state' => 'completed',
    ),
    'payment_received' => array(
      'name' => 'payment_received',
      'title' => 'Payment Received',
      'state' => 'completed',
    ),
    'partially_refunded' => array(
      'name' => 'partially_refunded',
      'title' => 'Partially Refunded',
      'state' => 'completed',
    ),
  );
  return $fundraiser_statuses;
}

/**
 * Implements hook_fundraiser_gateway_info().
 */
function fundraiser_commerce_fundraiser_gateway_info() {
  /// Load all the methods available.
  $methods = new stdClass();
  $methods->payment_methods = array();
  rules_invoke_all('commerce_payment_methods', $methods);
  $fundraiser_gateways = array();
  foreach ($methods->payment_methods as $id => $info) {
    $this_gateway = array();
    $method_instance = commerce_payment_method_instance_load($id); // From commerce_payment.module.
    list($method_id, $rule_name) = explode('|', $method_instance['instance_id']);
    // Load the rule configuration
    if (!empty($method_id) && !empty($rule_name)) {
      $rule_config = rules_config_load($rule_name);
      $this_gateway['id'] = $method_instance['instance_id'];
      $this_gateway['module'] = 'fundraiser_commerce';
      $this_gateway['module_name'] = t('Commerce');
      $this_gateway['title'] = $rule_config->label;
      $this_gateway['description'] = $method_instance['description'];

      // Gather additional details per our specific implementation.
      // Re: type of fieldset, and available recurring features.
      // By including the plugin code here, we insure that all available functions are available for all other code.
      // When referencing gateway info gathered under gateway_info hooks.
      module_load_include('inc', 'fundraiser_commerce', '/gateways/' . $method_instance['module']);
      $gateway_options = module_invoke($method_instance['module'], 'fundraiser_commerce_fundraiser_gateway_info');
      // If nothing is returned this gateway is not configured to work with fundraiser
      if (empty($gateway_options)) {
        continue;
      }

      // Some gateways support multiple payment methods and multiple payment processors
      // Check if it specifies support for each in the payment method array
      foreach ($gateway_options['payment_method'] as $key => $type) {
        if (!is_numeric($key) && $key == $method_id) {
          $gateway_options['payment_method'] = array($type);
        }
      }
      $this_gateway += $gateway_options;

      // Make sure defaults are in place if not set in the plugin.
      if (empty($this_gateway['allow_recurring'])) {
        $this_gateway['allow_recurring'] = array();
      }
      if (empty($this_gateway['offsite_recurring'])
         || empty($method_instance['settings']['offsite_recurring'])
         || $method_instance['settings']['offsite_recurring'] == 0) {
        $this_gateway['offsite_recurring'] = array();
      }
      if (empty($this_gateway['offsite_processing'])) {
        $this_gateway['offsite_processing'] = array();
      }
      if (empty($this_gateway['allow_refund'])) {
        $this_gateway['allow_refund'] = array();
      }
      // Error check, disallow members of recurring that are offsite processing.
      $this_gateway['allow_recurring'] = array_diff($this_gateway['allow_recurring'], $this_gateway['offsite_processing']);
      // Save the original data declared.
      $this_gateway['gateway_details'] = $method_instance;
      $fundraiser_gateways[$this_gateway['id']] = $this_gateway;
    }
  }

  return $fundraiser_gateways;
}

/**
 * Implements hook_fundraiser_field_info_alter().
 */
function fundraiser_commerce_fundraiser_field_info_alter(&$fields) {
  // TODO review this code, perhaps we can push it further up into fundraiser proper.
  // That would also avoid the wierd ajaxy stuff we have to do to get reference back working.
  $countries = fundraiser_commerce_get_countries();
  $include_all_countries = variable_get('fundraiser_all_countries', 0);
  $default_available = array('US', 'CA');
  $options = '';
  $included_countries = array();
  if ($include_all_countries) {
    foreach ($countries->countries as $country_id => $country) {
      if (!in_array($country->iso, $included_countries) && !empty($country->iso)) {
        $options .= $country->iso . '|' . $country->country_name . "\n";
        $included_countries[] = $country->iso;
      }
    }
  }
  else {
    foreach ($countries->countries as $country_id => $country) {
      if (in_array($country->iso, $default_available)) {
        $options .= $country->iso . '|' . $country->country_name . "\n";
      }
    }
  }

  // Set the default to a global default if set.
  $fields['billing_information']['country'] = array(
    '#title' => t('Country'),
    '#type' => 'select',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'items' => $options,
      'multiple' => 0,
      'aslist' => 1,
    ),
    '#display_callback' => '_fundraiser_commerce_country_field_display',
  );
  $default_country = variable_get('fundraiser_default_country', 'US');
  if (!empty($default_country)) {
    $fields['billing_information']['country']['#value'] = $default_country;
  }
  $options = '';
  $included_zones = array();
  foreach ($countries->zones as $zone_id => $zone) {
    if (!in_array($zone->iso, $included_zones) && !empty($zone->iso)) {
      $options .= $zone->iso . '|' . $zone->zone_name . "\n";
      $included_zones[] = $zone->iso;
    }
  }
  $fields['billing_information']['state'] = array(
    '#title' => t('State/Province'),
    '#type' => 'select',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'items' => $options,
      'multiple' => 0,
      'aslist' => 1,
    ),
    '#display_callback' => '_fundraiser_commerce_zone_field_display',
  );
  // Add our own validation routines to the billing fields for credit cards.
  $fields['payment_information']['payment_fields']['#validate_callback'] = '_fundraiser_commerce_payment_fields_validate';
  return $fields;
}

/**
 * Validation callback for field payment_fields.
 */
function _fundraiser_commerce_payment_fields_validate($form, $form_state, $submission_fields, $value) {
  if (empty($form['#node'])) {
    $form['#node'] = $form['#donation']->node;
  }
  $payment_method = $submission_fields['payment_method'];
  $payment_method_component = _fundraiser_webform_get_component_by_nid_key($form['#node']->nid, array('payment_method'));
  $payment_method_field = $form['#node']->webform['components'][$payment_method_component->cid];
  $gateway_info = _fundraiser_gateway_info($payment_method_field['extra']['payment_methods'][$payment_method]['id']);
  // If the payment method has its own validate function don't validate here
  if (isset($gateway_info['validate callback'])) {
    return;
  }

  // If we don't have a gateway validate callback, use generic credit card
  // validation.
  if ($payment_method == 'credit') {
    return fundraiser_commerce_generic_credit_card_validate($value);
  }
}

/**
 * Does some basic credit card validation.
 *
 * @param array $value
 *   The credit card data in the following format.
 *   array('credit' =>
 *     'card_number' => 1234,
 *     'card_cvv' => 123,
 *     'card_expiration_month' => 1,
 *     'card_expiration_year' => 2014,
 *   )
 *
 * @return array
 *   An array with form key and error message.
 */
function fundraiser_commerce_generic_credit_card_validate($value) {
  // @todo This should probably be driven down to the gateway level.
  // Include the file with the validation info.
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  $number = $value['credit']['card_number'];
  if ($number != '0000000000000000') {
    $valid = commerce_payment_validate_credit_card_number($number);
    if ($valid !== TRUE || !ctype_digit($number) || drupal_strlen($number) < 10) {
      return array('card_number' => t('You have entered an invalid credit card number.'));
    }
    $cvv = $value['credit']['card_cvv'];
    $valid = commerce_payment_validate_credit_card_security_code($number, $cvv);
    if ($valid !== TRUE && !empty($cvv)) {
      return array('card_cvv' => t('You have entered an invalid CVV number.'));
    }
    $cc_expiration_month = $value['credit']['card_expiration_month'];
    $cc_expiration_year = $value['credit']['card_expiration_year'];
    $valid = commerce_payment_validate_credit_card_exp_date($cc_expiration_month, $cc_expiration_year);
    if ($valid !== TRUE && !empty($cc_expiration_month) && !empty($cc_expiration_year)) {
      return array(
        'card_expiration_month' => t('The credit card you entered has expired.'),
        'card_expiration_year' => '',
      );
    }
  }
}

/**
 * Display callback for field country. Set the defaults if the country has it.
 */
function _fundraiser_commerce_country_field_display($form, $form_state, $field) {
  // Set the default to a user default if set.
  // Flatten form state array so we can get the user selection easier.
  $fields = _fundraiser_commerce_submission_flatten($form_state);
  // Set the default country if form_state has it.
  if (array_key_exists('country', $fields)) {
    $field['#default_value'] = $fields['country'];
  }
  // Add interface elements to the field display.
  $field['#ajax'] = array(
    'callback' => '_fundraiser_commerce_client_state_ajax_submit',
    'wrapper' => 'zone-select-wrapper',
    'method' => 'replace',
    'effect' => 'fade',
  );
  return $field;
}

/**
 * Helper function, flatten webforms submitted tree into an array mapping fields to values.
 */
function _fundraiser_commerce_submission_flatten($submit_tree) {
  $flat_array = array();
  foreach ($submit_tree as $key => $value) {
    if (!is_array($submit_tree[$key])) {
      $flat_array[$key] = $value;
    }
    else {
      $flat_array = array_merge($flat_array, _fundraiser_commerce_submission_flatten($value));
    }
  }
  return $flat_array;
}

/**
 * AJAX callback for dealing with changes to the donation form.
 */
function _fundraiser_commerce_client_state_ajax_submit($form, $form_state, &$mess = '') {
  // Replace the state field with an updated version with the state list for the
  // selected country.
  // After the replace event add focus to the state field. This makes for a smooth transition
  // in some browsers for users who tab between fields.
  return array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_replace('#zone-select-wrapper', render(fundraiser_get_form_field($form['#calling_module'], $form, 'state'))),
      ajax_command_invoke('#edit-submitted-billing-information-state', 'focus'),
    ),
  );
}

/**
 * Display callback for field zone, to set the default based on the country given.
 */
function _fundraiser_commerce_zone_field_display($form, $form_state, $field) {
  // Get countries.
  $countries = fundraiser_commerce_get_countries();
  // Flatten form state array so we can get the user selection easier.
  $fields = _fundraiser_commerce_submission_flatten($form_state);
  // Country/state dependant drop down code
  $available_zones = isset($countries->zones) ? $countries->zones : array();
  // Filter the available zones by the set country.
  if (array_key_exists('country', $fields)) {
    $country_id = $fields['country'];
    // Filter options down to just the zones available for this country.
    if (isset($countries->countries[$country_id])) {
      $available_zones = $countries->countries[$country_id]->zones;
    }
  }
  else {
    // Provide a default based on the form values.
    $country_field = fundraiser_get_form_field($form['#calling_module'], $form, 'country');
    // Filter options down to just the zones available for this country.
    if (isset($country_field['#default_value'])) {
      $default = $country_field['#default_value'];
      $default = $default;
      if (isset($countries->countries[$default])) {
        $available_zones = $countries->countries[$default]->zones;
      }
    }
  }
  // Given available zones, filter the dropdown to match.
  if (!empty($available_zones)) {
    $new_zone_options = array();
    foreach ($available_zones as $zone_id => $zone) {
      $new_zone_options[$zone->iso] = $zone->zone_name;
    }
    $field['#options'] = $new_zone_options;
  }
  else {
    // If there are no zones to match, then fall back on a non-select solution.
    $field['#type'] = 'textfield';
  }
  $field['#prefix'] = '<div id="zone-select-wrapper">';
  $field['#suffix'] = '</div>';
  return $field;
}

/**
 * Implements hook_fundraiser_get_credit_encryption_path().
 * This is called by modules that need to check for processing availablity outside of normal.
 * Such as sustainer.
 */
function fundraiser_commerce_fundraiser_get_credit_encryption_path() {
  return variable_get('encrypt_secure_key_path', t('Not configured, see below.')); // From the encrypt module.
}

/**
 * Implements hook_fundraiser_donation_get_donation().
 */
function fundraiser_commerce_fundraiser_donation_get_donation($donation) {
  // Load the order object, line items and profile.
  $order = commerce_order_load($donation->did);
  // Data from order.
  $donation->donation['mail'] = isset($order->mail) ? $order->mail : '';
  // Reverse the work done by commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency'])
  // So we have the correct decimaled value.
  $donation->donation['amount'] = commerce_currency_amount_to_decimal($order->commerce_order_total[LANGUAGE_NONE][0]['amount'],
    $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code']);
  $donation->donation['quantity'] = 1;
  $donation->donation['hostname'] = $order->hostname;
  $found = commerce_line_item_load_multiple(array(), array('order_id' => $order->order_id));
  $line_item_id = -1;
  foreach ($found as $id => $found) {
    $line_item_id = $id;
  }
  if ($line_item_id != -1) {
    $line_item = commerce_line_item_load($line_item_id);
    $donation->donation['quantity'] = $line_item->quantity;
    $donation->donation['amount'] = commerce_currency_amount_to_decimal($line_item->commerce_unit_price[LANGUAGE_NONE][0]['amount'],
      $line_item->commerce_unit_price[LANGUAGE_NONE][0]['currency_code']);
  }
  // Data from profile.
  if (isset($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id'])) {
    $profile = commerce_customer_profile_load($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id']);
    $map = array(
      'first_name' => 'first_name',
      'last_name' => 'last_name',
      'address' => 'thoroughfare',
      'address_line_2' => 'premise',
      'city' => 'locality',
      'country' => 'country',
      'state' => 'administrative_area',
      'zip' => 'postal_code',
    );
    $field_info = _fundraiser_get_field_keys();
    foreach ($field_info as $field_name) {
      if (isset($map[$field_name])) {
        $order_name = $map[$field_name];
        $donation->donation[$field_name] = isset($profile->commerce_customer_address[LANGUAGE_NONE][0][$order_name]) ?
          $profile->commerce_customer_address[LANGUAGE_NONE][0][$order_name] : '';
      }
    }
  }
  // Time of last update / charge.
  $donation->last_changed = $order->changed;
  // Add the order status data.
  $donation->status = $donation->status_label = isset($order->status) ? $order->status : 'unknown';
  if (!empty($order->status)) {
    $donation->status_label = _fundraiser_commerce_get_label_by_status($order->status);
    $donation->status_charged = _fundraiser_commerce_get_charged_by_status($order->status) ? 1 : 0;
    if ($donation->status_charged) {
      $donation->close_date = date('Y-m-d H:i:s', $donation->last_changed);
      $donation->transaction_date = date('Y-m-d H:i:s', $donation->last_changed);
    }
  }
  // This order data was stored during hook_fundraiser_donation_process(), and scrubbed by the gateway.
  if (!empty($order->data)) {
    $data = _fundraiser_commerce_order_data_retrieve($order->data['fundraiser_commerce']);

    // Put data stored data into the right places.
    $donation->donation['payment_method'] = isset($data['payment_method']) ? $data['payment_method'] : '';
    $donation->donation['payment_fields'] = isset($data['payment_fields']) ? $data['payment_fields'] : array();
    // Put data on the donation object for reference later.
    $donation->data = $data; // Data will contain any gateway payment processing information.
  }
}

/**
 * Implements hook_fundraiser_donation_create().
 */
function fundraiser_commerce_fundraiser_donation_create($donation) {
  /**
   * Commerce checkout is usually what creates an account.
   * If we don't have that turned on (and there's no other reason to)
   * Then WE are responsible for linking the user id to the correct submitted account.
   * If commerce_checkout is enabled, then:
   * Creating the new user comes as part of the checkout rules.
   * Which is set to the end of the checkout process, and sets the order->uid to the new account.
   * And is triggered on form submission of the checkout panel. This means: It doesn't get run.
   * So for our needs, we need to make out own user and add him to the donation on a success.
   */

  // Go by the logged in user first, unless user is anon or not set.
  $user = $donation->user;
  if ($user->uid < 1) {
    // Check by email, see if this account is already in existance.
    $user = user_load_by_mail( $donation->donation['mail'] );
    if (empty($user->uid)) {
      // If not, create a new user account, and add it to the donation.
      $donation->donation['mail'] = trim($donation->donation['mail']);
      $fields = array(
        'name' => _fundraiser_commerce_email_to_username($donation->donation['mail']),
        'mail' => $donation->donation['mail'],
        'init' => $donation->donation['mail'],
        'pass' => user_password(12),
        'roles' => array(),
        'status' => 1,
      );
      $user = user_save('', $fields);
    }
  }
  // Set the new information on the donation.
  $donation->user = $user;
  $donation->uid = $user->uid;

  // Set the node.
  $node = $donation->node;
  // Pick out the values we need to generate an order.
  if ($donation->donation['amount'] == 'other') {
    $donation->donation['amount'] = preg_replace('/[^\d\.]/i', '', $donation->donation['other_amount']);
  }
  $donation->donation['currency'] = isset($donation->donation['currency']) ? $donation->donation['currency'] : 'USD';
  // Determine quantity and data from donation values.
  $quantity = isset($donation->donation['quantity']) && !empty($donation->donation['quantity']) ? $donation->donation['quantity'] : 1;

  // Create new order.
  $order = commerce_order_new($user->uid, 'pending', 'commerce_order');
  commerce_order_save($order);
  $order->email = isset($donation->donation['mail']) ? $donation->donation['mail'] : '';

  // Create a line item for this order. Contains order amount info.
  $line_item = commerce_line_item_new('donation', $order->order_id);
  $line_item->line_item_label = t('Donation');
  $line_item->quantity = $quantity;
  $line_item->commerce_unit_price[LANGUAGE_NONE][0] = array(
    'amount' => commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency']),
    'currency_code' => $donation->donation['currency'],
  );
  // Make sure the line item will be included in the update for order total.
  $line_item->commerce_unit_price[LANGUAGE_NONE][0]['data'] = commerce_price_component_add(
    $line_item->commerce_unit_price[LANGUAGE_NONE][0],
    'base_price',
    array(
      'amount' => commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency']),
      'currency_code' => $donation->donation['currency'],
      'data' => array(),
    ),
    TRUE
  );
  commerce_line_item_save($line_item);
  // Add the line item to the order.
  $order->commerce_line_items[LANGUAGE_NONE][0]['line_item_id'] = $line_item->line_item_id;

  // Save the customer information. Contains billing info.
  // Look up the profile by user id or email, then if not found make a new profile.
  $found = commerce_customer_profile_load_multiple(array(), array('uid' => $user->uid));
  $profile_id = -1;
  foreach ($found as $id => $found) {
    $profile_id = $id;
  }
  if ($profile_id != -1) {
    $profile = commerce_customer_profile_load($profile_id);
  }
  else {
    $profile = commerce_customer_profile_new('billing', $user->uid); // Billing type comes with Commerce by default.
  }
  // Update profile with the billing information.
  $profile->commerce_customer_address[LANGUAGE_NONE][0] = addressfield_default_values();
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['country'] = $donation->donation['country'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line'] = $donation->donation['first_name'] . ' ' . $donation->donation['last_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['first_name'] = $donation->donation['first_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['last_name'] = $donation->donation['last_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['administrative_area'] = $donation->donation['state'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['thoroughfare'] = $donation->donation['address'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['premise'] = $donation->donation['address_line_2'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['locality'] = $donation->donation['city'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['postal_code'] = $donation->donation['zip'];
  commerce_customer_profile_save($profile);
  $order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id'] = $profile->profile_id;

  // Gather the payment fields for storage, and scrub them.
  if (!empty($donation->gateway)) {
    $method_instance = is_string($donation->gateway) ? _fundraiser_gateway_info($donation->gateway) : $donation->gateway;
  }
  else {
    $info = _fundraiser_get_donation_gateway($donation->did);
    $method_instance = _fundraiser_gateway_info($info['id']);
  }

  $scrubbed_fields = $donation->donation['payment_fields'];
  if (isset($method_instance['scrub callback']) && function_exists($method_instance['scrub callback'])) {
    $callback = $method_instance['scrub callback'];
    $scrubbed_fields = $callback($scrubbed_fields, $donation->donation['payment_method']);
  }
  $data = array(
    'payment_method' => $donation->donation['payment_method'],
    'payment_fields' => $scrubbed_fields,
  );

  // There may be information already in the donation->data in the case of sustainer duplication.
  // We want to make sure this information propogates if it's available on the donation object already.
  if (isset($donation->data) && is_array($donation->data) && !empty($donation->data)) {
    $data = array_merge($donation->data, $data);
  }

  // Then set the data for storage on the order object to be ecrypted.
  // This data array contains: method choosen, fields for the method, card handler id info.
  // Since Card On File stores data unencrypted we can't use it here.
  // And any other additional information we need to track for the donation object.
  $donation->data = $data;

  // If this is a sustainer create process clear the data array of the master order values
  if (!empty($donation->sustainer_create)) {
    $donation->data['txn_id'] = '';
    $donation->data['remote_id'] = '';
    $donation->data['transaction_id'] = '';
    $donation->data['status'] = '';
    $donation->data['remote_status'] = '';
  }

  $order->data['fundraiser_commerce'] = _fundraiser_commerce_order_data_prepare($donation->data);

  // Save the order.
  $order->uid = $user->uid; // Make sure we have the right user. The one we want.
  commerce_order_save($order);

  // Set the order id to the donation to carry forward.
  $donation->did = $order->order_id;
  // Set the order status to fundraiser_commerce's status.
  _fundraiser_commerce_update_order_status('pending_future_payment', $donation->did);
  $donation->status = 'pending_future_payment';
  $donation->status_label = _fundraiser_commerce_get_label_by_status('pending_future_payment');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('pending_future_payment');
}

/**
 * Implements hook_fundraiser_donation_process().
 * Could be called immediately after creation, or recurring months later using a cc handler profile id.
 * The donation could then be processed internally, or be a redirection handler.
 * So all in all - we'll need to account for a bunch of paths here.
 */
function fundraiser_commerce_fundraiser_donation_process($donation) {
  // Grab the gateway configuration from fundraisers data.
  $info = _fundraiser_get_donation_gateway($donation->did);
  $method_instance = commerce_payment_method_instance_load($info['id']); // From commerce_payment.module.
  // Choose which of two ways to process this.
  if (in_array($donation->donation['payment_method'], $info['offsite_processing'])) {
    // If external processing, we cannot execute a recurring charge against it. So we're ok.
    // Load up additional data as needed for this donation, from Fundraiser and Commerce.
    // If the function to build the redirect form exists.
    if (empty($info['redirect callback'])) {
      // Alert the administrator that the module does not provide a required form.
      drupal_set_message(t('The %title payment method indicates it is offsite but does not define the form to process the redirect.',
        array('%title' => $method_instance['title'])), 'error');
      // We can't find the gateway and we should tell someone about it.
      watchdog('fundraiser', 'Cannot determine the redirect form for donation @id. Node id of donation form is @nid',
        array('@id' => $donation->did, '@nid' => $donation->nid), WATCHDOG_CRITICAL);
      watchdog('fundraiser_commerce', 'Redirect hook is empty.');
      $donation->result = array(
        'success' => FALSE,
        'message' => 'Cannot determine the redirect hook for this donation.',
      );
      return; // At this point, the original form will reload with error.
    }
    // If external, check for paths to be available.
    _fundraiser_commerce_fundraiser_donation_process_external($donation, $info);
  }
  else {
    // If internal processing, then it may be a sustainer charge or newly declared.
    // The gateway is responsible for that call.
    if (empty($info['charge callback'])) {
      // Alert the administrator that the module does not provide a required form.
      drupal_set_message(t('The %title payment method does not provide a gateway charge function.',
        array('%title' => $method_instance['title'])), 'error');
      // We can't find the gateway and we should tell someone about it.
      watchdog('fundraiser', 'Cannot determine the payment gateway for donation @id. Node id of donation form is @nid',
        array('@id' => $donation->did, '@nid' => $donation->nid), WATCHDOG_CRITICAL);
      watchdog('fundraiser_commerce', 'Charge function :function is empty.', array(':function' => $info['charge callback']));
      $donation->result = array(
        'success' => FALSE,
        'message' => 'Cannot determine the payment gateway for this donation.',
      );
      return; // Return the failure.
    }
    // And process.
    _fundraiser_commerce_fundraiser_donation_process_internal($donation, $info);
  }
}

/**
 * Helper function, after process for redirected processes to update status etc in one line.
 * Pulled out to make it easier for redirect processes to update the donation on return.
 */
function fundraiser_commerce_fundraiser_donation_after_process($donation) {
  if (isset($donation->result['success']) && $donation->result['success']) {
    // Set the values donation needs for the rest of the system.
    $order = commerce_order_load($donation->did);
    // If a user was created in the midst of that it should be on the order object. If so, add here.
    $donation->uid = $order->uid;
    $donation->user = user_load($order->uid);
    // Add the status data.
    $donation->status = $donation->status_label = isset($order->status) ? $order->status : 'unknown';
    if (!empty($order->status)) {
      $donation->status_label = _fundraiser_commerce_get_label_by_status($order->status);
      $donation->status_charged = _fundraiser_commerce_get_charged_by_status($order->status);
    }
  }
}

/**
 * Helper function, provides internal processing for supported gateways.
 *
 * Drupal Commerce doesn’t maintain Ubercart’s separation of payment methods from payment gateways but rather
 * defines payment methods as any single way of collecting payment from a customer per payment provider. This
 * means there will not be a single Credit Card payment method with plugin modules for CyberSource, Authorize.Net,
 * etc. but a separate CC payment method for each payment provider with a common base set of code for building
 * credit card forms and handling the data securely.
 * See: http://dcorgdev.devcloud.acquia-sites.com/developer-guide/core-architecture/info-hooks/payment-info-hooks
 * The Rules configuration for a specific gateway instance contains all of the additional configuration needed.
 * Essentially Commerce replicates the behavior of Gateway Manager.
 * The problem is when you do this programatically - you don't have a predictable map of values in the form to use.
 * Each gateway has a custom form, and so we need to add a plugin to Fundraiser Commerce to wrap donation submissions
 * per gateway supported. To avoid module proloferation, we'll use plugins here based on the type of gateway.
 * The gateway module itself should handle transaction creation and order updates as if the form were actually submitted.
 */
function _fundraiser_commerce_fundraiser_donation_process_internal($donation, $info) {
  // Now execute the custom charge, keeping in mind for Commerce, the charge function is a submit handler.
  $method_instance = commerce_payment_method_instance_load($info['id']); // From commerce_payment.module.
  // This gets us: The payment method instance object with the addition of the settings array. Settings are per Rule.
  // Since the plugin is only relevant in one situation, and then it's Not optional, no need to make it a module.
  // Call the function with donation, this will handle internal translation for the specific gateway.
  // A specific gateway may implement more than one form of charging (credit and PP for example) so leave that choice
  // to the execution function. All the information needed is on the donation object.
  if (isset($info['charge callback']) && function_exists($info['charge callback'])) {
    $charge_function = $info['charge callback'];
    $success = $charge_function($method_instance, $donation);
  }
  // Update the donation and order data and result values based on the success.
  _fundraiser_commerce_update_donation_result_data($donation, $success);
  // Finish up any last cleanup for this transaction.
  fundraiser_commerce_fundraiser_donation_after_process($donation);
}

/**
 * Helper function, provides external processing for supported gateways.
 * NOTE: This function includes a drupal_goto, which uses exit().
 * THIS INTERRUPTS FORM PROCESSING.
 * While we attempt to pick up form processing when the user returns, there is no gurantee.
 */
function _fundraiser_commerce_fundraiser_donation_process_external($donation, $info) {
  // Load up additional data as needed for this donation, from Fundraiser and Commerce.
  $method_instance = commerce_payment_method_instance_load($info['id']); // From commerce_payment.module.
  // Generate a key to use in the return URL from the redirected service.
  $order = commerce_order_load($donation->did);
  $order->data['payment_redirect_key'] = drupal_hash_base64(time());
  commerce_order_save($order);
  // And kick out to the export form interrupting the usual submission process.
  // drupal_goto kills the processing of the existing form. We will need to pick it back up later.
  drupal_goto('node/' . $donation->nid . '/fundraiser-redirect/' . $donation->did);
}

/**
 * Menu callback for the redirect form page.
 */
function _fundraiser_commerce_fundraiser_donation_process_external_form($form, $form_state, $did) {
  $log = t('No available redirection form.');
  // If we don't have a donation id, we can't go anywhere so we bail early.
  if (!empty($did)) {
    // Load up additional data as needed for this donation, from Fundraiser and Commerce.
    $donation = fundraiser_donation_get_donation($did);
    $order = commerce_order_load($donation->did);
    $info = _fundraiser_get_donation_gateway($donation->did);
    $method_instance = commerce_payment_method_instance_load($info['id']); // From commerce_payment.module.

    // Check if we're in the wrong spot.
    if (!$method_instance || !$method_instance['offsite']) {
      if (!$method_instance) {
        $log = t('No payment required on this donation.');
      }
      else {
        $log = t('Payment was already submitted on this donation.');
      }
    }
    // Present the form, or start the JS redirect as needed.
    // If the function to build the redirect form exists.
    if (isset($info['redirect callback']) && function_exists($info['redirect callback'])) {
      $redirect_function = $info['redirect callback'];
      // Merge the new form into the current form array, preserving the help text
      // if it exists. We also add a wrapper so the form can be easily submitted.
      // Provide common settings, the redirect function can modify these as needed before sending onwards.
      $settings = array(
        'cancel_return' => url(
          'node/' . $donation->nid . '/fundraiser-cancel/' . $order->order_id . '/' . $order->data['payment_redirect_key'],
          array('absolute' => TRUE)
        ),
        'return' => url(
          'node/' . $donation->nid . '/fundraiser-return/' .  $order->order_id . '/' . $order->data['payment_redirect_key'],
          array('absolute' => TRUE)
        ),
        'payment_method' => $method_instance['instance_id'],
      );
      $form = $redirect_function($method_instance, $donation, $order, $settings);

      // If the payment method has the 'offsite_autoredirect' option enabled, add the redirection behavior.
      if (!empty($method_instance['offsite_autoredirect'])) {
        $form['#attached']['js'][] = drupal_get_path('module', 'commerce_payment') . '/commerce_payment.js';
        $form['help']['#markup'] = '<div class="checkout-help">' . t('Please wait while you are redirected to the payment server. ' .
          'If nothing happens within 10 seconds, please click on the button above.') . '</div>';
      }

      $form['#prefix'] = '<div class="payment-redirect-form">';
      $form['#suffix'] = '</div>';
      return $form;
    }
  }
  $form['message'] = array(
    '#markup' => '<div class="fundraiser-commerce-failed-to-redirect">' . $log . '</div>',
  );
  return $form;
}

/**
 * Callback for processing a cancel on the redirect.
 */
function _fundraiser_commerce_fundraiser_donation_process_external_form_cancel($did, $redirect_key) {
  // Load up additional data as needed for this donation, from Fundraiser and Commerce.
  $donation = fundraiser_donation_get_donation($did);
  $order = commerce_order_load($donation->did);
  $info = _fundraiser_get_donation_gateway($donation->did);
  $method_instance = commerce_payment_method_instance_load($info['id']); // From commerce_payment.module.
  $log = t('Payment cancelled at the gateway.');
  // Check if we're in the wrong spot.
  if (!$method_instance || !$method_instance['offsite']) {
    if (!$method_instance) {
      $log = t('No payment required on this donation.');
    }
    else {
      $log = t('Payment was already submitted on this donation.');
    }
  }
  // On return, the the user came to the cancel page - they canceled at the gateway.
  if ($redirect_key == $order->data['payment_redirect_key']) {
    $donation->result = array(
      'success' => FALSE,
      'message' => $log,
      'data' => array(),
    );
    // And handle post processing form resolution and redirect.
    _fundraiser_commerce_fundraiser_donation_process_external_form_redirect($donation);
    // This will redirect us back to the original form and process any left over submissions.
  }
  return array(
    '#markup' => '<div class="fundraiser-commerce-failed-to-redirect">' . $log . '</div>',
  );
}

/**
 * Callback for processing a return (success or fail) on the redirect.
 */
function _fundraiser_commerce_fundraiser_donation_process_external_form_return($did, $redirect_key = '') {
  // Load up additional data as needed for this donation, from Fundraiser and Commerce.
  $donation = fundraiser_donation_get_donation($did);
  $order = commerce_order_load($donation->did);
  $info = _fundraiser_get_donation_gateway($donation->did);
  $method_instance = commerce_payment_method_instance_load($info['id']); // From commerce_payment.module.
  $log = t('Payment attempted processing at the gateway.');
  // Check if we're in the wrong spot.
  if (!$method_instance || !$method_instance['offsite']) {
    if (!$method_instance) {
      $log = t('No payment required on this donation.');
    }
    else {
      $log = t('Payment was already submitted on this donation.');
    }
  }
  // On return, the user came back to the payment page - they paid at the gateway.
  if ($redirect_key == $order->data['payment_redirect_key']) {
    // Set initial values including the failure state.
    $log = t('Payment failed at the gateway.');
    $donation->result = array(
      'success' => FALSE,
      'message' => $log,
      'data' => array(),
    );
    // Check for a validate handler on return.
    $valid = TRUE;
    if (isset($info['redirect callback']) && function_exists($info['redirect callback'] . '_validate')) {
      $validation_function = $info['redirect callback'] . '_validate';
      $valid = $validation_function($method_instance, $donation, $order);
    }
    if ($valid) {
      if (isset($info['redirect callback']) && function_exists($info['redirect callback'] . '_submit')) {
        $submit_function = $info['redirect callback'] . '_submit';
        // Perform any submit functions if necessary.
        $success = $submit_function($method_instance, $donation, $order);
        // After a callback, we need to get transaction data into order->data, donation->data for storage.
        _fundraiser_commerce_update_donation_result_data($donation, $success);
        if ($success) {
          $log = t('Payment successfully processed at the gateway.');
        }
      }
    }
    else {
      // Otherwise display the failure message and send the customer back.
      drupal_set_message(t('Payment failed at the payment server. Please review your information and try again.'), 'error');
    }
    // And handle post processing form resolution and redirect.
    _fundraiser_commerce_fundraiser_donation_process_external_form_redirect($donation);
    // This will redirect us back to the original form and process any left over submissions.
  }
  else {
    $log = t('The return key was not the same as recorded for this donation.');
  }
  return array(
    '#markup' => '<div class="fundraiser-commerce-failed-to-redirect">' . $log . '</div>',
  );
}

/**
 * Helper function, given a standard result array and donation set the data for storage.
 */
function _fundraiser_commerce_update_donation_result_data($donation, $success) {
  // If no result then presume a failure or no hook installed for this gateway type.
  if (!isset($success)) {
    $donation->result = array(
      'success' => FALSE,
      'message' => 'This payment gateway is not supported by Fundraiser Commerce.',
    );
    return; // Return the failure.
  }
  // Load the order object so we can save additional data post submit.
  $order = commerce_order_load($donation->did);
  // Transactions are made even for failures, so we need to go through to get the very last one.
  // Grab the transaction information so we can return the transaction id.
  // Use the last one in the list cause it's the last one we processed.
  $transactions = commerce_payment_transaction_load_multiple(array(), $conditions = array('order_id' => $order->order_id));
  // Loop to get the latest transaction.
  $remote_id = $transaction_id = $message = $status = $remote_status = '';
  foreach ($transactions as $transaction) {
    $message = $transaction->message;
    $remote_id = $transaction->remote_id;
    $transaction_id = $transaction->transaction_id;
    $status = $transaction->status;
    $remote_status = $transaction->remote_status;
  }
  // And update the result array success field.
  $result = array(
    'success' => $success,
    'message' => $success ? t('Donation was successfully processed.') : t('Donation transaction failed.'), // Shown to user.
    // Additional data for the order record to store.
    'data' => array(
      'txn_id' => $remote_id,
      'remote_id' => $remote_id, // The handler ID.
      'transaction_id' => $transaction_id, // The Drupal ID.
      'status' => $status, // Local status.
      'remote_status' => $remote_status, // Handler's status.
    ),
    // If a profile was created on this, it's stored in
    //'customer_profile_id' => '',
  );
  $data = $result['data'];

  // There may be information already in the donation->data.
  // We want to make sure this information propogates if it's available on the donation object already.
  if (is_array($donation->data) && !empty($donation->data)) {
    // Merge the order data with existing donation data,
    // This wil be stored on the order, encrypted, and decrypted on donation_get.
    $data = array_merge($donation->data, $data);
  }
  $donation->data = $data;
  $donation->txn_id = $remote_id; // TODO Not called anywhere locally, this may not even need to be stored.
  // Encrypt it for storage.
  $order->data['fundraiser_commerce'] = _fundraiser_commerce_order_data_prepare($donation->data);
  // Save the order again to update its line item reference field and user.
  commerce_order_save($order);
  // Pass the result up the chain.
  $donation->result = $result;
}

/**
 * Helper function, after external redirect return the user to the original submitted form.
 */
function _fundraiser_commerce_fundraiser_donation_process_external_form_redirect($donation) {
  // Grab data if it exists from the caches.
  $form_build_id = cache_get('fundraiser-form-id-' . $donation->did, 'cache');
  $form = $form_state = array();
  if (!empty($form_build_id)) {
    // Given the form build id, get the rest from the form cache.
    $form = cache_get('fundraiser-form-' . $donation->did, 'cache_form');
    $form_state = cache_get('fundraiser-form-state-' . $donation->did, 'cache_form');
  }
  // Finalize the processing (which clears the caches), and redirect the form.
  fundraiser_commerce_fundraiser_donation_after_process($donation);
  _fundraiser_donation_submit_after_process($donation);
  // If we're down to this point, we've returned from a submit redirect. In that case, we redirect the form based on success or failure.
  if (!empty($form_build_id)) {
    if (!empty($form) && !empty($form_state)) {
      $form = $form->data;
      $form_state = $form_state->data;
      // Now that we have the form and form_state as they were when we started this redirection, we can hop back in to the flow.
      // Restarting form submission on return is the only good way to make sure all form submits (including webform ones)
      // get kicked off. B/c of the redirects involved we can't pass $form, $form_state along - we need to have it in caches.
      if (!empty($form['#submit'])) {
        // On a failure we pick back up with the form submits.
        $start = FALSE;
        foreach ($form['#submit'] as $index => $submit_handler) {
          // Skip handlers until we get to post submit.
          if ($submit_handler == 'fundraiser_donation_post_submit') {
            $start = TRUE;
          }
          if (!$start) {
            unset($form['#submit'][$index]);
          }
        }
        // With the correct set of submit handlers in place, we need to pick up processing again.
        // From as if we were inside of drupal_process_form, since our goto interrupted execution.
        // The following code is from drupal_process_form().
        $form_id = $form['#build_id'];
        $form_state['#donation'] = $donation;
        // Handle the rest of the submit handlers.
        form_execute_handlers('submit', $form, $form_state);
        // Clean caches out entirely.
        if (!variable_get('cache', 0) && !empty($form_state['values']['form_build_id'])) {
          cache_clear_all('form_' . $form_state['values']['form_build_id'], 'cache_form');
          cache_clear_all('form_state_' . $form_state['values']['form_build_id'], 'cache_form');
        }
        // Process batches as needed.
        if ($batch = & batch_get() && !isset($batch['current_set'])) {
          if ($batch['has_form_submits'] || !empty($form_state['rebuild'])) {
            $batch['form_state'] = $form_state;
          }
          else {
            $batch['form_state'] = array_intersect_key($form_state,
              array_flip(array('programmed', 'rebuild', 'storage', 'no_redirect', 'redirect')));
          }
          $batch['progressive'] = !$form_state['programmed'];
          batch_process();
        }
        // Set flag.
        $form_state['executed'] = TRUE;
        // Redirect the form based on values in $form_state.
        // This will forward us to another page with a drupal goto if set.
        // This will interupt further processing like a return would.
        drupal_redirect_form($form_state);
        // But if we aren't redirecting, something went wrong and so we continue.
        // This does mean we will not rebuild a form in the even of a post-submission error.
        // That's ok though, something went critically wrong if we got to this point.
      }
    }
  }

  // If the form doesn't exist in the cache try the sid from webform
  elseif ($donation->sid) {
    module_load_include('inc', 'webform', 'includes/webform.submissions');
    $node = $donation->node;
    $sid = $donation->sid;
    $submission = webform_get_submission($node->webform['nid'], $sid, TRUE);

    /**
     * The code below is adapted from the webform module's confirmation handling
     */

    // Strip out empty tags added by WYSIWYG editors if needed.
    $confirmation = strlen(trim(strip_tags($node->webform['confirmation']))) ? $node->webform['confirmation'] : '';

    // Clean up the redirect URL and filter it for webform tokens.
    $redirect_url = trim($node->webform['redirect_url']);
    $redirect_url = _webform_filter_values($redirect_url, $node, $submission, NULL, FALSE, TRUE);

    // Remove the domain name from the redirect.
    $redirect_url = preg_replace('/^' . preg_quote($GLOBALS['base_url'], '/') . '\//', '', $redirect_url);

    // Check confirmation and redirect_url fields.
    $redirect = array(
      'path' => '',
      'options' => array(),
    );
    $external_url = FALSE;

    if ($redirect_url == '<none>') {
      $redirect['path'] = 'node/' . $node->nid;
    }
    elseif ($redirect_url == '<confirmation>') {
      $redirect = array(
        'path' => 'node/' . $node->nid . '/done',
        'options' => array('query' => array('sid' => $sid)),
      );
    }
    elseif (valid_url($redirect_url, TRUE)) {
      $redirect['path'] = $redirect_url;
      $external_url = TRUE;
    }
    elseif ($redirect_url && strpos($redirect_url, 'http') !== 0) {
      $parts = drupal_parse_url($redirect_url);
      $parts['query'] ? ($parts['query']['sid'] = $sid) : ($parts['query'] = array('sid' => $sid));
      $query = $parts['query'];
      $redirect = array(
        'path' => $parts['path'],
        'options' => array(
          'query' => $query,
          'fragment' => $parts['fragment'],
        ),
      );
    }

    // If redirecting and we have a confirmation message, show it as a message.
    if (!$external_url && (!empty($redirect_url) && $redirect_url != '<confirmation>') && !empty($confirmation)) {
      drupal_set_message(check_markup($confirmation, $node->webform['confirmation_format'], '', TRUE));
    }

    drupal_goto($redirect['path'], $redirect['options']);
  }

  // If we don't have all the information we need, then we do nothing and fall through to standard page display.
}

/**
 * Implements hook_fundraiser_donation_update().
 */
function fundraiser_commerce_fundraiser_donation_update($donation) {
  // Get basic information from the donation node.
  $user = $donation->user;
  $node = $donation->node;
  // Pick out the values we need to generate an order.
  if ($donation->donation['amount'] == 'other') {
    $donation->donation['amount'] = preg_replace('/[^\d\.]/i', '', $donation->donation['other_amount']);
  }
  $donation->donation['currency'] = isset($donation->donation['currency']) ? $donation->donation['currency'] : 'USD';
  // Determine quantity and data from donation values.
  $quantity = isset($donation->donation['quantity']) && !empty($donation->donation['quantity']) ? $donation->donation['quantity'] : 1;

  // Get the original order.
  $order = commerce_order_load($donation->did);

  // Update the amount
  if (!empty($donation->update_amount)) {
    // Update the existing line item(s) with the new value.
    $found = commerce_line_item_load_multiple(array(), array('order_id' => $order->order_id));
    $line_item_id = -1;
    foreach ($found as $id => $found) {
      $line_item_id = $id;
    }
    if ($line_item_id != -1) {
      $line_item = commerce_line_item_load($line_item_id);
    }
    else {
      $line_item = commerce_line_item_new('donation', $order->order_id);
    }
    // Update line item with the new amount information as needed.
    $line_item->line_item_label = t('Donation');
    $line_item->quantity = $quantity;
    $line_item->commerce_unit_price[LANGUAGE_NONE][0] = array(
      'amount' => commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency']),
      'currency_code' => $donation->donation['currency'],
    );
    // Make sure the line item will be included in the update for order total.
    $line_item->commerce_unit_price[LANGUAGE_NONE][0]['data'] = commerce_price_component_add(
      $line_item->commerce_unit_price[LANGUAGE_NONE][0],
      'base_price',
      array(
        'amount' => commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency']),
        'currency_code' => $donation->donation['currency'],
        'data' => array(),
      ),
      TRUE
    );
    commerce_line_item_save($line_item);
    // Add the line item to the order.
    $order->commerce_line_items[LANGUAGE_NONE][0]['line_item_id'] = $line_item->line_item_id;
  }

  // Update the billing information
  if (!empty($donation->update_billing)) {
    // Update the customer profile with new info.
    $found = commerce_customer_profile_load_multiple(array(), array('uid' => $user->uid));
    $profile_id = -1;
    foreach ($found as $id => $found) {
      $profile_id = $id;
    }
    if ($profile_id != -1) {
      $profile = commerce_customer_profile_load($profile_id);
    }
    else {
      $profile = commerce_customer_profile_new('billing', $user->uid); // Billing type comes with Commerce by default.
    }
    // Update profile with the billing information.
    $profile->commerce_customer_address[LANGUAGE_NONE][0] = addressfield_default_values();
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['country'] = $donation->donation['country'];
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line'] = $donation->donation['first_name'] . ' ' . $donation->donation['last_name'];
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['first_name'] = $donation->donation['first_name'];
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['last_name'] = $donation->donation['last_name'];
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['administrative_area'] = $donation->donation['state'];
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['thoroughfare'] = $donation->donation['address'];
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['premise'] = $donation->donation['address_line_2'];
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['locality'] = $donation->donation['city'];
    $profile->commerce_customer_address[LANGUAGE_NONE][0]['postal_code'] = $donation->donation['zip'];
    commerce_customer_profile_save($profile);
    $order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id'] = $profile->profile_id;
  }

  // Update the payment information
  if (!empty($donation->update_payment)) {
    // Allow the gateways to clean the data before going to the update function
    if (isset($donation->gateway['cleanup callback']) && function_exists($donation->gateway['cleanup callback'])) {
      $cleaned = $donation->gateway['cleanup callback']($donation->donation, $donation->donation['payment_method']);
      $donation->donation['payment_fields'] = $cleaned['payment_fields'];
    }

    // Update the gateway's stored data.
    // Gateways that allow recurring donation will have an update callback
    $update_callback = isset($donation->gateway['update callback']) && function_exists($donation->gateway['update callback']) ? $donation->gateway['update callback'] : FALSE;

    // If we're in a sustainer update, and this is the first record update the stored payment information
    if (!empty($donation->sustainer_update) && !empty($donation->sustainer_update_first) && $update_callback) {
      // Load the current card data for updating
      $card_data = _fundraiser_commerce_donation_cardonfile_card($donation);
      $update_callback($donation, $card_data);
    }
    // Sustainer update, update remaining donations with the first record's cardonfile id
    // This avoids calling the APIs for each donation
    elseif (!empty($donation->sustainer_update) && !empty($donation->sustainer_update_did)) {
      $master = fundraiser_donation_get_donation($donation->sustainer_update_did);
      $donation->data['cardonfile'] = $master->data['cardonfile'];
    }

    // Allow the gateways to scrub the data before saving
    $scrubbed_fields = $donation->donation['payment_fields'];
    if (isset($donation->gateway['scrub callback']) && function_exists($donation->gateway['scrub callback'])) {
      $scrubbed_fields = $donation->gateway['scrub callback']($scrubbed_fields, $donation->donation['payment_method']);
    }

    // Add the fields to the data array
    $donation->data['payment_fields'] = $scrubbed_fields;
  }

  // Add the status data.
  $donation->status = $donation->status_label = isset($order->status) ? $order->status : 'unknown';
  if (!empty($order->status)) {
    $donation->status_label = _fundraiser_commerce_get_label_by_status($order->status);
    $donation->status_charged = _fundraiser_commerce_get_charged_by_status($order->status);
  }

  // Save the updated data array to the order's data column
  $order->data['fundraiser_commerce'] = _fundraiser_commerce_order_data_prepare($donation->data);

  // Save the order
  commerce_order_save($order);
}

/**
 * Implements hook_fundraiser_donation_success().
 */
function fundraiser_commerce_fundraiser_donation_success($donation) {
  // Mark as complete.
  _fundraiser_commerce_update_order_status('payment_received', $donation->did);
  $donation->status = 'payment_received';
  $donation->status_label = _fundraiser_commerce_get_label_by_status('payment_received');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('payment_received');
}

/**
 * Implements hook_fundraiser_donation_decline().
 */
function fundraiser_commerce_fundraiser_donation_decline($donation) {
  // Mark the sale in commerce as failed.
  _fundraiser_commerce_update_order_status('failed', $donation->did);
  $donation->status = 'failed';
  $donation->status_label = _fundraiser_commerce_get_label_by_status('failed');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('failed');
}

/**
 * Implements hook_fundraiser_donation_exception().
 */
function fundraiser_commerce_fundraiser_donation_exception($donation) {
  return fundraiser_commerce_fundraiser_donation_decline($donation);
}

/**
 * Implements hook_fundraiser_donation_cancel().
 */
function fundraiser_commerce_fundraiser_donation_cancel($donation) {
  // Mark the sale in commerce as canceled.
  _fundraiser_commerce_update_order_status('canceled', $donation->did);
  $donation->status = 'canceled';
  $donation->status_label = _fundraiser_commerce_get_label_by_status('canceled');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('canceled');
}

/**
 * Implements hook_fundraiser_donation_delete().
 */
function fundraiser_commerce_fundraiser_donation_delete($donation) {
  // Mark the sale in commerce as canceled.
  _fundraiser_commerce_update_order_status('canceled', $donation->did);
  $donation->status = 'canceled';
  $donation->status_label = _fundraiser_commerce_get_label_by_status('canceled');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('canceled');
}

/**
 * Implements hook_fundraiser_refund_process().
 */
function fundraiser_commerce_fundraiser_refund_process($refund) {
  // Grab the gateway configuration from fundraisers data.
  $donation = fundraiser_donation_get_donation($refund->did);
  $info = _fundraiser_get_donation_gateway($refund->did);
  $method_instance = commerce_payment_method_instance_load($info['id']); // From commerce_payment.module.
  // This gets us: The payment method instance object with the addition of the settings array. Settings are per Rule.
  // Choose which of two ways to process this.
  if (in_array($donation->donation['payment_method'], $info['offsite_processing'])) {
    // If external processing, we cannot execute a refund charge against it.
    drupal_set_message(t('The %title payment method indicates it is offsite processing, and cannot be refunded through this interface.',
      array('%title' => $method_instance['title'])), 'error');
  }
  else {
    if (empty($info['refund callback'])) {
      // Alert the administrator that the module does not provide a required form.
      drupal_set_message(t('The %title payment method does not provide a gateway refund function.',
        array('%title' => $method_instance['title'])), 'error');
      // We can't find the gateway and we should tell someone about it.
      watchdog('fundraiser', 'Cannot determine the payment gateway for refund @id. Node id of refund form is @nid',
        array('@id' => $refund->did, '@nid' => $donation->nid), WATCHDOG_CRITICAL);
      watchdog('fundraiser_commerce', 'Refund function :function is empty.', array(':function' => $info['refund callback']));
      $donation->result = array(
        'success' => FALSE,
        'message' => 'Cannot determine the payment gateway for this refund.',
      );
      return; // Return the failure.
    }
  }
  // And process.
  // Now execute the custom charge, keeping in mind for Commerce, the charge function is a submit handler.
  if (isset($info['refund callback']) && function_exists($info['refund callback'])) {
    $refund->donation = $donation;
    $refund_function = $info['refund callback'];
    $success = $refund_function($method_instance, $refund);
  }
  // Update the donation and order data and result values based on the success.
  _fundraiser_commerce_update_donation_result_data($donation, $success);
  // Finish up any last cleanup for this transaction.
  if (isset($donation->result['success']) && $donation->result['success']) {
    $refund->result = $donation->result;
    // Set the values donation needs for the rest of the system.
    $order = commerce_order_load($refund->did);
    // Add the status data.
    $refund->status = $donation->status = $donation->status_label = isset($order->status) ? $order->status : 'unknown';
    if (!empty($order->status)) {
      $donation->status_label = _fundraiser_commerce_get_label_by_status($order->status);
      $donation->status_charged = _fundraiser_commerce_get_charged_by_status($order->status);
    }
    $refund->donation = $donation;
    $refund->receipt_id = $donation->result['data']['remote_id'];
    $refund->txn_id = $donation->result['data']['txn_id'];
  }
}

/**
 * Implements hookfundraiser_refund_success().
 */
function fundraiser_commerce_fundraiser_refund_success($refund) {
  // Mark as complete.
  _fundraiser_commerce_update_order_status($refund->new_status, $refund->did);
  $refund->status = $refund->donation->status = $refund->new_status;
  $refund->donation->status_label = _fundraiser_commerce_get_label_by_status($refund->new_status);
  $refund->donation->status_charged = _fundraiser_commerce_get_charged_by_status($refund->new_status);
}

/**
 * Implements hook_fundraiser_refund_decline().
 */
function fundraiser_commerce_fundraiser_refund_decline($refund) {
  // Mark as failed to refund.
  _fundraiser_commerce_update_order_status('failed_refund', $refund->did);
  $refund->status = $refund->donation->status = 'failed_refund';
  $refund->donation->status_label = _fundraiser_commerce_get_label_by_status('failed_refund');
  $refund->donation->status_charged = _fundraiser_commerce_get_charged_by_status('failed_refund');
}

/**
 * Implements hook_salesforce_donation_statuses().
 */
function fundraiser_commerce_salesforce_donation_statuses() {
  // Get a list of available statuses, and return that list to salesforce donation.
  $available_statuses = array();
  $order_statuses = commerce_order_statuses();
  foreach ($order_statuses as $name => $order_status) {
    $available_statuses[$name] = $order_status['title'] . ' (' . t('Commerce') . ')';
  }
  return $available_statuses;
}

/**
 * Helper function, derives a valid username from an e-mail address.
 */
function _fundraiser_commerce_email_to_username($email) {
  $name = substr($email, 0, strpos($email, '@'));
  $name = preg_replace('/[^A-Za-z0-9_.-]/', '', $name);
  $name = trim(substr($name, 0, USERNAME_MAX_LENGTH - 4));
  // Make sure we don't hand out a duplicate username.
  while (db_query('SELECT COUNT(uid) FROM {users} WHERE name LIKE :name', array(':name' => $name))->fetchField() > 0) {
    if (strlen($name) == USERNAME_MAX_LENGTH) {
      $name = substr($name, 0, USERNAME_MAX_LENGTH - 4);
    }
    $name .= rand(0, 9);
  }
  return $name;
}

/**
 * Helper function, given a card number return likely type.
 */
function _fundraiser_commerce_get_cc_type($cardnumber) {
  $cardtype = 'UNKNOWN';
  $len = drupal_strlen($cardnumber);
  if ( $len == 15 && drupal_substr($cardnumber, 0, 1) == '3' ) {
    $cardtype = 'amex';
  }
  elseif ( $len == 16 && drupal_substr($cardnumber, 0, 4) == '6011' ) {
    $cardtype = 'discover';
  }
  elseif ( $len == 16 && drupal_substr($cardnumber, 0, 1) == '5' ) {
    $cardtype = 'mc';
  }
  elseif ( ($len == 16 || $len == 13) && drupal_substr($cardnumber, 0, 1) == '4' ) {
    $cardtype = 'visa';
  }
  return ( $cardtype );
}

/**
 * Helper function, gather commerces country information into a central location.
 */
function fundraiser_commerce_get_countries() {
  $return_data = &drupal_static(__FUNCTION__);
  if (empty($return_data)) {
    $return_data = new stdClass();

    // Try hitting cache first.
    $cache = cache_get(__FUNCTION__);
    if (isset($cache) && !empty($cache->data)) {
      // cache_get() was a hit, so add to static cache.
      $return_data = $cache->data;
    }
    else {
      // cache_get() was a miss, so generate the data.
      $countries = array();
      $zones = array();
      // Gather an array of countries.
      $found_countries = _fundraiser_commerce_get_countries();
      foreach ($found_countries as $found_country) {
        // First load up id, name, iso code 2, iso code 3, and version from commerce.
        $countries[$found_country->country_id] = $found_country;
        $countries[$found_country->country_id]->zones = array();
        $found_zones = _fundraiser_commerce_get_zone_by_country($found_country->country_id);
        foreach ($found_zones as $found_zone) {
          // For each zone load up, zone_id, zone country_id, zone, code, zone_name.
          // Store in the country and zone arrays.
          $countries[$found_country->country_id]->zones[$found_zone->zone_id] = $found_zone;
          $zones[$found_zone->zone_id] = $found_zone;
        }
      }
      $return_data->countries = $countries;
      $return_data->zones = $zones;

      // Save into cache.
      cache_set(__FUNCTION__, $return_data);
    }
  }
  return $return_data;
}

/**
 * Helper function, update order status on a order.
 */
function _fundraiser_commerce_update_order_status($status, $order_id) {
  // Commerce order provides four statuses: canceled, pending, processing, completed.
  // We provide (or alter the names of) more: pending_future_payment, failed, refunded, partially_refunded
  $order = commerce_order_load($order_id);
  commerce_order_status_update($order, $status, FALSE); // Do not skip saving the order here.
}

/**
 * Helper function, look in country table for country info.
 */
function _fundraiser_commerce_get_countries() {
  // Commerce does not store countries in a database, it relies instead on locale.inc
  $countries = array();
  // Necessary for country_get_list().
  require_once DRUPAL_ROOT . '/includes/locale.inc';
  $drupal_countries = country_get_list();
  foreach ($drupal_countries as $iso => $human_name) {
    $country['country_id'] = $iso;
    $country['country_name'] = $human_name;
    $country['iso'] = $iso;
    $countries[] = (object) $country;
  }
  return $countries;
}

/**
 * Helper function, look in zone table for zone info.
 */
function _fundraiser_commerce_get_zone_by_country($country_id) {
  // Commerce does not store countries in a database, it relies instead on locale.inc
  // And a hard coded addressfield form widget for zone level information.
  // In order to retrieve this information from Commerce, we need to call the addressfield widget
  // And pull it from the form. The results will be different for each zone, and we can't grab them
  // all at once. So thankfully we don't need to the way the rest of the system is designed.
  // Some countries will have states, and do NOT have them listed here. UC has a more complete list.
  // So we will need to leave those available for users to fill in as blanks.
  module_load_include('inc', 'addressfield', 'plugins/format/address');
  $address['country'] = $country_id;
  addressfield_format_address_generate($form, $address, array('mode' => '')); // Data is loaded into $form
  $zones = array();
  if (isset($form['locality_block']['administrative_area']['#options'])) {
    foreach ($form['locality_block']['administrative_area']['#options'] as $iso => $human_name) {
      $zone['zone_id'] = $iso;
      $zone['country_id'] = $country_id;
      $zone['zone_name'] = $human_name;
      $zone['iso'] = $iso;
      $zones[] = (object) $zone;
    }
  }
  return $zones;
}

/**
 * Helper function. Translate status to status label.
 */
function _fundraiser_commerce_get_label_by_status($status) {
  // Grab the human readable label for the status.
  return commerce_order_status_get_title($status); // The machine name of the declares state, we need the human readable label.
}

/**
 * Helper function, determine if given this status the donation has been charged already.
 */
function _fundraiser_commerce_get_charged_by_status($status) {
  $chargable_states = array('pending'); // Commerce order provides three states: canceled, pending, completed.
  $status = commerce_order_status_load($status);
  if (in_array($status['state'], $chargable_states)) {
    return FALSE; // If the donation is still able to be charged, say it hasn't been.
  }
  return TRUE;
}

/**
 * Prepare the fundraiser commerce order data for storage
 */
function _fundraiser_commerce_order_data_prepare($data) {
  $encrypted = _fundraiser_commerce_encrypt(serialize($data));

  // Check to ensure the correct encryption was used
  $encryption_array = unserialize($encrypted);
  if (!isset($encryption_array['method']) || $encryption_array['method'] != 'mcrypt_rij_256' || !isset($encryption_array['key_name']) || $encryption_array['key_name'] != 'secure_file_key') {
    watchdog('fundraiser_commerce', 'The encryption module has not been configured correctly. You may need to patch or update your version.', array(), WATCHDOG_EMERGENCY, l('Fix', 'admin/config/system/encrypt'));
    return FALSE;
  }

  return $encrypted;
}

/**
 * Retrieve the fundraiser commerce order data
 */
function _fundraiser_commerce_order_data_retrieve($data) {
  $decrypted = _fundraiser_commerce_decrypt($data);
  if (is_string($decrypted) && $unserialized = @unserialize($decrypted)) {
    return $unserialized;
  }
  return $decrypted;
}

/**
 * Helper function, wrapper for encrypt function.
 */
function _fundraiser_commerce_encrypt($input) {
  if (module_exists('encrypt')) {
    module_load_install('encrypt');
    $requirements = encrypt_requirements('runtime');
    if (isset($requirements['encrypt_keys']) && $requirements['encrypt_keys']['severity'] == REQUIREMENT_ERROR) {
      drupal_set_message(t('A problem was found with your secure key.') . ' ' .
        $requirements['encrypt_keys']['value'], 'warning');
    }
    else {
      return encrypt($input);
    }
  }
  return $input;
}

/**
 * Helper function, wrapper for decrypt function.
 */
function _fundraiser_commerce_decrypt($input) {
  if (module_exists('encrypt')) {
    module_load_install('encrypt');
    $requirements = encrypt_requirements('runtime');
    if (isset($requirements['encrypt_keys']) && $requirements['encrypt_keys']['severity'] == REQUIREMENT_ERROR) {
      drupal_set_message(t('A problem was found with your secure key.') . ' ' .
        $requirements['encrypt_keys']['value'], 'warning');
    }
    else {
      return decrypt($input);
    }
  }
  return $input;
}

/**
 * Implements hook_fundraiser_get_total_donations_by_nids().
 */
function fundraiser_commerce_fundraiser_get_total_donations_by_nids($nids, $start = FALSE, $end = FALSE) {
  // Since more than one goal may target this nid with differing date ranges we
  // can't cache this.

  // This would normally use the commerce_order table and do two JOINs,
  // but here we use the derived values in fundraiser_donation to speed up
  // the query.
  // Having an index on fd.status also helps of course.
  // (commerce_order doesn't have that index.)
  $query = db_select('fundraiser_donation', 'fd');
  $query->addExpression('SUM(fd.amount)', 'total');
  $query->condition('fd.nid', $nids, 'IN');
  $query->condition('fd.status', 'payment_received', '=');
  if ($start) {
    $query->condition('fd.created', $start, '>=');
  }
  if ($end) {
    $query->condition('fd.created', $end, '<=');
  }

  // This result will already be in dollars.
  return $query->execute()->fetchField();
}

/**
 * Implements hook_rules_data_info_alter().
 */
function commerce_payment_rules_data_info_alter(&$data) {
  if (!empty($data['commerce_payment_settings'])) {
    $data['commerce_payment_settings'] = array(
      'label' => t('Payment settings'),
      'ui class' => 'FundraiserCommerceUIPaymentSettings',
    );
  }
  return $data;
}

/**
 * Adds a payment method settings form to the enabling action.
 */
class FundraiserCommerceUIPaymentSettings extends RulesDataUI implements RulesDataDirectInputFormInterface {
  public static function getDefaultMode() {
    return 'input';
  }

  public static function inputForm($name, $info, $settings, RulesPlugin $element) {
    // If the specified payment method exists...
    if (!empty($info['payment_method']) && $payment_method = commerce_payment_method_load($info['payment_method'])) {
      $form[$name]['method_id'] = array(
        '#type' => 'value',
        '#value' => $info['payment_method'],
      );

      // If the payment method has a settings callback...
      if ($callback = commerce_payment_method_callback($payment_method, 'settings_form')) {
        // Prepare an array of payment method settings defaults.
        $method_settings = !empty($settings[$name]['settings']) && is_array($settings[$name]['settings']) ? $settings[$name]['settings'] : array();

        // Add the settings form elements to the action form.
        $form[$name]['settings'] = $callback($method_settings);
      }

      // Add the remote recurring option if the module supports it.
      module_load_include('inc', 'fundraiser_commerce', '/gateways/' . $payment_method['module']);
      $gateway_info = module_invoke($payment_method['module'], 'fundraiser_commerce_fundraiser_gateway_info');
      if (!empty($gateway_info['allow_recurring']) && !empty($gateway_info['offsite_recurring'])) {
        $form[$name]['settings']['offsite_recurring'] = array(
          '#type' => 'checkbox',
          '#title' => t('Offsite recurring donations'),
          '#description' => t('Handle recurring donations offsite at the gateway.'),
          '#default_value' => isset($settings['payment_method']['settings']['offsite_recurring']) ? $settings['payment_method']['settings']['offsite_recurring'] : FALSE,
        );
      }
    }
    else {
      $form[$name]['invalid']['#markup'] = t('Invalid or missing payment method.');
    }
    return $form;
  }

  public static function render($value) {
    return array();
  }
}

/**
 * Given a donation, determine when the payment method expires.
 *
 * @param object $donation
 *   The donation object.
 *
 * @return NULL|array
 *   An array with 'month' and 'year' keys.
 */
function fundraiser_commerce_get_payment_method_expiration_date_from_donation($donation) {
  if (isset($donation->gateway['expire callback'])) {
    $expiration_func = $donation->gateway['expire callback'];
    if (function_exists($expiration_func)) {
      $expires = $expiration_func($donation->donation);
      if (isset($expires['month']) && isset($expires['year'])) {
        return $expires;
      }
    }
  }

  return NULL;
}

/**
 * Supported gateway hooks.
 * Some gateways in order to integrate with the fundraiser_commerce system must implement hooks.
 * As the /inc files for those gateways are not automatically included, we must include those hooks
 * internally to allow Drupal to pick up on the implementation. The space below is reserved for those.
 */

/**
 * Implements hook_commerce_paypal_ipn_process().
 */
function fundraiser_commerce_commerce_paypal_ipn_process($order, $payment_method, $ipn) {
  // If the user executes the transaction and then abandons at Paypal, not returning to fundraiser_commerce's
  // return path and not triggering anything in _fundraiser_commerce_fundraiser_donation_process_external_form_return()
  // Therefore we need to finish completion at the IPN transaction process path.

  // We skip this step for so long as a pending is in play.
  if ($ipn['payment_status'] == 'Pending') {
    return;
  }
  // Anything else, except Completed counts as a fail.
  $success = FALSE;
  if ($ipn['payment_status'] == 'Completed') {
    $success = TRUE;
  }
  // Grab the donation object from the order.
  $donation = fundraiser_donation_get_donation($order->order_id);
  // Update the donation and order data and result values based on the success.
  _fundraiser_commerce_update_donation_result_data($donation, $success);
  // Finish up any last cleanup for this transaction.
  fundraiser_commerce_fundraiser_donation_after_process($donation);
  // Save the donation
  fundraiser_donation_update($donation);
  // Finish up the submission to kick off success / decline triggers.
  _fundraiser_donation_submit_after_process($donation);
}

/**
 * Add values to the pane_values array before they go to the commerce submit handler
 *
 * @param $pane_values Array
 *    Values to be sent to a commerce payment processor, passed by reference
 * @return nothing
 */
function _fundraiser_commerce_submit_handler_pane_values(&$pane_values, $donation) {
  // If card on file is enabled check if we should create a new profile
  if (module_exists('commerce_cardonfile')) {
    // Load any existing card data
    $card = _fundraiser_commerce_donation_cardonfile_card($donation);

    // If this is not a reference charge be sure to store the card data and set the new flag
    if ($donation->reference_charge === FALSE) {
      // If there is not an existing card then set the store flag to TRUE
      // This ensures card on file integrations create new profiles only for new cards
      if (empty($card)) {
        $pane_values['credit_card']['cardonfile_store'] = TRUE;
      }
      else {
        $pane_values['credit_card']['cardonfile_store'] = FALSE;

        // Also set this value on the donation for saving later
        $donation->data['cardonfile'] = $card->card_id;
      }

      // To avoid using a stored CIM to charge set this value to new even for existing cards
      $pane_values['cardonfile'] = 'new';
    }
    // For reference charges add the cardonfile id
    elseif ($donation->reference_charge == TRUE) {
      // Load the card on file card card data
      if (!empty($card)) {
        $pane_values['cardonfile'] = $card->card_id;
      }
      else {
        // Log the missing card data
        watchdog(
          'fundraiser',
          'A reference charge was attempted on donation @id but no stored card data was found.',
          array('@id' => $donation->did),
          WATCHDOG_CRITICAL
        );
      }
    }
  }
  // Allow other modules to alter the pane values
  drupal_alter('fundraiser_commerce_submit_handler_pane_values', $pane_values, $donation);
}

/**
 * Perform some standard functions after a commerce submit form has been processed
 *
 * @param $success Boolean
 *    TRUE or FALSE
 * @param $method_instance Array
 *    Details on the gateway
 * @param $pane_values Array
 *    Values passed to the commerce submit handler
 * @param $donation Object
 *    Fundraiser donation object
 * @return nothing
 */
function _fundraiser_commerce_charge_submit_form_process($success, $method_instance, $pane_values, $donation) {
  // If this charge resulted in a new card on file save that to the donation
  if ($success && module_exists('commerce_cardonfile') && !empty($pane_values['credit_card']['cardonfile_store'])) {
    // Load up the cardonfile record for this donation and save it
    $card = _fundraiser_commerce_donation_cardonfile_card($donation);
    $donation->data['cardonfile'] = $card->card_id;
  }
}

/**
 * Load the card on file card data for a donation
 *
 * @param $donation Object
 *    Fundraiser donation object
 * @param $active boolean
 *    Flag to select only active cards, defaults to TRUE
 * @return Object
 *    Card on file card entity
 */
function _fundraiser_commerce_donation_cardonfile_card($donation, $active = TRUE) {
  // If this donation has the cardonfile value set in its data array, load the card data from that
  if (!empty($donation->data['cardonfile'])) {
    return commerce_cardonfile_load($donation->data['cardonfile']);
  }

  // Allow modules to provide their own card on file profile field values
  if (!empty($donation->gateway['cardonfile callback'])) {
    $cardonfile_fields = $donation->gateway['cardonfile callback']($donation);
  }
  // If this is a credit purchase use the default credit function
  elseif ($donation->donation['payment_method'] == 'credit') {
    module_load_include('inc', 'fundraiser_commerce', 'includes/fundraiser_commerce.credit_card');
    $cardonfile_fields = _fundraiser_commerce_credit_card_cardonfile_fields($donation);
  }

  if (empty($cardonfile_fields)) {
    return FALSE;
  }

  return _fundraiser_commerce_cardonfile_match($cardonfile_fields, $active = TRUE);
}

/**
 * Search the card on file table for a record
 *
 * @param $fields Array
 *    Array of fields to search card on file table
 * @return Object
 *    Card on file card entity or FALSE if no record
 */
function _fundraiser_commerce_cardonfile_match($fields, $active = TRUE) {
  // Query for the card on file profile using the provided values
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_cardonfile')
  ->propertyCondition('uid', $fields['uid'])
  ->propertyCondition('instance_id', $fields['instance_id'])
  ->propertyCondition('card_number', $fields['card_number']);

  if (!empty($fields['card_exp_month'])) {
    $query->propertyCondition('card_exp_month', $fields['card_exp_month']);
  }

  if (!empty($fields['card_exp_year'])) {
    $query->propertyCondition('card_exp_year', $fields['card_exp_year']);
  }

  if ($active) {
    $query->propertyCondition('status', TRUE);
  }

  $result = $query->execute();

  if (isset($result['commerce_cardonfile'])) {
    $ids = array_keys($result['commerce_cardonfile']);
    return commerce_cardonfile_load($ids[0]);
  }
  else {
    return FALSE;
  }
}

/**
 * Search the card on file table for a record that doesn't match the date
 *
 * @param $fields Array
 *    Array of fields to search card on file table
 * @return Object
 *    Card on file card entity or FALSE if no record
 */
function _fundraiser_commerce_cardonfile_exp_date_mismatch($fields) {
  // Create the date or portion of the query
  $date_or = db_or()
  ->condition('c.card_exp_month', $fields['card_exp_month'], '<>')
  ->condition('c.card_exp_year', $fields['card_exp_year'], '<>');

  // Query the db for an existing record
  $existing = db_select('commerce_cardonfile', 'c')
  ->fields('c', array('card_id'))
  ->condition('c.uid', $fields['uid'], '=')
  ->condition('c.instance_id', $fields['instance_id'], '=')
  ->condition('c.card_number', $fields['card_number'], '=')
  ->condition($date_or)
  ->range(0, 1)
  ->execute()
  ->fetchField();

  if ($existing) {
    return commerce_cardonfile_load($existing);
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_commerce_authnet_cim_request_alter
 */
function fundraiser_commerce_commerce_authnet_cim_request_alter($api_request_element) {

  if (!empty($api_request_element->transaction->profileTransAuthCapture->order->invoiceNumber)) {
    $did = (string) $api_request_element->transaction->profileTransAuthCapture->order->invoiceNumber;
    $donation = fundraiser_donation_get_donation($did);
    $config = $donation->gateway['gateway_details']['settings'];
    $extra = (string) $api_request_element->extraOptions;
    $extra = substr($extra, 9, -3);
    $fields = _commerce_authnet_extra_fields();
    unset($fields[0]);
    $i = 1;
    foreach ($fields as $field) {
      if (isset($config['commerce_authnet_webform_field_' . $i]) && isset($donation->submission_data[$config['commerce_authnet_webform_field_' . $i]])) {
        $name = $fields[$config['commerce_authnet_authorize_field_' . $i]];
        $value =  $donation->submission_data[$config['commerce_authnet_webform_field_' . $i]];
        $value = str_replace(array("&","'",'"',"|"), array("%26","%27","%22","%7C"), $value); 
        $extra .= '&' . trim($name) . '=' . trim($value);
      }
      $i++;
    }
    $api_request_element->extraOptions = '<![CDATA[' .  $extra . '&cms=Springboard]]>';
  }
  // Change the description to something unique so we get a new profile each time
  if (!empty($api_request_element->profile->description)) {
    $api_request_element->profile->description = substr(t('CIM request taking place at @date', array('@date' => format_date(time()))), 0, 255);
  }
}
